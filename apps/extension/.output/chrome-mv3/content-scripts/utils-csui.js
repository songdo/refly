var _utils_csui = function() {
  "use strict";var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

  var _a, _b, _isTopFrame, _abortController, _locationWatcher, __ContentScriptContext_instances, stopOldScripts_fn, listenForNewerScripts_fn;
  var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsxDevRuntime = { exports: {} };
  var reactJsxDevRuntime_development = {};
  var react = { exports: {} };
  var react_development = { exports: {} };
  react_development.exports;
  (function(module, exports) {
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i2 = 0; i2 < children.length; i2++) {
              child = children[i2];
              nextName = nextNamePrefix + getElementKey(child, i2);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result2 = [];
          var count = 0;
          mapIntoArray(children, result2, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result2;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key = keys[i2];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              validateChildKeys(arguments[i2], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i2 = 2; i2 < arguments.length; i2++) {
            validateChildKeys(arguments[i2], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result2;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result2 = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result2 !== null && typeof result2 === "object" && typeof result2.then === "function") {
              var thenableResult = result2;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result2;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i2 = 0;
              try {
                for (; i2 < queue.length; i2++) {
                  var callback = queue[i2];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i2 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(react_development, react_development.exports);
  var react_developmentExports = react_development.exports;
  {
    react.exports = react_developmentExports;
  }
  var reactExports = react.exports;
  /**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      var React = reactExports;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i2 = 0; i2 < children.length; i2++) {
                    validateChildKeys(children[i2], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      reactJsxDevRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxDevRuntime_development.jsxDEV = jsxDEV$1;
    })();
  }
  {
    jsxDevRuntime.exports = reactJsxDevRuntime_development;
  }
  var jsxDevRuntimeExports = jsxDevRuntime.exports;
  function defineContentScript(definition2) {
    return definition2;
  }
  var client = {};
  var reactDom = { exports: {} };
  var reactDom_development = {};
  var scheduler = { exports: {} };
  var scheduler_development = {};
  (function(exports) {
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i2) {
          var index = i2;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i2) {
          var index = i2;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            var currentTime;
            if (enableProfiling) ;
            else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && true) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(scheduler_development);
  {
    scheduler.exports = scheduler_development;
  }
  var schedulerExports = scheduler.exports;
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React = reactExports;
      var Scheduler = schedulerExports;
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var suppressWarning = false;
      function setSuppressWarning(newSuppressWarning) {
        {
          suppressWarning = newSuppressWarning;
        }
      }
      function warn(format) {
        {
          if (!suppressWarning) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          if (!suppressWarning) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedFragment = 18;
      var SuspenseListComponent = 19;
      var ScopeComponent = 21;
      var OffscreenComponent = 22;
      var LegacyHiddenComponent = 23;
      var CacheComponent = 24;
      var TracingMarkerComponent = 25;
      var enableClientRenderFallbackOnTextMismatch = true;
      var enableNewReconciler = false;
      var enableLazyContextPropagation = false;
      var enableLegacyHidden = false;
      var enableCustomElementPropertySupport = false;
      var warnAboutStringRefs = true;
      var enableSchedulingProfiler = true;
      var enableProfilerTimer = true;
      var enableProfilerCommitHooks = true;
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      var possibleRegistrationNames = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        {
          if (registrationNameDependencies[registrationName]) {
            error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
          }
        }
        registrationNameDependencies[registrationName] = dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          if (registrationName === "onDoubleClick") {
            possibleRegistrationNames.ondblclick = registrationName;
          }
        }
        for (var i2 = 0; i2 < dependencies.length; i2++) {
          allNativeEvents.add(dependencies[i2]);
        }
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkPropStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkFormFieldValueStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) {
          return propertyInfo.type === RESERVED;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return true;
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value === "undefined") {
          return true;
        }
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
          return true;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value;
            case OVERLOADED_BOOLEAN:
              return value === false;
            case NUMERIC:
              return isNaN(value);
            case POSITIVE_NUMERIC:
              return isNaN(value) || value < 1;
          }
        }
        return false;
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          true,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          false,
          // sanitizeURL
          false
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        false,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        // sanitizeURL
        false
      );
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          true,
          // sanitizeURL
          true
        );
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      function getValueForProperty(node, name, expected, propertyInfo) {
        {
          if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node[propertyName];
          } else {
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL("" + expected);
            }
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
              if (node.hasAttribute(attributeName)) {
                var value = node.getAttribute(attributeName);
                if (value === "") {
                  return true;
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return value;
                }
                if (value === "" + expected) {
                  return expected;
                }
                return value;
              }
            } else if (node.hasAttribute(attributeName)) {
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return node.getAttribute(attributeName);
              }
              if (propertyInfo.type === BOOLEAN) {
                return expected;
              }
              stringValue = node.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
              return stringValue === null ? expected : stringValue;
            } else if (stringValue === "" + expected) {
              return expected;
            } else {
              return stringValue;
            }
          }
        }
      }
      function getValueForAttribute(node, name, expected, isCustomComponentTag) {
        {
          if (!isAttributeNameSafe(name)) {
            return;
          }
          if (!node.hasAttribute(name)) {
            return expected === void 0 ? void 0 : null;
          }
          var value = node.getAttribute(name);
          {
            checkAttributeStringCoercion(expected, name);
          }
          if (value === "" + expected) {
            return expected;
          }
          return value;
        }
      }
      function setValueForProperty(node, name, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name);
        if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
          return;
        }
        if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
          value = null;
        }
        if (isCustomComponentTag || propertyInfo === null) {
          if (isAttributeNameSafe(name)) {
            var _attributeName = name;
            if (value === null) {
              node.removeAttribute(_attributeName);
            } else {
              {
                checkAttributeStringCoercion(value, name);
              }
              node.setAttribute(_attributeName, "" + value);
            }
          }
          return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          if (value === null) {
            var type = propertyInfo.type;
            node[propertyName] = type === BOOLEAN ? false : "";
          } else {
            node[propertyName] = value;
          }
          return;
        }
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value === null) {
          node.removeAttribute(attributeName);
        } else {
          var _type = propertyInfo.type;
          var attributeValue;
          if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
            attributeValue = "";
          } else {
            {
              {
                checkAttributeStringCoercion(value, attributeName);
              }
              attributeValue = "" + value;
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL(attributeValue.toString());
            }
          }
          if (attributeNamespace) {
            node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
          } else {
            node.setAttribute(attributeName, attributeValue);
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_CACHE_TYPE = Symbol.for("react.cache");
      var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      function describeFiber(fiber) {
        fiber._debugOwner ? fiber._debugOwner.type : null;
        fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef:
            return describeFunctionComponentFrame(fiber.type.render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          var node = workInProgress2;
          do {
            info += describeFiber(node);
            node = node.return;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      function getWrappedName$1(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName$1(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromFiber(fiber) {
        var tag = fiber.tag, type = fiber.type;
        switch (tag) {
          case CacheComponent:
            return "Cache";
          case ContextConsumer:
            var context = type;
            return getContextName$1(context) + ".Consumer";
          case ContextProvider:
            var provider = type;
            return getContextName$1(provider._context) + ".Provider";
          case DehydratedFragment:
            return "DehydratedFragment";
          case ForwardRef:
            return getWrappedName$1(type, type.render, "ForwardRef");
          case Fragment:
            return "Fragment";
          case HostComponent:
            return type;
          case HostPortal:
            return "Portal";
          case HostRoot:
            return "Root";
          case HostText:
            return "Text";
          case LazyComponent:
            return getComponentNameFromType(type);
          case Mode:
            if (type === REACT_STRICT_MODE_TYPE) {
              return "StrictMode";
            }
            return "Mode";
          case OffscreenComponent:
            return "Offscreen";
          case Profiler:
            return "Profiler";
          case ScopeComponent:
            return "Scope";
          case SuspenseComponent:
            return "Suspense";
          case SuspenseListComponent:
            return "SuspenseList";
          case TracingMarkerComponent:
            return "TracingMarker";
          case ClassComponent:
          case FunctionComponent:
          case IncompleteClassComponent:
          case IndeterminateComponent:
          case MemoComponent:
          case SimpleMemoComponent:
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            break;
        }
        return null;
      }
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var current = null;
      var isRendering = false;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }
          var owner = current._debugOwner;
          if (owner !== null && typeof owner !== "undefined") {
            return getComponentNameFromFiber(owner);
          }
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }
          return getStackByFiberInDevAndProd(current);
        }
      }
      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          isRendering = false;
        }
      }
      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
          current = fiber;
          isRendering = false;
        }
      }
      function getCurrentFiber() {
        {
          return current;
        }
      }
      function setIsRendering(rendering) {
        {
          isRendering = rendering;
        }
      }
      function toString(value) {
        return "" + value;
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            {
              checkFormFieldValueStringCoercion(value);
            }
            return value;
          default:
            return "";
        }
      }
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
      }
      function getTracker(node) {
        return node._valueTracker;
      }
      function detachTracker(node) {
        node._valueTracker = null;
      }
      function getValueFromNode(node) {
        var value = "";
        if (!node) {
          return value;
        }
        if (isCheckable(node)) {
          value = node.checked ? "true" : "false";
        } else {
          value = node.value;
        }
        return value;
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value";
        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        {
          checkFormFieldValueStringCoercion(node[valueField]);
        }
        var currentValue = "" + node[valueField];
        if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
          return;
        }
        var get2 = descriptor.get, set2 = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
            set2.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        var tracker = {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
          },
          stopTracking: function() {
            detachTracker(node);
            delete node[valueField];
          }
        };
        return tracker;
      }
      function track(node) {
        if (getTracker(node)) {
          return;
        }
        node._valueTracker = trackValueOnNode(node);
      }
      function updateValueIfChanged(node) {
        if (!node) {
          return false;
        }
        var tracker = getTracker(node);
        if (!tracker) {
          return true;
        }
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node);
        if (nextValue !== lastValue) {
          tracker.setValue(nextValue);
          return true;
        }
        return false;
      }
      function getActiveElement(doc) {
        doc = doc || (typeof document !== "undefined" ? document : void 0);
        if (typeof doc === "undefined") {
          return null;
        }
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var didWarnValueDefaultValue = false;
      var didWarnCheckedDefaultChecked = false;
      var didWarnControlledToUncontrolled = false;
      var didWarnUncontrolledToControlled = false;
      function isControlled(props) {
        var usesChecked = props.type === "checkbox" || props.type === "radio";
        return usesChecked ? props.checked != null : props.value != null;
      }
      function getHostProps(element, props) {
        var node = element;
        var checked = props.checked;
        var hostProps = assign({}, props, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: checked != null ? checked : node._wrapperState.initialChecked
        });
        return hostProps;
      }
      function initWrapperState(element, props) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnValueDefaultValue = true;
          }
        }
        var node = element;
        var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
        node._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
          controlled: isControlled(props)
        };
      }
      function updateChecked(element, props) {
        var node = element;
        var checked = props.checked;
        if (checked != null) {
          setValueForProperty(node, "checked", checked, false);
        }
      }
      function updateWrapper(element, props) {
        var node = element;
        {
          var controlled = isControlled(props);
          if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
          }
          if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
          }
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value);
        var type = props.type;
        if (value != null) {
          if (type === "number") {
            if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
            // eslint-disable-next-line
            node.value != value) {
              node.value = toString(value);
            }
          } else if (node.value !== toString(value)) {
            node.value = toString(value);
          }
        } else if (type === "submit" || type === "reset") {
          node.removeAttribute("value");
          return;
        }
        {
          if (props.hasOwnProperty("value")) {
            setDefaultValue(node, props.type, value);
          } else if (props.hasOwnProperty("defaultValue")) {
            setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
          }
        }
        {
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      }
      function postMountWrapper(element, props, isHydrating2) {
        var node = element;
        if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
          var type = props.type;
          var isButton = type === "submit" || type === "reset";
          if (isButton && (props.value === void 0 || props.value === null)) {
            return;
          }
          var initialValue = toString(node._wrapperState.initialValue);
          if (!isHydrating2) {
            {
              if (initialValue !== node.value) {
                node.value = initialValue;
              }
            }
          }
          {
            node.defaultValue = initialValue;
          }
        }
        var name = node.name;
        if (name !== "") {
          node.name = "";
        }
        {
          node.defaultChecked = !node.defaultChecked;
          node.defaultChecked = !!node._wrapperState.initialChecked;
        }
        if (name !== "") {
          node.name = name;
        }
      }
      function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props);
        updateNamedCousins(node, props);
      }
      function updateNamedCousins(rootNode, props) {
        var name = props.name;
        if (props.type === "radio" && name != null) {
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          {
            checkAttributeStringCoercion(name, "name");
          }
          var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
          for (var i2 = 0; i2 < group.length; i2++) {
            var otherNode = group[i2];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherProps = getFiberCurrentPropsFromNode(otherNode);
            if (!otherProps) {
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            }
            updateValueIfChanged(otherNode);
            updateWrapper(otherNode, otherProps);
          }
        }
      }
      function setDefaultValue(node, type, value) {
        if (
          // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
          type !== "number" || getActiveElement(node.ownerDocument) !== node
        ) {
          if (value == null) {
            node.defaultValue = toString(node._wrapperState.initialValue);
          } else if (node.defaultValue !== toString(value)) {
            node.defaultValue = toString(value);
          }
        }
      }
      var didWarnSelectedSetOnOption = false;
      var didWarnInvalidChild = false;
      var didWarnInvalidInnerHTML = false;
      function validateProps(element, props) {
        {
          if (props.value == null) {
            if (typeof props.children === "object" && props.children !== null) {
              React.Children.forEach(props.children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === "string" || typeof child === "number") {
                  return;
                }
                if (!didWarnInvalidChild) {
                  didWarnInvalidChild = true;
                  error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              });
            } else if (props.dangerouslySetInnerHTML != null) {
              if (!didWarnInvalidInnerHTML) {
                didWarnInvalidInnerHTML = true;
                error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
              }
            }
          }
          if (props.selected != null && !didWarnSelectedSetOnOption) {
            error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
          }
        }
      }
      function postMountWrapper$1(element, props) {
        if (props.value != null) {
          element.setAttribute("value", toString(getToStringValue(props.value)));
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var didWarnValueDefaultValue$1;
      {
        didWarnValueDefaultValue$1 = false;
      }
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) {
          return "\n\nCheck the render method of `" + ownerName + "`.";
        }
        return "";
      }
      var valuePropNames = ["value", "defaultValue"];
      function checkSelectPropTypes(props) {
        {
          checkControlledValueProps("select", props);
          for (var i2 = 0; i2 < valuePropNames.length; i2++) {
            var propName = valuePropNames[i2];
            if (props[propName] == null) {
              continue;
            }
            var propNameIsArray = isArray(props[propName]);
            if (props.multiple && !propNameIsArray) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
            } else if (!props.multiple && propNameIsArray) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
          }
        }
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options2 = node.options;
        if (multiple) {
          var selectedValues = propValue;
          var selectedValue = {};
          for (var i2 = 0; i2 < selectedValues.length; i2++) {
            selectedValue["$" + selectedValues[i2]] = true;
          }
          for (var _i = 0; _i < options2.length; _i++) {
            var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
            if (options2[_i].selected !== selected) {
              options2[_i].selected = selected;
            }
            if (selected && setDefaultSelected) {
              options2[_i].defaultSelected = true;
            }
          }
        } else {
          var _selectedValue = toString(getToStringValue(propValue));
          var defaultSelected = null;
          for (var _i2 = 0; _i2 < options2.length; _i2++) {
            if (options2[_i2].value === _selectedValue) {
              options2[_i2].selected = true;
              if (setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
              return;
            }
            if (defaultSelected === null && !options2[_i2].disabled) {
              defaultSelected = options2[_i2];
            }
          }
          if (defaultSelected !== null) {
            defaultSelected.selected = true;
          }
        }
      }
      function getHostProps$1(element, props) {
        return assign({}, props, {
          value: void 0
        });
      }
      function initWrapperState$1(element, props) {
        var node = element;
        {
          checkSelectPropTypes(props);
        }
        node._wrapperState = {
          wasMultiple: !!props.multiple
        };
        {
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
          }
        }
      }
      function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        } else if (props.defaultValue != null) {
          updateOptions(node, !!props.multiple, props.defaultValue, true);
        }
      }
      function postUpdateWrapper(element, props) {
        var node = element;
        var wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        } else if (wasMultiple !== !!props.multiple) {
          if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          } else {
            updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
          }
        }
      }
      function restoreControlledState$1(element, props) {
        var node = element;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        }
      }
      var didWarnValDefaultVal = false;
      function getHostProps$2(element, props) {
        var node = element;
        if (props.dangerouslySetInnerHTML != null) {
          throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
        }
        var hostProps = assign({}, props, {
          value: void 0,
          defaultValue: void 0,
          children: toString(node._wrapperState.initialValue)
        });
        return hostProps;
      }
      function initWrapperState$2(element, props) {
        var node = element;
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
            error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
            didWarnValDefaultVal = true;
          }
        }
        var initialValue = props.value;
        if (initialValue == null) {
          var children = props.children, defaultValue = props.defaultValue;
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            {
              if (defaultValue != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                children = children[0];
              }
              defaultValue = children;
            }
          }
          if (defaultValue == null) {
            defaultValue = "";
          }
          initialValue = defaultValue;
        }
        node._wrapperState = {
          initialValue: getToStringValue(initialValue)
        };
      }
      function updateWrapper$1(element, props) {
        var node = element;
        var value = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
          var newValue = toString(value);
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null && node.defaultValue !== newValue) {
            node.defaultValue = newValue;
          }
        }
        if (defaultValue != null) {
          node.defaultValue = toString(defaultValue);
        }
      }
      function postMountWrapper$3(element, props) {
        var node = element;
        var textContent = node.textContent;
        if (textContent === node._wrapperState.initialValue) {
          if (textContent !== "" && textContent !== null) {
            node.value = textContent;
          }
        }
      }
      function restoreControlledState$2(element, props) {
        updateWrapper$1(element, props);
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
          return getIntrinsicNamespace(type);
        }
        if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
          return HTML_NAMESPACE;
        }
        return parentNamespace;
      }
      var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
          return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
              return func(arg0, arg1, arg2, arg3);
            });
          };
        } else {
          return func;
        }
      };
      var reusableSVGContainer;
      var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === SVG_NAMESPACE) {
          if (!("innerHTML" in node)) {
            reusableSVGContainer = reusableSVGContainer || document.createElement("div");
            reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
            var svgNode = reusableSVGContainer.firstChild;
            while (node.firstChild) {
              node.removeChild(node.firstChild);
            }
            while (svgNode.firstChild) {
              node.appendChild(svgNode.firstChild);
            }
            return;
          }
        }
        node.innerHTML = html;
      });
      var ELEMENT_NODE = 1;
      var TEXT_NODE = 3;
      var COMMENT_NODE = 8;
      var DOCUMENT_NODE = 9;
      var DOCUMENT_FRAGMENT_NODE = 11;
      var setTextContent = function(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      };
      var shorthandToLonghand = {
        animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
        background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
        fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
        gap: ["columnGap", "rowGap"],
        grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      };
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name, value, isCustomProperty) {
        var isEmpty = value == null || typeof value === "boolean" || value === "";
        if (isEmpty) {
          return "";
        }
        if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
          return value + "px";
        }
        {
          checkCSSPropertyStringCoercion(value, name);
        }
        return ("" + value).trim();
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern$1 = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern$1, "ms-"))
          );
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      function createDangerousStringForStyles(styles) {
        {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var styleValue = styles[styleName];
            if (styleValue != null) {
              var isCustomProperty = styleName.indexOf("--") === 0;
              serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
      }
      function setValueForStyles(node, styles) {
        var style2 = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          {
            if (!isCustomProperty) {
              warnValidStyle$1(styleName, styles[styleName]);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
          if (styleName === "float") {
            styleName = "cssFloat";
          }
          if (isCustomProperty) {
            style2.setProperty(styleName, styleValue);
          } else {
            style2[styleName] = styleValue;
          }
        }
      }
      function isValueEmpty(value) {
        return value == null || typeof value === "boolean" || value === "";
      }
      function expandShorthandMap(styles) {
        var expanded = {};
        for (var key in styles) {
          var longhands = shorthandToLonghand[key] || [key];
          for (var i2 = 0; i2 < longhands.length; i2++) {
            expanded[longhands[i2]] = key;
          }
        }
        return expanded;
      }
      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        {
          if (!nextStyles) {
            return;
          }
          var expandedUpdates = expandShorthandMap(styleUpdates);
          var expandedStyles = expandShorthandMap(nextStyles);
          var warnedAbout = {};
          for (var key in expandedUpdates) {
            var originalKey = expandedUpdates[key];
            var correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
              var warningKey = originalKey + "," + correctOriginalKey;
              if (warnedAbout[warningKey]) {
                continue;
              }
              warnedAbout[warningKey] = true;
              error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
            }
          }
        }
      }
      var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
        // NOTE: menuitem's close tag should be omitted, but that causes problems.
      };
      var voidElementTags = assign({
        menuitem: true
      }, omittedCloseTags);
      var HTML = "__html";
      function assertValidProps(tag, props) {
        if (!props) {
          return;
        }
        if (voidElementTags[tag]) {
          if (props.children != null || props.dangerouslySetInnerHTML != null) {
            throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          }
        }
        if (props.dangerouslySetInnerHTML != null) {
          if (props.children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
        }
        {
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
        }
        if (props.style != null && typeof props.style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies2.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
      var IS_NON_DELEGATED = 1 << 1;
      var IS_CAPTURE_PHASE = 1 << 2;
      var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
      var currentReplayingEvent = null;
      function setReplayingEvent(event) {
        {
          if (currentReplayingEvent !== null) {
            error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = event;
      }
      function resetReplayingEvent() {
        {
          if (currentReplayingEvent === null) {
            error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = null;
      }
      function isReplayingEvent(event) {
        return event === currentReplayingEvent;
      }
      function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        if (target.correspondingUseElement) {
          target = target.correspondingUseElement;
        }
        return target.nodeType === TEXT_NODE ? target.parentNode : target;
      }
      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (!internalInstance) {
          return;
        }
        if (typeof restoreImpl !== "function") {
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        }
        var stateNode = internalInstance.stateNode;
        if (stateNode) {
          var _props = getFiberCurrentPropsFromNode(stateNode);
          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
      }
      function setRestoreImplementation(impl) {
        restoreImpl = impl;
      }
      function enqueueStateRestore(target) {
        if (restoreTarget) {
          if (restoreQueue) {
            restoreQueue.push(target);
          } else {
            restoreQueue = [target];
          }
        } else {
          restoreTarget = target;
        }
      }
      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }
      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }
        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);
        if (queuedTargets) {
          for (var i2 = 0; i2 < queuedTargets.length; i2++) {
            restoreStateOfTarget(queuedTargets[i2]);
          }
        }
      }
      var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
      };
      var flushSyncImpl = function() {
      };
      var isInsideEventHandler = false;
      function finishEventHandler() {
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
          flushSyncImpl();
          restoreStateIfNeeded();
        }
      }
      function batchedUpdates(fn, a, b) {
        if (isInsideEventHandler) {
          return fn(a, b);
        }
        isInsideEventHandler = true;
        try {
          return batchedUpdatesImpl(fn, a, b);
        } finally {
          isInsideEventHandler = false;
          finishEventHandler();
        }
      }
      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        flushSyncImpl = _flushSyncImpl;
      }
      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }
      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !!(props.disabled && isInteractive(type));
          default:
            return false;
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) {
          return null;
        }
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) {
          return null;
        }
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }
        if (listener && typeof listener !== "function") {
          throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        }
        return listener;
      }
      var passiveBrowserEventsSupported = false;
      if (canUseDOM) {
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      }
      function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");
          invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            if (typeof document === "undefined" || document === null) {
              throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
            }
            var evt = document.createEvent("Event");
            var didCall = false;
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            function restoreAfterDispatch() {
              fakeNode.removeEventListener(evtType, callCallback2, false);
              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }
            }
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback2() {
              didCall = true;
              restoreAfterDispatch();
              func.apply(context, funcArgs);
              didError = false;
            }
            var error2;
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event) {
              error2 = event.error;
              didSetError = true;
              if (error2 === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }
              if (event.defaultPrevented) {
                if (error2 != null && typeof error2 === "object") {
                  try {
                    error2._suppressLogging = true;
                  } catch (inner) {
                  }
                }
              }
            }
            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback2, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }
            if (didCall && didError) {
              if (!didSetError) {
                error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
              } else if (isCrossOriginError) {
                error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
              }
              this.onError(error2);
            }
            window.removeEventListener("error", handleWindowError);
            if (!didCall) {
              restoreAfterDispatch();
              return invokeGuardedCallbackProd.apply(this, arguments);
            }
          };
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function(error2) {
          hasError = true;
          caughtError = error2;
        }
      };
      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
          var error2 = clearCaughtError();
          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error2;
          }
        }
      }
      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error2 = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error2;
        }
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          hasError = false;
          caughtError = null;
          return error2;
        } else {
          throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function get(key) {
        return key._reactInternals;
      }
      function has2(key) {
        return key._reactInternals !== void 0;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var NoFlags = (
        /*                      */
        0
      );
      var PerformedWork = (
        /*                */
        1
      );
      var Placement = (
        /*                    */
        2
      );
      var Update = (
        /*                       */
        4
      );
      var ChildDeletion = (
        /*                */
        16
      );
      var ContentReset = (
        /*                 */
        32
      );
      var Callback = (
        /*                     */
        64
      );
      var DidCapture = (
        /*                   */
        128
      );
      var ForceClientRender = (
        /*            */
        256
      );
      var Ref = (
        /*                          */
        512
      );
      var Snapshot = (
        /*                     */
        1024
      );
      var Passive = (
        /*                      */
        2048
      );
      var Hydrating = (
        /*                    */
        4096
      );
      var Visibility = (
        /*                   */
        8192
      );
      var StoreConsistency = (
        /*             */
        16384
      );
      var HostEffectMask = (
        /*               */
        32767
      );
      var Incomplete = (
        /*                   */
        32768
      );
      var ShouldCapture = (
        /*                */
        65536
      );
      var ForceUpdateForLegacySuspense = (
        /* */
        131072
      );
      var Forked = (
        /*                       */
        1048576
      );
      var RefStatic = (
        /*                    */
        2097152
      );
      var LayoutStatic = (
        /*                 */
        4194304
      );
      var PassiveStatic = (
        /*                */
        8388608
      );
      var MountLayoutDev = (
        /*               */
        16777216
      );
      var MountPassiveDev = (
        /*              */
        33554432
      );
      var BeforeMutationMask = (
        // TODO: Remove Update flag from before mutation phase by re-landing Visibility
        // flag logic (see #20043)
        Update | Snapshot | 0
      );
      var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
      var LayoutMask = Update | Callback | Ref | Visibility;
      var PassiveMask = Passive | ChildDeletion;
      var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
          var nextNode = node;
          do {
            node = nextNode;
            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
              nearestMounted = node.return;
            }
            nextNode = node.return;
          } while (nextNode);
        } else {
          while (node.return) {
            node = node.return;
          }
        }
        if (node.tag === HostRoot) {
          return nearestMounted;
        }
        return null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState === null) {
            var current2 = fiber.alternate;
            if (current2 !== null) {
              suspenseState = current2.memoizedState;
            }
          }
          if (suspenseState !== null) {
            return suspenseState.dehydrated;
          }
        }
        return null;
      }
      function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            if (!instance._warnedAboutRefsInRender) {
              error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
            }
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get(component);
        if (!fiber) {
          return false;
        }
        return getNearestMountedFiber(fiber) === fiber;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) {
          throw new Error("Unable to find node on an unmounted component.");
        }
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (nearestMounted !== fiber) {
            return null;
          }
          return fiber;
        }
        var a = fiber;
        var b = alternate;
        while (true) {
          var parentA = a.return;
          if (parentA === null) {
            break;
          }
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            var child = parentA.child;
            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }
              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }
              child = child.sibling;
            }
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              _child = parentB.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
              }
            }
          }
          if (a.alternate !== b) {
            throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (a.tag !== HostRoot) {
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a.stateNode.current === a) {
          return fiber;
        }
        return alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
      }
      function findCurrentHostFiberImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          var match = findCurrentHostFiberImpl(child);
          if (match !== null) {
            return match;
          }
          child = child.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          if (child.tag !== HostPortal) {
            var match = findCurrentHostFiberWithNoPortalsImpl(child);
            if (match !== null) {
              return match;
            }
          }
          child = child.sibling;
        }
        return null;
      }
      var scheduleCallback = Scheduler.unstable_scheduleCallback;
      var cancelCallback = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now2 = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var unstable_yieldValue = Scheduler.unstable_yieldValue;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      var injectedProfilingHooks = null;
      var hasLoggedError = false;
      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) {
          return true;
        }
        if (!hook.supportsFiber) {
          {
            error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
          }
          return true;
        }
        try {
          if (enableSchedulingProfiler) {
            internals = assign({}, internals, {
              getLaneLabelMap,
              injectProfilingHooks
            });
          }
          rendererID = hook.inject(internals);
          injectedHook = hook;
        } catch (err) {
          {
            error("React instrumentation encountered an error: %s.", err);
          }
        }
        if (hook.checkDCE) {
          return true;
        } else {
          return false;
        }
      }
      function onScheduleRoot(root22, children) {
        {
          if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
            try {
              injectedHook.onScheduleFiberRoot(rendererID, root22, children);
            } catch (err) {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitRoot(root22, eventPriority) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
          try {
            var didError = (root22.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) {
              var schedulerPriority;
              switch (eventPriority) {
                case DiscreteEventPriority:
                  schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority;
                  break;
              }
              injectedHook.onCommitFiberRoot(rendererID, root22, schedulerPriority, didError);
            }
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onPostCommitRoot(root22) {
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root22);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        {
          if (typeof unstable_yieldValue === "function") {
            unstable_setDisableYieldValue(newIsStrictMode);
            setSuppressWarning(newIsStrictMode);
          }
          if (injectedHook && typeof injectedHook.setStrictMode === "function") {
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function getLaneLabelMap() {
        {
          var map = /* @__PURE__ */ new Map();
          var lane = 1;
          for (var index2 = 0; index2 < TotalLanes; index2++) {
            var label = getLabelForLane(lane);
            map.set(lane, label);
            lane *= 2;
          }
          return map;
        }
      }
      function markCommitStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
            injectedProfilingHooks.markCommitStarted(lanes);
          }
        }
      }
      function markCommitStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
            injectedProfilingHooks.markCommitStopped();
          }
        }
      }
      function markComponentRenderStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
            injectedProfilingHooks.markComponentRenderStarted(fiber);
          }
        }
      }
      function markComponentRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
            injectedProfilingHooks.markComponentRenderStopped();
          }
        }
      }
      function markComponentPassiveEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStopped();
          }
        }
      }
      function markComponentPassiveEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
          }
        }
      }
      function markComponentLayoutEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStopped();
          }
        }
      }
      function markComponentLayoutEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
          }
        }
      }
      function markComponentErrored(fiber, thrownValue, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
          }
        }
      }
      function markComponentSuspended(fiber, wakeable, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
          }
        }
      }
      function markLayoutEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
            injectedProfilingHooks.markLayoutEffectsStarted(lanes);
          }
        }
      }
      function markLayoutEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
            injectedProfilingHooks.markLayoutEffectsStopped();
          }
        }
      }
      function markPassiveEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
            injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          }
        }
      }
      function markPassiveEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
            injectedProfilingHooks.markPassiveEffectsStopped();
          }
        }
      }
      function markRenderStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
            injectedProfilingHooks.markRenderStarted(lanes);
          }
        }
      }
      function markRenderYielded() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
            injectedProfilingHooks.markRenderYielded();
          }
        }
      }
      function markRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
            injectedProfilingHooks.markRenderStopped();
          }
        }
      }
      function markRenderScheduled(lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
            injectedProfilingHooks.markRenderScheduled(lane);
          }
        }
      }
      function markForceUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
          }
        }
      }
      function markStateUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
          }
        }
      }
      var NoMode = (
        /*                         */
        0
      );
      var ConcurrentMode = (
        /*                 */
        1
      );
      var ProfileMode = (
        /*                    */
        2
      );
      var StrictLegacyMode = (
        /*               */
        8
      );
      var StrictEffectsMode = (
        /*              */
        16
      );
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      var TotalLanes = 31;
      var NoLanes = (
        /*                        */
        0
      );
      var NoLane = (
        /*                          */
        0
      );
      var SyncLane = (
        /*                        */
        1
      );
      var InputContinuousHydrationLane = (
        /*    */
        2
      );
      var InputContinuousLane = (
        /*             */
        4
      );
      var DefaultHydrationLane = (
        /*            */
        8
      );
      var DefaultLane = (
        /*                     */
        16
      );
      var TransitionHydrationLane = (
        /*                */
        32
      );
      var TransitionLanes = (
        /*                       */
        4194240
      );
      var TransitionLane1 = (
        /*                        */
        64
      );
      var TransitionLane2 = (
        /*                        */
        128
      );
      var TransitionLane3 = (
        /*                        */
        256
      );
      var TransitionLane4 = (
        /*                        */
        512
      );
      var TransitionLane5 = (
        /*                        */
        1024
      );
      var TransitionLane6 = (
        /*                        */
        2048
      );
      var TransitionLane7 = (
        /*                        */
        4096
      );
      var TransitionLane8 = (
        /*                        */
        8192
      );
      var TransitionLane9 = (
        /*                        */
        16384
      );
      var TransitionLane10 = (
        /*                       */
        32768
      );
      var TransitionLane11 = (
        /*                       */
        65536
      );
      var TransitionLane12 = (
        /*                       */
        131072
      );
      var TransitionLane13 = (
        /*                       */
        262144
      );
      var TransitionLane14 = (
        /*                       */
        524288
      );
      var TransitionLane15 = (
        /*                       */
        1048576
      );
      var TransitionLane16 = (
        /*                       */
        2097152
      );
      var RetryLanes = (
        /*                            */
        130023424
      );
      var RetryLane1 = (
        /*                             */
        4194304
      );
      var RetryLane2 = (
        /*                             */
        8388608
      );
      var RetryLane3 = (
        /*                             */
        16777216
      );
      var RetryLane4 = (
        /*                             */
        33554432
      );
      var RetryLane5 = (
        /*                             */
        67108864
      );
      var SomeRetryLane = RetryLane1;
      var SelectiveHydrationLane = (
        /*          */
        134217728
      );
      var NonIdleLanes = (
        /*                          */
        268435455
      );
      var IdleHydrationLane = (
        /*               */
        268435456
      );
      var IdleLane = (
        /*                        */
        536870912
      );
      var OffscreenLane = (
        /*                   */
        1073741824
      );
      function getLabelForLane(lane) {
        {
          if (lane & SyncLane) {
            return "Sync";
          }
          if (lane & InputContinuousHydrationLane) {
            return "InputContinuousHydration";
          }
          if (lane & InputContinuousLane) {
            return "InputContinuous";
          }
          if (lane & DefaultHydrationLane) {
            return "DefaultHydration";
          }
          if (lane & DefaultLane) {
            return "Default";
          }
          if (lane & TransitionHydrationLane) {
            return "TransitionHydration";
          }
          if (lane & TransitionLanes) {
            return "Transition";
          }
          if (lane & RetryLanes) {
            return "Retry";
          }
          if (lane & SelectiveHydrationLane) {
            return "SelectiveHydration";
          }
          if (lane & IdleHydrationLane) {
            return "IdleHydration";
          }
          if (lane & IdleLane) {
            return "Idle";
          }
          if (lane & OffscreenLane) {
            return "Offscreen";
          }
        }
      }
      var NoTimestamp = -1;
      var nextTransitionLane = TransitionLane1;
      var nextRetryLane = RetryLane1;
      function getHighestPriorityLanes(lanes) {
        switch (getHighestPriorityLane(lanes)) {
          case SyncLane:
            return SyncLane;
          case InputContinuousHydrationLane:
            return InputContinuousHydrationLane;
          case InputContinuousLane:
            return InputContinuousLane;
          case DefaultHydrationLane:
            return DefaultHydrationLane;
          case DefaultLane:
            return DefaultLane;
          case TransitionHydrationLane:
            return TransitionHydrationLane;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return lanes & TransitionLanes;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return lanes & RetryLanes;
          case SelectiveHydrationLane:
            return SelectiveHydrationLane;
          case IdleHydrationLane:
            return IdleHydrationLane;
          case IdleLane:
            return IdleLane;
          case OffscreenLane:
            return OffscreenLane;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return lanes;
        }
      }
      function getNextLanes(root22, wipLanes) {
        var pendingLanes = root22.pendingLanes;
        if (pendingLanes === NoLanes) {
          return NoLanes;
        }
        var nextLanes = NoLanes;
        var suspendedLanes = root22.suspendedLanes;
        var pingedLanes = root22.pingedLanes;
        var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
        if (nonIdlePendingLanes !== NoLanes) {
          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
          if (nonIdleUnblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
          } else {
            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
            if (nonIdlePingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
            }
          }
        } else {
          var unblockedLanes = pendingLanes & ~suspendedLanes;
          if (unblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(unblockedLanes);
          } else {
            if (pingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(pingedLanes);
            }
          }
        }
        if (nextLanes === NoLanes) {
          return NoLanes;
        }
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
        // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
          var nextLane = getHighestPriorityLane(nextLanes);
          var wipLane = getHighestPriorityLane(wipLanes);
          if (
            // Tests whether the next lane is equal or lower priority than the wip
            // one. This works because the bits decrease in priority as you go left.
            nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
            // only difference between default updates and transition updates is that
            // default updates do not support refresh transitions.
            nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
          ) {
            return wipLanes;
          }
        }
        if ((nextLanes & InputContinuousLane) !== NoLanes) {
          nextLanes |= pendingLanes & DefaultLane;
        }
        var entangledLanes = root22.entangledLanes;
        if (entangledLanes !== NoLanes) {
          var entanglements = root22.entanglements;
          var lanes = nextLanes & entangledLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            nextLanes |= entanglements[index2];
            lanes &= ~lane;
          }
        }
        return nextLanes;
      }
      function getMostRecentEventTime(root22, lanes) {
        var eventTimes = root22.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var eventTime = eventTimes[index2];
          if (eventTime > mostRecentEventTime) {
            mostRecentEventTime = eventTime;
          }
          lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case SyncLane:
          case InputContinuousHydrationLane:
          case InputContinuousLane:
            return currentTime + 250;
          case DefaultHydrationLane:
          case DefaultLane:
          case TransitionHydrationLane:
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return currentTime + 5e3;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return NoTimestamp;
          case SelectiveHydrationLane:
          case IdleHydrationLane:
          case IdleLane:
          case OffscreenLane:
            return NoTimestamp;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return NoTimestamp;
        }
      }
      function markStarvedLanesAsExpired(root22, currentTime) {
        var pendingLanes = root22.pendingLanes;
        var suspendedLanes = root22.suspendedLanes;
        var pingedLanes = root22.pingedLanes;
        var expirationTimes = root22.expirationTimes;
        var lanes = pendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var expirationTime = expirationTimes[index2];
          if (expirationTime === NoTimestamp) {
            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
              expirationTimes[index2] = computeExpirationTime(lane, currentTime);
            }
          } else if (expirationTime <= currentTime) {
            root22.expiredLanes |= lane;
          }
          lanes &= ~lane;
        }
      }
      function getHighestPriorityPendingLanes(root22) {
        return getHighestPriorityLanes(root22.pendingLanes);
      }
      function getLanesToRetrySynchronouslyOnError(root22) {
        var everythingButOffscreen = root22.pendingLanes & ~OffscreenLane;
        if (everythingButOffscreen !== NoLanes) {
          return everythingButOffscreen;
        }
        if (everythingButOffscreen & OffscreenLane) {
          return OffscreenLane;
        }
        return NoLanes;
      }
      function includesSyncLane(lanes) {
        return (lanes & SyncLane) !== NoLanes;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyNonUrgentLanes(lanes) {
        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
        return (lanes & UrgentLanes) === NoLanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function includesBlockingLane(root22, lanes) {
        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
        return (lanes & SyncDefaultLanes) !== NoLanes;
      }
      function includesExpiredLane(root22, lanes) {
        return (lanes & root22.expiredLanes) !== NoLanes;
      }
      function isTransitionLane(lane) {
        return (lane & TransitionLanes) !== NoLanes;
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        if ((nextTransitionLane & TransitionLanes) === NoLanes) {
          nextTransitionLane = TransitionLane1;
        }
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        if ((nextRetryLane & RetryLanes) === NoLanes) {
          nextRetryLane = RetryLane1;
        }
        return lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
      }
      function isSubsetOfLanes(set2, subset) {
        return (set2 & subset) === subset;
      }
      function mergeLanes(a, b) {
        return a | b;
      }
      function removeLanes(set2, subset) {
        return set2 & ~subset;
      }
      function intersectLanes(a, b) {
        return a & b;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a, b) {
        return a !== NoLane && a < b ? a : b;
      }
      function createLaneMap(initial) {
        var laneMap = [];
        for (var i2 = 0; i2 < TotalLanes; i2++) {
          laneMap.push(initial);
        }
        return laneMap;
      }
      function markRootUpdated(root22, updateLane, eventTime) {
        root22.pendingLanes |= updateLane;
        if (updateLane !== IdleLane) {
          root22.suspendedLanes = NoLanes;
          root22.pingedLanes = NoLanes;
        }
        var eventTimes = root22.eventTimes;
        var index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root22, suspendedLanes) {
        root22.suspendedLanes |= suspendedLanes;
        root22.pingedLanes &= ~suspendedLanes;
        var expirationTimes = root22.expirationTimes;
        var lanes = suspendedLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootPinged(root22, pingedLanes, eventTime) {
        root22.pingedLanes |= root22.suspendedLanes & pingedLanes;
      }
      function markRootFinished(root22, remainingLanes) {
        var noLongerPendingLanes = root22.pendingLanes & ~remainingLanes;
        root22.pendingLanes = remainingLanes;
        root22.suspendedLanes = NoLanes;
        root22.pingedLanes = NoLanes;
        root22.expiredLanes &= remainingLanes;
        root22.mutableReadLanes &= remainingLanes;
        root22.entangledLanes &= remainingLanes;
        var entanglements = root22.entanglements;
        var eventTimes = root22.eventTimes;
        var expirationTimes = root22.expirationTimes;
        var lanes = noLongerPendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          entanglements[index2] = NoLanes;
          eventTimes[index2] = NoTimestamp;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootEntangled(root22, entangledLanes) {
        var rootEntangledLanes = root22.entangledLanes |= entangledLanes;
        var entanglements = root22.entanglements;
        var lanes = rootEntangledLanes;
        while (lanes) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          if (
            // Is this one of the newly entangled lanes?
            lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
            entanglements[index2] & entangledLanes
          ) {
            entanglements[index2] |= entangledLanes;
          }
          lanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root22, renderLanes2) {
        var renderLane = getHighestPriorityLane(renderLanes2);
        var lane;
        switch (renderLane) {
          case InputContinuousLane:
            lane = InputContinuousHydrationLane;
            break;
          case DefaultLane:
            lane = DefaultHydrationLane;
            break;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            lane = TransitionHydrationLane;
            break;
          case IdleLane:
            lane = IdleHydrationLane;
            break;
          default:
            lane = NoLane;
            break;
        }
        if ((lane & (root22.suspendedLanes | renderLanes2)) !== NoLane) {
          return NoLane;
        }
        return lane;
      }
      function addFiberToLanesMap(root22, fiber, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root22.pendingUpdatersLaneMap;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          updaters.add(fiber);
          lanes &= ~lane;
        }
      }
      function movePendingFibersToMemoized(root22, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root22.pendingUpdatersLaneMap;
        var memoizedUpdaters = root22.memoizedUpdaters;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          if (updaters.size > 0) {
            updaters.forEach(function(fiber) {
              var alternate = fiber.alternate;
              if (alternate === null || !memoizedUpdaters.has(alternate)) {
                memoizedUpdaters.add(fiber);
              }
            });
            updaters.clear();
          }
          lanes &= ~lane;
        }
      }
      function getTransitionsForLanes(root22, lanes) {
        {
          return null;
        }
      }
      var DiscreteEventPriority = SyncLane;
      var ContinuousEventPriority = InputContinuousLane;
      var DefaultEventPriority = DefaultLane;
      var IdleEventPriority = IdleLane;
      var currentUpdatePriority = NoLane;
      function getCurrentUpdatePriority() {
        return currentUpdatePriority;
      }
      function setCurrentUpdatePriority(newPriority) {
        currentUpdatePriority = newPriority;
      }
      function runWithPriority(priority, fn) {
        var previousPriority = currentUpdatePriority;
        try {
          currentUpdatePriority = priority;
          return fn();
        } finally {
          currentUpdatePriority = previousPriority;
        }
      }
      function higherEventPriority(a, b) {
        return a !== 0 && a < b ? a : b;
      }
      function lowerEventPriority(a, b) {
        return a > b ? a : b;
      }
      function isHigherEventPriority(a, b) {
        return a !== 0 && a < b;
      }
      function lanesToEventPriority(lanes) {
        var lane = getHighestPriorityLane(lanes);
        if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
          return DiscreteEventPriority;
        }
        if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
          return ContinuousEventPriority;
        }
        if (includesNonIdleWork(lane)) {
          return DefaultEventPriority;
        }
        return IdleEventPriority;
      }
      function isRootDehydrated(root22) {
        var currentState = root22.current.memoizedState;
        return currentState.isDehydrated;
      }
      var _attemptSynchronousHydration;
      function setAttemptSynchronousHydration(fn) {
        _attemptSynchronousHydration = fn;
      }
      function attemptSynchronousHydration(fiber) {
        _attemptSynchronousHydration(fiber);
      }
      var attemptContinuousHydration;
      function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
      }
      var attemptHydrationAtCurrentPriority;
      function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
      }
      var getCurrentUpdatePriority$1;
      function setGetCurrentUpdatePriority(fn) {
        getCurrentUpdatePriority$1 = fn;
      }
      var attemptHydrationAtPriority;
      function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
      }
      var hasScheduledReplayAttempt = false;
      var queuedDiscreteEvents = [];
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = [
        "mousedown",
        "mouseup",
        "touchcancel",
        "touchend",
        "touchstart",
        "auxclick",
        "dblclick",
        "pointercancel",
        "pointerdown",
        "pointerup",
        "dragend",
        "dragstart",
        "drop",
        "compositionend",
        "compositionstart",
        "keydown",
        "keypress",
        "keyup",
        "input",
        "textInput",
        // Intentionally camelCase
        "copy",
        "cut",
        "paste",
        "click",
        "change",
        "contextmenu",
        "reset",
        "submit"
      ];
      function isDiscreteEventThatRequiresHydration(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
      }
      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        };
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout": {
            var pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            break;
          }
          case "gotpointercapture":
          case "lostpointercapture": {
            var _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            break;
          }
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn !== null) {
            var _fiber2 = getInstanceFromNode(blockedOn);
            if (_fiber2 !== null) {
              attemptContinuousHydration(_fiber2);
            }
          }
          return queuedEvent;
        }
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
          targetContainers.push(targetContainer);
        }
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin": {
            var focusEvent = nativeEvent;
            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
            return true;
          }
          case "dragenter": {
            var dragEvent = nativeEvent;
            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
            return true;
          }
          case "mouseover": {
            var mouseEvent = nativeEvent;
            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
            return true;
          }
          case "pointerover": {
            var pointerEvent = nativeEvent;
            var pointerId = pointerEvent.pointerId;
            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
            return true;
          }
          case "gotpointercapture": {
            var _pointerEvent = nativeEvent;
            var _pointerId2 = _pointerEvent.pointerId;
            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
            return true;
          }
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted !== null) {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                queuedTarget.blockedOn = instance;
                attemptHydrationAtPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (tag === HostRoot) {
              var root22 = nearestMounted.stateNode;
              if (isRootDehydrated(root22)) {
                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                return;
              }
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function queueExplicitHydrationTarget(target) {
        var updatePriority = getCurrentUpdatePriority$1();
        var queuedTarget = {
          blockedOn: null,
          target,
          priority: updatePriority
        };
        var i2 = 0;
        for (; i2 < queuedExplicitHydrationTargets.length; i2++) {
          if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {
            break;
          }
        }
        queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);
        if (i2 === 0) {
          attemptExplicitHydrationTarget(queuedTarget);
        }
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) {
          return false;
        }
        var targetContainers = queuedEvent.targetContainers;
        while (targetContainers.length > 0) {
          var targetContainer = targetContainers[0];
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
          if (nextBlockedOn === null) {
            {
              var nativeEvent = queuedEvent.nativeEvent;
              var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
              setReplayingEvent(nativeEventClone);
              nativeEvent.target.dispatchEvent(nativeEventClone);
              resetReplayingEvent();
            }
          } else {
            var _fiber3 = getInstanceFromNode(nextBlockedOn);
            if (_fiber3 !== null) {
              attemptContinuousHydration(_fiber3);
            }
            queuedEvent.blockedOn = nextBlockedOn;
            return false;
          }
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
          map.delete(key);
        }
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
          queuedFocus = null;
        }
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
          queuedDrag = null;
        }
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
          queuedMouse = null;
        }
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
          queuedEvent.blockedOn = null;
          if (!hasScheduledReplayAttempt) {
            hasScheduledReplayAttempt = true;
            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
          }
        }
      }
      function retryIfBlockedOn(unblocked) {
        if (queuedDiscreteEvents.length > 0) {
          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
          for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {
            var queuedEvent = queuedDiscreteEvents[i2];
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
            }
          }
        }
        if (queuedFocus !== null) {
          scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        }
        if (queuedDrag !== null) {
          scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        }
        if (queuedMouse !== null) {
          scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        }
        var unblock = function(queuedEvent2) {
          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
          var queuedTarget = queuedExplicitHydrationTargets[_i];
          if (queuedTarget.blockedOn === unblocked) {
            queuedTarget.blockedOn = null;
          }
        }
        while (queuedExplicitHydrationTargets.length > 0) {
          var nextExplicitTarget = queuedExplicitHydrationTargets[0];
          if (nextExplicitTarget.blockedOn !== null) {
            break;
          } else {
            attemptExplicitHydrationTarget(nextExplicitTarget);
            if (nextExplicitTarget.blockedOn === null) {
              queuedExplicitHydrationTargets.shift();
            }
          }
        }
      }
      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
      var _enabled = true;
      function setEnabled(enabled) {
        _enabled = !!enabled;
      }
      function isEnabled() {
        return _enabled;
      }
      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriority(domEventName);
        var listenerWrapper;
        switch (eventPriority) {
          case DiscreteEventPriority:
            listenerWrapper = dispatchDiscreteEvent;
            break;
          case ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent;
            break;
          case DefaultEventPriority:
          default:
            listenerWrapper = dispatchEvent;
            break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(DiscreteEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(ContinuousEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) {
          return;
        }
        {
          dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        }
      }
      function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          clearIfContinuousEvent(domEventName, nativeEvent);
          return;
        }
        if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
          nativeEvent.stopPropagation();
          return;
        }
        clearIfContinuousEvent(domEventName, nativeEvent);
        if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
          while (blockedOn !== null) {
            var fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null) {
              attemptSynchronousHydration(fiber);
            }
            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (nextBlockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            }
            if (nextBlockedOn === blockedOn) {
              break;
            }
            blockedOn = nextBlockedOn;
          }
          if (blockedOn !== null) {
            nativeEvent.stopPropagation();
          }
          return;
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
      var return_targetInst = null;
      function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return_targetInst = null;
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted === null) {
            targetInst = null;
          } else {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                return instance;
              }
              targetInst = null;
            } else if (tag === HostRoot) {
              var root22 = nearestMounted.stateNode;
              if (isRootDehydrated(root22)) {
                return getContainerFromFiber(nearestMounted);
              }
              targetInst = null;
            } else if (nearestMounted !== targetInst) {
              targetInst = null;
            }
          }
        }
        return_targetInst = targetInst;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return DiscreteEventPriority;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return ContinuousEventPriority;
          case "message": {
            var schedulerPriority = getCurrentPriorityLevel();
            switch (schedulerPriority) {
              case ImmediatePriority:
                return DiscreteEventPriority;
              case UserBlockingPriority:
                return ContinuousEventPriority;
              case NormalPriority:
              case LowPriority:
                return DefaultEventPriority;
              case IdlePriority:
                return IdleEventPriority;
              default:
                return DefaultEventPriority;
            }
          }
          default:
            return DefaultEventPriority;
        }
      }
      function addEventBubbleListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, false);
        return listener;
      }
      function addEventCaptureListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, true);
        return listener;
      }
      function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          capture: true,
          passive
        });
        return listener;
      }
      function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          passive
        });
        return listener;
      }
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function initialize(nativeEventTarget) {
        root2 = nativeEventTarget;
        startText = getText();
        return true;
      }
      function reset() {
        root2 = null;
        startText = null;
        fallbackText = null;
      }
      function getData() {
        if (fallbackText) {
          return fallbackText;
        }
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText();
        var endLength = endValue.length;
        for (start = 0; start < startLength; start++) {
          if (startValue[start] !== endValue[start]) {
            break;
          }
        }
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd; end++) {
          if (startValue[startLength - end] !== endValue[endLength - end]) {
            break;
          }
        }
        var sliceTail = end > 1 ? 1 - end : void 0;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
      }
      function getText() {
        if ("value" in root2) {
          return root2.value;
        }
        return root2.textContent;
      }
      function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ("charCode" in nativeEvent) {
          charCode = nativeEvent.charCode;
          if (charCode === 0 && keyCode === 13) {
            charCode = 13;
          }
        } else {
          charCode = keyCode;
        }
        if (charCode === 10) {
          charCode = 13;
        }
        if (charCode >= 32 || charCode === 13) {
          return charCode;
        }
        return 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var _propName in Interface) {
            if (!Interface.hasOwnProperty(_propName)) {
              continue;
            }
            var normalize = Interface[_propName];
            if (normalize) {
              this[_propName] = normalize(nativeEvent);
            } else {
              this[_propName] = nativeEvent[_propName];
            }
          }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
          if (defaultPrevented) {
            this.isDefaultPrevented = functionThatReturnsTrue;
          } else {
            this.isDefaultPrevented = functionThatReturnsFalse;
          }
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.preventDefault) {
              event.preventDefault();
            } else if (typeof event.returnValue !== "unknown") {
              event.returnValue = false;
            }
            this.isDefaultPrevented = functionThatReturnsTrue;
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.stopPropagation) {
              event.stopPropagation();
            } else if (typeof event.cancelBubble !== "unknown") {
              event.cancelBubble = true;
            }
            this.isPropagationStopped = functionThatReturnsTrue;
          },
          /**
           * We release all dispatched `SyntheticEvent`s after each event loop, adding
           * them back into the pool. This allows a way to hold onto a reference that
           * won't be added back into the pool.
           */
          persist: function() {
          },
          /**
           * Checks if this event should be released back into the pool.
           *
           * @return {boolean} True if this should not be released, false otherwise.
           */
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
      });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      function updateMouseMovementPolyfillState(event) {
        if (event !== lastMouseEvent) {
          if (lastMouseEvent && event.type === "mousemove") {
            lastMovementX = event.screenX - lastMouseEvent.screenX;
            lastMovementY = event.screenY - lastMouseEvent.screenY;
          } else {
            lastMovementX = 0;
            lastMovementY = 0;
          }
          lastMouseEvent = event;
        }
      }
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
          return event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) {
            return event.movementX;
          }
          updateMouseMovementPolyfillState(event);
          return lastMovementX;
        },
        movementY: function(event) {
          if ("movementY" in event) {
            return event.movementY;
          }
          return lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
      });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
      });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, {
        data: 0
      });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var SyntheticInputEvent = SyntheticCompositionEvent;
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        "8": "Backspace",
        "9": "Tab",
        "12": "Clear",
        "13": "Enter",
        "16": "Shift",
        "17": "Control",
        "18": "Alt",
        "19": "Pause",
        "20": "CapsLock",
        "27": "Escape",
        "32": " ",
        "33": "PageUp",
        "34": "PageDown",
        "35": "End",
        "36": "Home",
        "37": "ArrowLeft",
        "38": "ArrowUp",
        "39": "ArrowRight",
        "40": "ArrowDown",
        "45": "Insert",
        "46": "Delete",
        "112": "F1",
        "113": "F2",
        "114": "F3",
        "115": "F4",
        "116": "F5",
        "117": "F6",
        "118": "F7",
        "119": "F8",
        "120": "F9",
        "121": "F10",
        "122": "F11",
        "123": "F12",
        "144": "NumLock",
        "145": "ScrollLock",
        "224": "Meta"
      };
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified") {
            return key;
          }
        }
        if (nativeEvent.type === "keypress") {
          var charCode = getEventCharCode(nativeEvent);
          return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
          return translateToKey[nativeEvent.keyCode] || "Unidentified";
        }
        return "";
      }
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
          return nativeEvent.getModifierState(keyArg);
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
      }
      function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        // Legacy Interface
        charCode: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          return 0;
        },
        keyCode: function(event) {
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        },
        which: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : (
            // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
            "wheelDeltaX" in event ? -event.wheelDeltaX : 0
          );
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : (
            // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
            "wheelDeltaY" in event ? -event.wheelDeltaY : (
              // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
              "wheelDelta" in event ? -event.wheelDelta : 0
            )
          );
        },
        deltaZ: 0,
        // Browsers without "deltaMode" is reporting in raw wheel delta where one
        // notch on the scroll is always +/- 120, roughly equivalent to pixels.
        // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
        // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var START_KEYCODE = 229;
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      if (canUseDOM && "documentMode" in document) {
        documentMode = document.documentMode;
      }
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
      var SPACEBAR_CODE = 32;
      var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
      function registerEvents() {
        registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
      }
      var hasSpaceKeypress = false;
      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
        !(nativeEvent.ctrlKey && nativeEvent.altKey);
      }
      function getCompositionEventType(domEventName) {
        switch (domEventName) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }
      function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === "object" && "data" in detail) {
          return detail.data;
        }
        return null;
      }
      function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === "ko";
      }
      var isComposing = false;
      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) {
          eventType = getCompositionEventType(domEventName);
        } else if (!isComposing) {
          if (isFallbackCompositionStart(domEventName, nativeEvent)) {
            eventType = "onCompositionStart";
          }
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
          eventType = "onCompositionEnd";
        }
        if (!eventType) {
          return null;
        }
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
          if (!isComposing && eventType === "onCompositionStart") {
            isComposing = initialize(nativeEventTarget);
          } else if (eventType === "onCompositionEnd") {
            if (isComposing) {
              fallbackData = getData();
            }
          }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
          var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          if (fallbackData) {
            event.data = fallbackData;
          } else {
            var customData = getDataFromCustomEvent(nativeEvent);
            if (customData !== null) {
              event.data = customData;
            }
          }
        }
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return null;
            }
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            var chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return null;
            }
            return chars;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) {
          if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
            var chars = getData();
            reset();
            isComposing = false;
            return chars;
          }
          return null;
        }
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!isKeypressCommand(nativeEvent)) {
              if (nativeEvent.char && nativeEvent.char.length > 1) {
                return nativeEvent.char;
              } else if (nativeEvent.which) {
                return String.fromCharCode(nativeEvent.which);
              }
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) {
          chars = getNativeBeforeInputChars(domEventName, nativeEvent);
        } else {
          chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
        }
        if (!chars) {
          return null;
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
        if (listeners.length > 0) {
          var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          event.data = chars;
        }
      }
      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === "input") {
          return !!supportedInputTypes[elem.type];
        }
        if (nodeName === "textarea") {
          return true;
        }
        return false;
      }
      /**
       * Checks if an event is supported in the current execution environment.
       *
       * NOTE: This will not work correctly for non-generic events such as `change`,
       * `reset`, `load`, `error`, and `select`.
       *
       * Borrows from Modernizr.
       *
       * @param {string} eventNameSuffix Event name, e.g. "click".
       * @return {boolean} True if the event is supported.
       * @internal
       * @license Modernizr 3.0.0pre (Custom Build) | MIT
       */
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM) {
          return false;
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        return isSupported;
      }
      function registerEvents$1() {
        registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        enqueueStateRestore(target);
        var listeners = accumulateTwoPhaseListeners(inst, "onChange");
        if (listeners.length > 0) {
          var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      var activeElement = null;
      var activeElementInst = null;
      function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "select" || nodeName === "input" && elem.type === "file";
      }
      function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates(runEventInBatch, dispatchQueue);
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) {
          return targetInst;
        }
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === "change") {
          return targetInst;
        }
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
      }
      function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent("onpropertychange", handlePropertyChange);
      }
      function stopWatchingForValueChange() {
        if (!activeElement) {
          return;
        }
        activeElement.detachEvent("onpropertychange", handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
      }
      function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== "value") {
          return;
        }
        if (getInstIfValueChanged(activeElementInst)) {
          manualDispatchChangeEvent(nativeEvent);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        if (domEventName === "focusin") {
          stopWatchingForValueChange();
          startWatchingForValueChange(target, targetInst);
        } else if (domEventName === "focusout") {
          stopWatchingForValueChange();
        }
      }
      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
          return getInstIfValueChanged(activeElementInst);
        }
      }
      function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === "click") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === "input" || domEventName === "change") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        if (!state || !state.controlled || node.type !== "number") {
          return;
        }
        {
          setDefaultValue(node, "number", node.value);
        }
      }
      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(domEventName, targetInst);
          if (inst) {
            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
            return;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(domEventName, targetNode, targetInst);
        }
        if (domEventName === "focusout") {
          handleControlledInputBlur(targetNode);
        }
      }
      function registerEvents$2() {
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      }
      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
        var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
        if (isOverEvent && !isReplayingEvent(nativeEvent)) {
          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
          if (related) {
            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
              return;
            }
          }
        }
        if (!isOutEvent && !isOverEvent) {
          return;
        }
        var win;
        if (nativeEventTarget.window === nativeEventTarget) {
          win = nativeEventTarget;
        } else {
          var doc = nativeEventTarget.ownerDocument;
          if (doc) {
            win = doc.defaultView || doc.parentWindow;
          } else {
            win = window;
          }
        }
        var from;
        var to;
        if (isOutEvent) {
          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
          from = targetInst;
          to = _related ? getClosestInstanceFromNode(_related) : null;
          if (to !== null) {
            var nearestMounted = getNearestMountedFiber(to);
            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
              to = null;
            }
          }
        } else {
          from = null;
          to = targetInst;
        }
        if (from === to) {
          return;
        }
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = "onMouseLeave";
        var enterEventType = "onMouseEnter";
        var eventTypePrefix = "mouse";
        if (domEventName === "pointerout" || domEventName === "pointerover") {
          SyntheticEventCtor = SyntheticPointerEvent;
          leaveEventType = "onPointerLeave";
          enterEventType = "onPointerEnter";
          eventTypePrefix = "pointer";
        }
        var fromNode = from == null ? win : getNodeFromInstance(from);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null;
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
          var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
          enterEvent.target = toNode;
          enterEvent.relatedTarget = fromNode;
          enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
      }
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) {
          return true;
        }
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
          return false;
        }
        for (var i2 = 0; i2 < keysA.length; i2++) {
          var currentKey = keysA[i2];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
            return false;
          }
        }
        return true;
      }
      function getLeafNode(node) {
        while (node && node.firstChild) {
          node = node.firstChild;
        }
        return node;
      }
      function getSiblingNode(node) {
        while (node) {
          if (node.nextSibling) {
            return node.nextSibling;
          }
          node = node.parentNode;
        }
      }
      function getNodeForCharacterOffset(root22, offset) {
        var node = getLeafNode(root22);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node) {
          if (node.nodeType === TEXT_NODE) {
            nodeEnd = nodeStart + node.textContent.length;
            if (nodeStart <= offset && nodeEnd >= offset) {
              return {
                node,
                offset: offset - nodeStart
              };
            }
            nodeStart = nodeEnd;
          }
          node = getLeafNode(getSiblingNode(node));
        }
      }
      function getOffsets(outerNode) {
        var ownerDocument = outerNode.ownerDocument;
        var win = ownerDocument && ownerDocument.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return null;
        }
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
        try {
          anchorNode.nodeType;
          focusNode.nodeType;
        } catch (e) {
          return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node = outerNode;
        var parentNode = null;
        outer: while (true) {
          var next2 = null;
          while (true) {
            if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
              start = length + anchorOffset;
            }
            if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
              end = length + focusOffset;
            }
            if (node.nodeType === TEXT_NODE) {
              length += node.nodeValue.length;
            }
            if ((next2 = node.firstChild) === null) {
              break;
            }
            parentNode = node;
            node = next2;
          }
          while (true) {
            if (node === outerNode) {
              break outer;
            }
            if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
              start = length;
            }
            if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
              end = length;
            }
            if ((next2 = node.nextSibling) !== null) {
              break;
            }
            node = parentNode;
            parentNode = node.parentNode;
          }
          node = next2;
        }
        if (start === -1 || end === -1) {
          return null;
        }
        return {
          start,
          end
        };
      }
      function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document;
        var win = doc && doc.defaultView || window;
        if (!win.getSelection) {
          return;
        }
        var selection = win.getSelection();
        var length = node.textContent.length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
        if (!selection.extend && start > end) {
          var temp = end;
          end = start;
          start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
            return;
          }
          var range = doc.createRange();
          range.setStart(startMarker.node, startMarker.offset);
          selection.removeAllRanges();
          if (start > end) {
            selection.addRange(range);
            selection.extend(endMarker.node, endMarker.offset);
          } else {
            range.setEnd(endMarker.node, endMarker.offset);
            selection.addRange(range);
          }
        }
      }
      function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
      }
      function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
          return false;
        } else if (outerNode === innerNode) {
          return true;
        } else if (isTextNode(outerNode)) {
          return false;
        } else if (isTextNode(innerNode)) {
          return containsNode(outerNode, innerNode.parentNode);
        } else if ("contains" in outerNode) {
          return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
          return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
          return false;
        }
      }
      function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
      }
      function isSameOriginFrame(iframe) {
        try {
          return typeof iframe.contentWindow.location.href === "string";
        } catch (err) {
          return false;
        }
      }
      function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while (element instanceof win.HTMLIFrameElement) {
          if (isSameOriginFrame(element)) {
            win = element.contentWindow;
          } else {
            return element;
          }
          element = getActiveElement(win.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
      }
      function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
          focusedElem,
          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
        };
      }
      function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
            setSelection(priorFocusedElem, priorSelectionRange);
          }
          var ancestors = [];
          var ancestor = priorFocusedElem;
          while (ancestor = ancestor.parentNode) {
            if (ancestor.nodeType === ELEMENT_NODE) {
              ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
              });
            }
          }
          if (typeof priorFocusedElem.focus === "function") {
            priorFocusedElem.focus();
          }
          for (var i2 = 0; i2 < ancestors.length; i2++) {
            var info = ancestors[i2];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
      }
      function getSelection(input) {
        var selection;
        if ("selectionStart" in input) {
          selection = {
            start: input.selectionStart,
            end: input.selectionEnd
          };
        } else {
          selection = getOffsets(input);
        }
        return selection || {
          start: 0,
          end: 0
        };
      }
      function setSelection(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === void 0) {
          end = start;
        }
        if ("selectionStart" in input) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        } else {
          setOffsets(input, offsets);
        }
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
      function registerEvents$3() {
        registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      var lastSelection = null;
      var mouseDown = false;
      function getSelection$1(node) {
        if ("selectionStart" in node && hasSelectionCapabilities(node)) {
          return {
            start: node.selectionStart,
            end: node.selectionEnd
          };
        } else {
          var win = node.ownerDocument && node.ownerDocument.defaultView || window;
          var selection = win.getSelection();
          return {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
          };
        }
      }
      function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
          return;
        }
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.target = activeElement$1;
          }
        }
      }
      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
              activeElement$1 = targetNode;
              activeElementInst$1 = targetInst;
              lastSelection = null;
            }
            break;
          case "focusout":
            activeElement$1 = null;
            activeElementInst$1 = null;
            lastSelection = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) {
              break;
            }
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes2 = {};
        prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes2["Webkit" + styleProp] = "webkit" + eventName;
        prefixes2["Moz" + styleProp] = "moz" + eventName;
        return prefixes2;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      if (canUseDOM) {
        style = document.createElement("div").style;
        if (!("AnimationEvent" in window)) {
          delete vendorPrefixes.animationend.animation;
          delete vendorPrefixes.animationiteration.animation;
          delete vendorPrefixes.animationstart.animation;
        }
        if (!("TransitionEvent" in window)) {
          delete vendorPrefixes.transitionend.transition;
        }
      }
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
          return prefixedEventNames[eventName];
        } else if (!vendorPrefixes[eventName]) {
          return eventName;
        }
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap) {
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
            return prefixedEventNames[eventName] = prefixMap[styleProp];
          }
        }
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      function registerSimpleEvents() {
        for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
          var eventName = simpleEventPluginEvents[i2];
          var domEventName = eventName.toLowerCase();
          var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
          registerSimpleEvent(domEventName, "on" + capitalizedEvent);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      }
      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === void 0) {
          return;
        }
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0) {
              return;
            }
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2) {
              return;
            }
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        {
          var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          domEventName === "scroll";
          var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
          if (_listeners.length > 0) {
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: _event,
              listeners: _listeners
            });
          }
        }
      }
      registerSimpleEvents();
      registerEvents$2();
      registerEvents$1();
      registerEvents$3();
      registerEvents();
      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
        if (shouldProcessPolyfillPlugins) {
          extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
      }
      var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
      function executeDispatch(event, listener, currentTarget) {
        var type = event.type || "unknown-event";
        event.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
        event.currentTarget = null;
      }
      function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) {
          for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {
            var _dispatchListeners$i = dispatchListeners[i2], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, listener, currentTarget);
            previousInstance = instance;
          }
        } else {
          for (var _i = 0; _i < dispatchListeners.length; _i++) {
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, _listener, _currentTarget);
            previousInstance = _instance;
          }
        }
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
          var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
          processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
        }
        rethrowCaughtError();
      }
      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        {
          if (!nonDelegatedEvents.has(domEventName)) {
            error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName);
        if (!listenerSet.has(listenerSetKey)) {
          addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
          listenerSet.add(listenerSetKey);
        }
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        {
          if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
            error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var eventSystemFlags = 0;
        if (isCapturePhaseListener) {
          eventSystemFlags |= IS_CAPTURE_PHASE;
        }
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            if (domEventName !== "selectionchange") {
              if (!nonDelegatedEvents.has(domEventName)) {
                listenToNativeEvent(domEventName, false, rootContainerElement);
              }
              listenToNativeEvent(domEventName, true, rootContainerElement);
            }
          });
          var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          if (ownerDocument !== null) {
            if (!ownerDocument[listeningMarker]) {
              ownerDocument[listeningMarker] = true;
              listenToNativeEvent("selectionchange", false, ownerDocument);
            }
          }
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
        var isPassiveListener = void 0;
        if (passiveBrowserEventsSupported) {
          if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
            isPassiveListener = true;
          }
        }
        targetContainer = targetContainer;
        if (isCapturePhaseListener) {
          if (isPassiveListener !== void 0) {
            addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventCaptureListener(targetContainer, domEventName, listener);
          }
        } else {
          if (isPassiveListener !== void 0) {
            addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventBubbleListener(targetContainer, domEventName, listener);
          }
        }
      }
      function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
          var targetContainerNode = targetContainer;
          if (targetInst !== null) {
            var node = targetInst;
            mainLoop: while (true) {
              if (node === null) {
                return;
              }
              var nodeTag = node.tag;
              if (nodeTag === HostRoot || nodeTag === HostPortal) {
                var container = node.stateNode.containerInfo;
                if (isMatchingRootContainer(container, targetContainerNode)) {
                  break;
                }
                if (nodeTag === HostPortal) {
                  var grandNode = node.return;
                  while (grandNode !== null) {
                    var grandTag = grandNode.tag;
                    if (grandTag === HostRoot || grandTag === HostPortal) {
                      var grandContainer = grandNode.stateNode.containerInfo;
                      if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                        return;
                      }
                    }
                    grandNode = grandNode.return;
                  }
                }
                while (container !== null) {
                  var parentNode = getClosestInstanceFromNode(container);
                  if (parentNode === null) {
                    return;
                  }
                  var parentTag = parentNode.tag;
                  if (parentTag === HostComponent || parentTag === HostText) {
                    node = ancestorInst = parentNode;
                    continue mainLoop;
                  }
                  container = container.parentNode;
                }
              }
              node = node.return;
            }
          }
        }
        batchedUpdates(function() {
          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
        var captureName = reactName !== null ? reactName + "Capture" : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance = targetFiber;
        var lastHostComponent = null;
        while (instance !== null) {
          var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
          if (tag === HostComponent && stateNode !== null) {
            lastHostComponent = stateNode;
            if (reactEventName !== null) {
              var listener = getListener(instance, reactEventName);
              if (listener != null) {
                listeners.push(createDispatchListener(instance, listener, lastHostComponent));
              }
            }
          }
          if (accumulateTargetOnly) {
            break;
          }
          instance = instance.return;
        }
        return listeners;
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + "Capture";
        var listeners = [];
        var instance = targetFiber;
        while (instance !== null) {
          var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            var captureListener = getListener(instance, captureName);
            if (captureListener != null) {
              listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
            }
            var bubbleListener = getListener(instance, reactName);
            if (bubbleListener != null) {
              listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
          }
          instance = instance.return;
        }
        return listeners;
      }
      function getParent(inst) {
        if (inst === null) {
          return null;
        }
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);
        if (inst) {
          return inst;
        }
        return null;
      }
      function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }
        var depthB = 0;
        for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }
        while (depthA - depthB > 0) {
          nodeA = getParent(nodeA);
          depthA--;
        }
        while (depthB - depthA > 0) {
          nodeB = getParent(nodeB);
          depthB--;
        }
        var depth = depthA;
        while (depth--) {
          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
            return nodeA;
          }
          nodeA = getParent(nodeA);
          nodeB = getParent(nodeB);
        }
        return null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        var registrationName = event._reactName;
        var listeners = [];
        var instance = target;
        while (instance !== null) {
          if (instance === common) {
            break;
          }
          var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
          if (alternate !== null && alternate === common) {
            break;
          }
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            if (inCapturePhase) {
              var captureListener = getListener(instance, registrationName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
            } else if (!inCapturePhase) {
              var bubbleListener = getListener(instance, registrationName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
          }
          instance = instance.return;
        }
        if (listeners.length !== 0) {
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        if (from !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
        }
        if (to !== null && enterEvent !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
        }
      }
      function getListenerSetKey(domEventName, capture) {
        return domEventName + "__bubble";
      }
      var didWarnInvalidHydration = false;
      var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
      var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
      var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
      var AUTOFOCUS = "autoFocus";
      var CHILDREN = "children";
      var STYLE = "style";
      var HTML$1 = "__html";
      var warnedUnknownTags;
      var validatePropertiesInDevelopment;
      var warnForPropDifference;
      var warnForExtraAttributes;
      var warnForInvalidEventListener;
      var canDiffStyleForHydrationWarning;
      var normalizeHTML;
      {
        warnedUnknownTags = {
          // There are working polyfills for <dialog>. Let people use it.
          dialog: true,
          // Electron ships a custom <webview> tag to display external web content in
          // an isolated frame and process.
          // This tag is not present in non Electron environments such as JSDom which
          // is often used for testing purposes.
          // @see https://electronjs.org/docs/api/webview-tag
          webview: true
        };
        validatePropertiesInDevelopment = function(type, props) {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, {
            registrationNameDependencies,
            possibleRegistrationNames
          });
        };
        canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
        warnForPropDifference = function(propName, serverValue, clientValue) {
          if (didWarnInvalidHydration) {
            return;
          }
          var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
          var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
          if (normalizedServerValue === normalizedClientValue) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
        };
        warnForExtraAttributes = function(attributeNames) {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          var names = [];
          attributeNames.forEach(function(name) {
            names.push(name);
          });
          error("Extra attributes from the server: %s", names);
        };
        warnForInvalidEventListener = function(registrationName, listener) {
          if (listener === false) {
            error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
          } else {
            error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
          }
        };
        normalizeHTML = function(parent, html) {
          var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
          testElement.innerHTML = html;
          return testElement.innerHTML;
        };
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        {
          checkHtmlStringCoercion(markup);
        }
        var markupString = typeof markup === "string" ? markup : "" + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) {
          return;
        }
        if (shouldWarnDev) {
          {
            if (!didWarnInvalidHydration) {
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            }
          }
        }
        if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
          throw new Error("Text content does not match server-rendered HTML.");
        }
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function noop() {
      }
      function trapClickOnNonInteractiveElement(node) {
        node.onclick = noop;
      }
      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for (var propKey in nextProps) {
          if (!nextProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = nextProps[propKey];
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            setValueForStyles(domElement, nextProp);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            if (nextHtml != null) {
              setInnerHTML(domElement, nextHtml);
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              var canSetTextContent = tag !== "textarea" || nextProp !== "";
              if (canSetTextContent) {
                setTextContent(domElement, nextProp);
              }
            } else if (typeof nextProp === "number") {
              setTextContent(domElement, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (nextProp != null) {
            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
          }
        }
      }
      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        for (var i2 = 0; i2 < updatePayload.length; i2 += 2) {
          var propKey = updatePayload[i2];
          var propValue = updatePayload[i2 + 1];
          if (propKey === STYLE) {
            setValueForStyles(domElement, propValue);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            setInnerHTML(domElement, propValue);
          } else if (propKey === CHILDREN) {
            setTextContent(domElement, propValue);
          } else {
            setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
          }
        }
      }
      function createElement(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag;
        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE) {
          namespaceURI = getIntrinsicNamespace(type);
        }
        if (namespaceURI === HTML_NAMESPACE) {
          {
            isCustomComponentTag = isCustomComponent(type, props);
            if (!isCustomComponentTag && type !== type.toLowerCase()) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
          if (type === "script") {
            var div = ownerDocument.createElement("div");
            div.innerHTML = "<script><\/script>";
            var firstChild = div.firstChild;
            domElement = div.removeChild(firstChild);
          } else if (typeof props.is === "string") {
            domElement = ownerDocument.createElement(type, {
              is: props.is
            });
          } else {
            domElement = ownerDocument.createElement(type);
            if (type === "select") {
              var node = domElement;
              if (props.multiple) {
                node.multiple = true;
              } else if (props.size) {
                node.size = props.size;
              }
            }
          }
        } else {
          domElement = ownerDocument.createElementNS(namespaceURI, type);
        }
        {
          if (namespaceURI === HTML_NAMESPACE) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
              warnedUnknownTags[type] = true;
              error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
            }
          }
        }
        return domElement;
      }
      function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
      }
      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        {
          validatePropertiesInDevelopment(tag, rawProps);
        }
        var props;
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            props = rawProps;
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            props = rawProps;
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            props = rawProps;
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            props = rawProps;
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            props = getHostProps(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            props = rawProps;
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            props = getHostProps$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            props = getHostProps$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          default:
            props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, false);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "option":
            postMountWrapper$1(domElement, rawProps);
            break;
          case "select":
            postMountWrapper$2(domElement, rawProps);
            break;
          default:
            if (typeof props.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
      }
      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        {
          validatePropertiesInDevelopment(tag, nextRawProps);
        }
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch (tag) {
          case "input":
            lastProps = getHostProps(domElement, lastRawProps);
            nextProps = getHostProps(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "select":
            lastProps = getHostProps$1(domElement, lastRawProps);
            nextProps = getHostProps$1(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "textarea":
            lastProps = getHostProps$2(domElement, lastRawProps);
            nextProps = getHostProps$2(domElement, nextRawProps);
            updatePayload = [];
            break;
          default:
            lastProps = lastRawProps;
            nextProps = nextRawProps;
            if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                if (!styleUpdates) {
                  styleUpdates = {};
                }
                styleUpdates[styleName] = "";
              }
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
          else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (!updatePayload) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, null);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps != null ? lastProps[propKey] : void 0;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              if (!styleUpdates) {
                if (!updatePayload) {
                  updatePayload = [];
                }
                updatePayload.push(propKey, styleUpdates);
              }
              styleUpdates = nextProp;
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
            if (nextHtml != null) {
              if (lastHtml !== nextHtml) {
                (updatePayload = updatePayload || []).push(propKey, nextHtml);
              }
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string" || typeof nextProp === "number") {
              (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
            if (!updatePayload && lastProp !== nextProp) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, nextProp);
          }
        }
        if (styleUpdates) {
          {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
          }
          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
      }
      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
          updateChecked(domElement, nextRawProps);
        }
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
        switch (tag) {
          case "input":
            updateWrapper(domElement, nextRawProps);
            break;
          case "textarea":
            updateWrapper$1(domElement, nextRawProps);
            break;
          case "select":
            postUpdateWrapper(domElement, nextRawProps);
            break;
        }
      }
      function getPossibleStandardName(propName) {
        {
          var lowerCasedName = propName.toLowerCase();
          if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            return null;
          }
          return possibleStandardNames[lowerCasedName] || null;
        }
      }
      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
        var isCustomComponentTag;
        var extraAttributeNames;
        {
          isCustomComponentTag = isCustomComponent(tag, rawProps);
          validatePropertiesInDevelopment(tag, rawProps);
        }
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
        }
        assertValidProps(tag, rawProps);
        {
          extraAttributeNames = /* @__PURE__ */ new Set();
          var attributes = domElement.attributes;
          for (var _i = 0; _i < attributes.length; _i++) {
            var name = attributes[_i].name.toLowerCase();
            switch (name) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributeNames.add(attributes[_i].name);
            }
          }
        }
        var updatePayload = null;
        for (var propKey in rawProps) {
          if (!rawProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = rawProps[propKey];
          if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              if (domElement.textContent !== nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, nextProp];
              }
            } else if (typeof nextProp === "number") {
              if (domElement.textContent !== "" + nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, "" + nextProp];
              }
            }
          } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof isCustomComponentTag === "boolean") {
            var serverValue = void 0;
            var propertyInfo = getPropertyInfo(propKey);
            if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            propKey === "value" || propKey === "checked" || propKey === "selected") ;
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var serverHTML = domElement.innerHTML;
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                var expectedHTML = normalizeHTML(domElement, nextHtml);
                if (expectedHTML !== serverHTML) {
                  warnForPropDifference(propKey, serverHTML, expectedHTML);
                }
              }
            } else if (propKey === STYLE) {
              extraAttributeNames.delete(propKey);
              if (canDiffStyleForHydrationWarning) {
                var expectedStyle = createDangerousStringForStyles(nextProp);
                serverValue = domElement.getAttribute("style");
                if (expectedStyle !== serverValue) {
                  warnForPropDifference(propKey, serverValue, expectedStyle);
                }
              }
            } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
              extraAttributeNames.delete(propKey.toLowerCase());
              serverValue = getValueForAttribute(domElement, propKey, nextProp);
              if (nextProp !== serverValue) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
              var isMismatchDueToBadCasing = false;
              if (propertyInfo !== null) {
                extraAttributeNames.delete(propertyInfo.attributeName);
                serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
              } else {
                var ownNamespace = parentNamespace;
                if (ownNamespace === HTML_NAMESPACE) {
                  ownNamespace = getIntrinsicNamespace(tag);
                }
                if (ownNamespace === HTML_NAMESPACE) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                } else {
                  var standardName = getPossibleStandardName(propKey);
                  if (standardName !== null && standardName !== propKey) {
                    isMismatchDueToBadCasing = true;
                    extraAttributeNames.delete(standardName);
                  }
                  extraAttributeNames.delete(propKey);
                }
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
              }
              var dontWarnCustomElement = enableCustomElementPropertySupport;
              if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            }
          }
        }
        {
          if (shouldWarnDev) {
            if (
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
            ) {
              warnForExtraAttributes(extraAttributeNames);
            }
          }
        }
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, true);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "select":
          case "option":
            break;
          default:
            if (typeof rawProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        return updatePayload;
      }
      function diffHydratedText(textNode, text, isConcurrentMode) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
      }
      function warnForDeletedHydratableElement(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
        }
      }
      function warnForDeletedHydratableText(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedElement(parentNode, tag, props) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedText(parentNode, text) {
        {
          if (text === "") {
            return;
          }
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
        }
      }
      function restoreControlledState$3(domElement, tag, props) {
        switch (tag) {
          case "input":
            restoreControlledState(domElement, props);
            return;
          case "textarea":
            restoreControlledState$2(domElement, props);
            return;
          case "select":
            restoreControlledState$1(domElement, props);
            return;
        }
      }
      var validateDOMNesting = function() {
      };
      var updatedAncestorInfo = function() {
      };
      {
        var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
        var inScopeTags = [
          "applet",
          "caption",
          "html",
          "table",
          "td",
          "th",
          "marquee",
          "object",
          "template",
          // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
          // TODO: Distinguish by namespace here -- for <title>, including it here
          // errs on the side of fewer warnings
          "foreignObject",
          "desc",
          "title"
        ];
        var buttonScopeTags = inScopeTags.concat(["button"]);
        var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
        var emptyAncestorInfo = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null
        };
        updatedAncestorInfo = function(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
          var info = {
            tag
          };
          if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
          }
          if (buttonScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.pTagInButtonScope = null;
          }
          if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
          }
          ancestorInfo.current = info;
          if (tag === "form") {
            ancestorInfo.formTag = info;
          }
          if (tag === "a") {
            ancestorInfo.aTagInScope = info;
          }
          if (tag === "button") {
            ancestorInfo.buttonTagInScope = info;
          }
          if (tag === "nobr") {
            ancestorInfo.nobrTagInScope = info;
          }
          if (tag === "p") {
            ancestorInfo.pTagInButtonScope = info;
          }
          if (tag === "li") {
            ancestorInfo.listItemTagAutoclosing = info;
          }
          if (tag === "dd" || tag === "dt") {
            ancestorInfo.dlItemTagAutoclosing = info;
          }
          return ancestorInfo;
        };
        var isTagValidWithParent = function(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return tag === "option" || tag === "optgroup" || tag === "#text";
            case "optgroup":
              return tag === "option" || tag === "#text";
            case "option":
              return tag === "#text";
            case "tr":
              return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
            case "tbody":
            case "thead":
            case "tfoot":
              return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
            case "colgroup":
              return tag === "col" || tag === "template";
            case "table":
              return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
            case "head":
              return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
            case "html":
              return tag === "head" || tag === "body" || tag === "frameset";
            case "frameset":
              return tag === "frame";
            case "#document":
              return tag === "html";
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
            case "rp":
            case "rt":
              return impliedEndTags.indexOf(parentTag) === -1;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return parentTag == null;
          }
          return true;
        };
        var findInvalidAncestorForTag = function(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        };
        var didWarn$1 = {};
        validateDOMNesting = function(childTag, childText, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfo;
          var parentInfo = ancestorInfo.current;
          var parentTag = parentInfo && parentInfo.tag;
          if (childText != null) {
            if (childTag != null) {
              error("validateDOMNesting: when childText is passed, childTag should be null");
            }
            childTag = "#text";
          }
          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
          var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          var invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (!invalidParentOrAncestor) {
            return;
          }
          var ancestorTag = invalidParentOrAncestor.tag;
          var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
          if (didWarn$1[warnKey]) {
            return;
          }
          didWarn$1[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = "";
          if (childTag === "#text") {
            if (/\S/.test(childText)) {
              tagDisplayName = "Text nodes";
            } else {
              tagDisplayName = "Whitespace text nodes";
              whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
            }
          } else {
            tagDisplayName = "<" + childTag + ">";
          }
          if (invalidParent) {
            var info = "";
            if (ancestorTag === "table" && childTag === "tr") {
              info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
            }
            error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
          } else {
            error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
          }
        };
      }
      var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
      var SUSPENSE_START_DATA = "$";
      var SUSPENSE_END_DATA = "/$";
      var SUSPENSE_PENDING_START_DATA = "$?";
      var SUSPENSE_FALLBACK_START_DATA = "$!";
      var STYLE$1 = "style";
      var eventsEnabled = null;
      var selectionInformation = null;
      function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch (nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
            var root22 = rootContainerInstance.documentElement;
            namespace = root22 ? root22.namespaceURI : getChildNamespace(null, "");
            break;
          }
          default: {
            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            var ownNamespace = container.namespaceURI || null;
            type = container.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            break;
          }
        }
        {
          var validatedTag = type.toLowerCase();
          var ancestorInfo = updatedAncestorInfo(null, validatedTag);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        {
          var parentHostContextDev = parentHostContext;
          var namespace = getChildNamespace(parentHostContextDev.namespace, type);
          var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getPublicInstance(instance) {
        return instance;
      }
      function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
      }
      function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
      }
      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          validateDOMNesting(type, null, hostContextDev.ancestorInfo);
          if (typeof props.children === "string" || typeof props.children === "number") {
            var string = "" + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          parentNamespace = hostContextDev.namespace;
        }
        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
      }
      function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!props.autoFocus;
          case "img":
            return true;
          default:
            return false;
        }
      }
      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        {
          var hostContextDev = hostContext;
          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
            var string = "" + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
        }
        return diffProperties(domElement, type, oldProps, newProps);
      }
      function shouldSetTextContent(type, props) {
        return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
      }
      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        {
          var hostContextDev = hostContext;
          validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        }
        var textNode = createTextNode(text, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
      }
      function getCurrentEventPriority() {
        var currentEvent = window.event;
        if (currentEvent === void 0) {
          return DefaultEventPriority;
        }
        return getEventPriority(currentEvent.type);
      }
      var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
      var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
      var noTimeout = -1;
      var localPromise = typeof Promise === "function" ? Promise : void 0;
      var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function commitMount(domElement, type, newProps, internalInstanceHandle) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            if (newProps.autoFocus) {
              domElement.focus();
            }
            return;
          case "img": {
            if (newProps.src) {
              domElement.src = newProps.src;
            }
            return;
          }
        }
      }
      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
        updateFiberProps(domElement, newProps);
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function appendChildToContainer(container, child) {
        var parentNode;
        if (container.nodeType === COMMENT_NODE) {
          parentNode = container.parentNode;
          parentNode.insertBefore(child, container);
        } else {
          parentNode = container;
          parentNode.appendChild(child);
        }
        var reactRootContainer = container._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
          trapClickOnNonInteractiveElement(parentNode);
        }
      }
      function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      }
      function insertInContainerBefore(container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.insertBefore(child, beforeChild);
        } else {
          container.insertBefore(child, beforeChild);
        }
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container, child) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.removeChild(child);
        } else {
          container.removeChild(child);
        }
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance;
        var depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && nextNode.nodeType === COMMENT_NODE) {
            var data = nextNode.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
              depth++;
            }
          }
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
        if (container.nodeType === COMMENT_NODE) {
          clearSuspenseBoundary(container.parentNode, suspenseInstance);
        } else if (container.nodeType === ELEMENT_NODE) {
          clearSuspenseBoundary(container, suspenseInstance);
        }
        retryIfBlockedOn(container);
      }
      function hideInstance(instance) {
        instance = instance;
        var style2 = instance.style;
        if (typeof style2.setProperty === "function") {
          style2.setProperty("display", "none", "important");
        } else {
          style2.display = "none";
        }
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideInstance(instance, props) {
        instance = instance;
        var styleProp = props[STYLE$1];
        var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
        instance.style.display = dangerousStyleValue("display", display);
      }
      function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
      }
      function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE) {
          container.textContent = "";
        } else if (container.nodeType === DOCUMENT_NODE) {
          if (container.documentElement) {
            container.removeChild(container.documentElement);
          }
        }
      }
      function canHydrateInstance(instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
          return null;
        }
        return instance;
      }
      function canHydrateTextInstance(instance, text) {
        if (text === "" || instance.nodeType !== TEXT_NODE) {
          return null;
        }
        return instance;
      }
      function canHydrateSuspenseInstance(instance) {
        if (instance.nodeType !== COMMENT_NODE) {
          return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
      }
      function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
      }
      function getSuspenseInstanceFallbackErrorDetails(instance) {
        var dataset = instance.nextSibling && instance.nextSibling.dataset;
        var digest, message, stack;
        if (dataset) {
          digest = dataset.dgst;
          {
            message = dataset.msg;
            stack = dataset.stck;
          }
        }
        {
          return {
            message,
            digest,
            stack
          };
        }
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        instance._reactRetry = callback;
      }
      function getNextHydratable(node) {
        for (; node != null; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
            break;
          }
          if (nodeType === COMMENT_NODE) {
            var nodeData = node.data;
            if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
              break;
            }
            if (nodeData === SUSPENSE_END_DATA) {
              return null;
            }
          }
        }
        return node;
      }
      function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
      }
      function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
      }
      function getFirstHydratableChildWithinContainer(parentContainer) {
        return getNextHydratable(parentContainer.firstChild);
      }
      function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
        return getNextHydratable(parentInstance.nextSibling);
      }
      function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, instance);
        updateFiberProps(instance, props);
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
      }
      function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedText(textInstance, text);
      }
      function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, suspenseInstance);
      }
      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node = suspenseInstance.nextSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                return getNextHydratableSibling(node);
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              depth++;
            }
          }
          node = node.nextSibling;
        }
        return null;
      }
      function getParentSuspenseInstance(targetInstance) {
        var node = targetInstance.previousSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              if (depth === 0) {
                return node;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_END_DATA) {
              depth++;
            }
          }
          node = node.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container) {
        retryIfBlockedOn(container);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function shouldDeleteUnhydratedTailInstances(parentType) {
        return parentType !== "head" && parentType !== "body";
      }
      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
        var shouldWarnDev = true;
        checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
      }
      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
      }
      function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
        {
          if (instance.nodeType === ELEMENT_NODE) {
            warnForDeletedHydratableElement(parentContainer, instance);
          } else if (instance.nodeType === COMMENT_NODE) ;
          else {
            warnForDeletedHydratableText(parentContainer, instance);
          }
        }
      }
      function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentNode, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentNode, instance);
            }
          }
        }
      }
      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentInstance, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentInstance, instance);
            }
          }
        }
      }
      function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
        {
          warnForInsertedHydratedElement(parentContainer, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
        {
          warnForInsertedHydratedText(parentContainer, text);
        }
      }
      function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);
        }
      }
      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedElement(parentInstance, type);
          }
        }
      }
      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedText(parentInstance, text);
          }
        }
      }
      function errorHydratingContainer(parentContainer) {
        {
          error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
        }
      }
      function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
      }
      function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
      }
      function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
      }
      function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) {
          return targetInst;
        }
        var parentNode = targetNode.parentNode;
        while (parentNode) {
          targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
          if (targetInst) {
            var alternate = targetInst.alternate;
            if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
              var suspenseInstance = getParentSuspenseInstance(targetNode);
              while (suspenseInstance !== null) {
                var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                if (targetSuspenseInst) {
                  return targetSuspenseInst;
                }
                suspenseInstance = getParentSuspenseInstance(suspenseInstance);
              }
            }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        if (inst) {
          if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
            return inst;
          } else {
            return null;
          }
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) {
          return inst.stateNode;
        }
        throw new Error("getNodeFromInstance: Invalid argument.");
      }
      function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
      }
      function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
      }
      function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        if (elementListenerSet === void 0) {
          elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
        }
        return elementListenerSet;
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has22 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has22(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var valueStack = [];
      var fiberStack;
      {
        fiberStack = [];
      }
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          {
            error("Unexpected pop.");
          }
          return;
        }
        {
          if (fiber !== fiberStack[index]) {
            error("Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }
      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        {
          if (didPushOwnContextIfProvider && isContextProvider(Component)) {
            return previousContext;
          }
          return contextStackCursor.current;
        }
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance = workInProgress2.stateNode;
          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
          instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type;
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var instance = workInProgress2.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
            return instance.__reactInternalMemoizedMaskedChildContext;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          if (instance) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return context;
        }
      }
      function hasContextChanged() {
        {
          return didPerformWorkStackCursor.current;
        }
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes !== null && childContextTypes !== void 0;
        }
      }
      function popContext(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function popTopLevelContextObject(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject) {
            throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
          }
          push(contextStackCursor, context, fiber);
          push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance = fiber.stateNode;
          var childContextTypes = type.childContextTypes;
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromFiber(fiber) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name = getComponentNameFromFiber(fiber) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance = workInProgress2.stateNode;
          var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          previousContext = contextStackCursor.current;
          push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
          push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
          return true;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance = workInProgress2.stateNode;
          if (!instance) {
            throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
          }
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext;
            pop(didPerformWorkStackCursor, workInProgress2);
            pop(contextStackCursor, workInProgress2);
            push(contextStackCursor, mergedContext, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else {
            pop(didPerformWorkStackCursor, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          }
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
            throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
          }
          var node = fiber;
          do {
            switch (node.tag) {
              case HostRoot:
                return node.stateNode.context;
              case ClassComponent: {
                var Component = node.type;
                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }
                break;
              }
            }
            node = node.return;
          } while (node !== null);
          throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0;
      var ConcurrentRoot = 1;
      var syncQueue = null;
      var includesLegacySyncCallbacks = false;
      var isFlushingSyncQueue = false;
      function scheduleSyncCallback(callback) {
        if (syncQueue === null) {
          syncQueue = [callback];
        } else {
          syncQueue.push(callback);
        }
      }
      function scheduleLegacySyncCallback(callback) {
        includesLegacySyncCallbacks = true;
        scheduleSyncCallback(callback);
      }
      function flushSyncCallbacksOnlyInLegacyMode() {
        if (includesLegacySyncCallbacks) {
          flushSyncCallbacks();
        }
      }
      function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          var i2 = 0;
          var previousUpdatePriority = getCurrentUpdatePriority();
          try {
            var isSync = true;
            var queue = syncQueue;
            setCurrentUpdatePriority(DiscreteEventPriority);
            for (; i2 < queue.length; i2++) {
              var callback = queue[i2];
              do {
                callback = callback(isSync);
              } while (callback !== null);
            }
            syncQueue = null;
            includesLegacySyncCallbacks = false;
          } catch (error2) {
            if (syncQueue !== null) {
              syncQueue = syncQueue.slice(i2 + 1);
            }
            scheduleCallback(ImmediatePriority, flushSyncCallbacks);
            throw error2;
          } finally {
            setCurrentUpdatePriority(previousUpdatePriority);
            isFlushingSyncQueue = false;
          }
        }
        return null;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function isForkedChild(workInProgress2) {
        warnIfNotHydrating();
        return (workInProgress2.flags & Forked) !== NoFlags;
      }
      function getForksAtLevel(workInProgress2) {
        warnIfNotHydrating();
        return treeForkCount;
      }
      function getTreeId() {
        var overflow = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        var baseOverflow = treeContextOverflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          treeContextId = 1 << restOfLength | id;
          treeContextOverflow = overflow;
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          treeContextId = 1 << length | _id;
          treeContextOverflow = _overflow;
        }
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        var returnFiber = workInProgress2.return;
        if (returnFiber !== null) {
          var numberOfForks = 1;
          var slotIndex = 0;
          pushTreeFork(workInProgress2, numberOfForks);
          pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      function popTreeContext(workInProgress2) {
        while (workInProgress2 === treeForkProvider) {
          treeForkProvider = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
          treeForkCount = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
        }
        while (workInProgress2 === treeContextProvider) {
          treeContextProvider = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextOverflow = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextId = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
        }
      }
      function getSuspendedTreeContext() {
        warnIfNotHydrating();
        if (treeContextProvider !== null) {
          return {
            id: treeContextId,
            overflow: treeContextOverflow
          };
        } else {
          return null;
        }
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        {
          if (!getIsHydrating()) {
            error("Expected to be hydrating. This is a bug in React. Please file an issue.");
          }
        }
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var didSuspendOrErrorDEV = false;
      var hydrationErrors = null;
      function warnIfHydrating() {
        {
          if (isHydrating) {
            error("We should not be hydrating here. This is a bug in React. Please file a bug.");
          }
        }
      }
      function markDidThrowWhileHydratingDEV() {
        {
          didSuspendOrErrorDEV = true;
        }
      }
      function didSuspendOrErrorWhileHydratingDEV() {
        {
          return didSuspendOrErrorDEV;
        }
      }
      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        return true;
      }
      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
        nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        if (treeContext !== null) {
          restoreSuspendedTreeContext(fiber, treeContext);
        }
        return true;
      }
      function warnUnhydratedInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot: {
              didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
              break;
            }
            case HostComponent: {
              var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotHydrateInstance(
                returnFiber.type,
                returnFiber.memoizedProps,
                returnFiber.stateNode,
                instance,
                // TODO: Delete this argument when we remove the legacy root API.
                isConcurrentMode
              );
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
              break;
            }
          }
        }
      }
      function deleteHydratableInstance(returnFiber, instance) {
        warnUnhydratedInstance(returnFiber, instance);
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        var deletions = returnFiber.deletions;
        if (deletions === null) {
          returnFiber.deletions = [childToDelete];
          returnFiber.flags |= ChildDeletion;
        } else {
          deletions.push(childToDelete);
        }
      }
      function warnNonhydratedInstance(returnFiber, fiber) {
        {
          if (didSuspendOrErrorDEV) {
            return;
          }
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                  break;
              }
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent: {
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _type,
                    _props,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostText: {
                  var _text = fiber.pendingProps;
                  var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _text,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode
                  );
                  break;
                }
              }
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              var _parentInstance = suspenseState.dehydrated;
              if (_parentInstance !== null) switch (fiber.tag) {
                case HostComponent:
                  var _type2 = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                  break;
                case HostText:
                  var _text2 = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                  break;
              }
              break;
            }
            default:
              return;
          }
        }
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement;
        warnNonhydratedInstance(returnFiber, fiber);
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type;
            fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type);
            if (instance !== null) {
              fiber.stateNode = instance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = getFirstHydratableChild(instance);
              return true;
            }
            return false;
          }
          case HostText: {
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          case SuspenseComponent: {
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
            if (suspenseInstance !== null) {
              var suspenseState = {
                dehydrated: suspenseInstance,
                treeContext: getSuspendedTreeContext(),
                retryLane: OffscreenLane
              };
              fiber.memoizedState = suspenseState;
              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
              dehydratedFragment.return = fiber;
              fiber.child = dehydratedFragment;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          default:
            return false;
        }
      }
      function shouldClientRenderOnMismatch(fiber) {
        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
      }
      function throwOnHydrationMismatch(fiber) {
        throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          var prevHydrationParentFiber = hydrationParentFiber;
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
        fiber.updateQueue = updatePayload;
        if (updatePayload !== null) {
          return true;
        }
        return false;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _isConcurrentMode2
                );
                break;
              }
            }
          }
        }
        return shouldUpdate;
      }
      function prepareToHydrateHostSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        hydrateSuspenseInstance(suspenseInstance, fiber);
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
          parent = parent.return;
        }
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) {
          return false;
        }
        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }
        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
          var nextInstance = nextHydratableInstance;
          if (nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnIfUnhydratedTailNodes(fiber);
              throwOnHydrationMismatch();
            } else {
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
          }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) {
          nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        } else {
          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        }
        return true;
      }
      function hasUnhydratedTailNodes() {
        return isHydrating && nextHydratableInstance !== null;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          warnUnhydratedInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }
      function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
        didSuspendOrErrorDEV = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        if (hydrationErrors !== null) {
          queueRecoverableErrors(hydrationErrors);
          hydrationErrors = null;
        }
      }
      function getIsHydrating() {
        return isHydrating;
      }
      function queueHydrationError(error2) {
        if (hydrationErrors === null) {
          hydrationErrors = [error2];
        } else {
          hydrationErrors.push(error2);
        }
      }
      var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
      var NoTransition = null;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig$1.transition;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      };
      {
        var findStrictRoot = function(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;
          while (node !== null) {
            if (node.mode & StrictLegacyMode) {
              maybeStrictRoot = node;
            }
            node = node.return;
          }
          return maybeStrictRoot;
        };
        var setToSortedString = function(set2) {
          var array = [];
          set2.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };
        var pendingComponentWillMountWarnings = [];
        var pendingUNSAFE_ComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUNSAFE_ComponentWillUpdateWarnings = [];
        var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }
          if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
          instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
          }
          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
          }
          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
              componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
          }
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
              UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
          }
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
              componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
          }
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          }
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
              componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
          }
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
              UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
          }
          if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }
          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === void 0) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) {
              return;
            }
            var firstFiber = fiberArray[0];
            var uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
              setCurrentFiber(firstFiber);
              error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
            } finally {
              resetCurrentFiber();
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
      }
      var didWarnAboutMaps;
      var didWarnAboutGenerators;
      var didWarnAboutStringRefs;
      var ownerHasKeyUseWarning;
      var ownerHasFunctionTypeWarning;
      var warnForMissingKey = function(child, returnFiber) {
      };
      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefs = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};
        warnForMissingKey = function(child, returnFiber) {
          if (child === null || typeof child !== "object") {
            return;
          }
          if (!child._store || child._store.validated || child.key != null) {
            return;
          }
          if (typeof child._store !== "object") {
            throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          }
          child._store.validated = true;
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasKeyUseWarning[componentName]) {
            return;
          }
          ownerHasKeyUseWarning[componentName] = true;
          error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
        };
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function coerceRef(returnFiber, current2, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
            // because these cannot be automatically converted to an arrow function
            // using a codemod. Therefore, we don't have to warn about string refs again.
            !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
            !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
            !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
            element._owner) {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (!didWarnAboutStringRefs[componentName]) {
                {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                }
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
          if (element._owner) {
            var owner = element._owner;
            var inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent) {
                throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
              }
              inst = ownerFiber.stateNode;
            }
            if (!inst) {
              throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
            }
            var resolvedInst = inst;
            {
              checkPropStringCoercion(mixedRef, "ref");
            }
            var stringRef = "" + mixedRef;
            if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
              return current2.ref;
            }
            var ref = function(value) {
              var refs = resolvedInst.refs;
              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };
            ref._stringRef = stringRef;
            return ref;
          } else {
            if (typeof mixedRef !== "string") {
              throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            }
            if (!element._owner) {
              throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
            }
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var childString = Object.prototype.toString.call(newChild);
        throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasFunctionTypeWarning[componentName]) {
            return;
          }
          ownerHasFunctionTypeWarning[componentName] = true;
          error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
        }
      }
      function resolveLazy(lazyType) {
        var payload = lazyType._payload;
        var init = lazyType._init;
        return init(payload);
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }
          var childToDelete = currentFirstChild;
          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = /* @__PURE__ */ new Map();
          var existingChild = currentFirstChild;
          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }
            existingChild = existingChild.sibling;
          }
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone = createWorkInProgress(fiber, pendingProps);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects) {
            newFiber.flags |= Forked;
            return lastPlacedIndex;
          }
          var current2 = newFiber.alternate;
          if (current2 !== null) {
            var oldIndex = current2.index;
            if (oldIndex < lastPlacedIndex) {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.flags |= Placement;
            return lastPlacedIndex;
          }
        }
        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.flags |= Placement;
          }
          return newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (current2 === null || current2.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, textContent);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE) {
            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
          }
          if (current2 !== null) {
            if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
            isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
              var existing = useFiber(current2, element.props);
              existing.ref = coerceRef(returnFiber, current2, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
          }
          var created = createFiberFromElement(element, returnFiber.mode, lanes);
          created.ref = coerceRef(returnFiber, current2, element);
          created.return = returnFiber;
          return created;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, portal.children || []);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateFragment2(returnFiber, current2, fragment, lanes, key) {
          if (current2 === null || current2.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, fragment);
            existing.return = returnFiber;
            return existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                _created2.return = returnFiber;
                return _created2;
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return createChild(returnFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              _created3.return = returnFiber;
              return _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }
            return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                if (newChild.key === key) {
                  return updateElement(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_PORTAL_TYPE: {
                if (newChild.key === key) {
                  return updatePortal(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }
              return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key = child.key;
                if (typeof key !== "string") {
                  break;
                }
                if (knownKeys === null) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                break;
              case REACT_LAZY_TYPE:
                var payload = child._payload;
                var init = child._init;
                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          {
            var knownKeys = null;
            for (var i2 = 0; i2 < newChildren.length; i2++) {
              var child = newChildren[i2];
              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              if (_newFiber === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }
              previousNewFiber = _newFiber;
            }
            if (getIsHydrating()) {
              var _numberOfForks = newIdx;
              pushTreeFork(returnFiber, _numberOfForks);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            if (_newFiber2 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }
              previousNewFiber = _newFiber2;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks2 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks2);
          }
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn !== "function") {
            throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            newChildrenIterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (newChildrenIterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
              var knownKeys = null;
              var _step = _newChildren.next();
              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null) {
            throw new Error("An iterable object provided no iterator.");
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();
          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              if (_newFiber3 === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }
              previousNewFiber = _newFiber3;
            }
            if (getIsHydrating()) {
              var _numberOfForks3 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks3);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }
              previousNewFiber = _newFiber4;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks4 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks4);
          }
          return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent);
            existing.return = returnFiber;
            return existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          var key = element.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                if (child.tag === Fragment) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, element.props.children);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              } else {
                if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var _existing = useFiber(child, element.props);
                  _existing.ref = coerceRef(returnFiber, child, element);
                  _existing.return = returnFiber;
                  {
                    _existing._debugSource = element._source;
                    _existing._debugOwner = element._owner;
                  }
                  return _existing;
                }
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          var key = portal.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
            }
            if (isArray(newChild)) {
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (getIteratorFn(newChild)) {
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);
      function cloneChildFibers(current2, workInProgress2) {
        if (current2 !== null && workInProgress2.child !== current2.child) {
          throw new Error("Resuming work not yet implemented.");
        }
        if (workInProgress2.child === null) {
          return;
        }
        var currentChild = workInProgress2.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress2.child = newChild;
        newChild.return = workInProgress2;
        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
          newChild.return = workInProgress2;
        }
        newChild.sibling = null;
      }
      function resetChildFibers(workInProgress2, lanes) {
        var child = workInProgress2.child;
        while (child !== null) {
          resetWorkInProgress(child, lanes);
          child = child.sibling;
        }
      }
      var valueCursor = createCursor(null);
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastFullyObservedContext = null;
      var isDisallowedContextReadInDEV = false;
      function resetContextDependencies() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }
      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function pushProvider(providerFiber, context, nextValue) {
        {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        {
          {
            context._currentValue = currentValue;
          }
        }
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        var node = parent;
        while (node !== null) {
          var alternate = node.alternate;
          if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
            node.childLanes = mergeLanes(node.childLanes, renderLanes2);
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
          } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
          }
          if (node === propagationRoot) {
            break;
          }
          node = node.return;
        }
        {
          if (node !== propagationRoot) {
            error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
      }
      function propagateContextChange(workInProgress2, context, renderLanes2) {
        {
          propagateContextChange_eager(workInProgress2, context, renderLanes2);
        }
      }
      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
        var fiber = workInProgress2.child;
        if (fiber !== null) {
          fiber.return = workInProgress2;
        }
        while (fiber !== null) {
          var nextFiber = void 0;
          var list = fiber.dependencies;
          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.firstContext;
            while (dependency !== null) {
              if (dependency.context === context) {
                if (fiber.tag === ClassComponent) {
                  var lane = pickArbitraryLane(renderLanes2);
                  var update = createUpdate(NoTimestamp, lane);
                  update.tag = ForceUpdate;
                  var updateQueue = fiber.updateQueue;
                  if (updateQueue === null) ;
                  else {
                    var sharedQueue = updateQueue.shared;
                    var pending = sharedQueue.pending;
                    if (pending === null) {
                      update.next = update;
                    } else {
                      update.next = pending.next;
                      pending.next = update;
                    }
                    sharedQueue.pending = update;
                  }
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                list.lanes = mergeLanes(list.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
          } else if (fiber.tag === DehydratedFragment) {
            var parentSuspense = fiber.return;
            if (parentSuspense === null) {
              throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
            }
            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
            var _alternate = parentSuspense.alternate;
            if (_alternate !== null) {
              _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }
          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;
            while (nextFiber !== null) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
              if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                markWorkInProgressReceivedUpdate();
              }
              dependencies.firstContext = null;
            }
          }
        }
      }
      function readContext(context) {
        {
          if (isDisallowedContextReadInDEV) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        var value = context._currentValue;
        if (lastFullyObservedContext === context) ;
        else {
          var contextItem = {
            context,
            memoizedValue: value,
            next: null
          };
          if (lastContextDependency === null) {
            if (currentlyRenderingFiber === null) {
              throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
            lastContextDependency = contextItem;
            currentlyRenderingFiber.dependencies = {
              lanes: NoLanes,
              firstContext: contextItem
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }
        return value;
      }
      var concurrentQueues = null;
      function pushConcurrentUpdateQueue(queue) {
        if (concurrentQueues === null) {
          concurrentQueues = [queue];
        } else {
          concurrentQueues.push(queue);
        }
      }
      function finishQueueingConcurrentUpdates() {
        if (concurrentQueues !== null) {
          for (var i2 = 0; i2 < concurrentQueues.length; i2++) {
            var queue = concurrentQueues[i2];
            var lastInterleavedUpdate = queue.interleaved;
            if (lastInterleavedUpdate !== null) {
              queue.interleaved = null;
              var firstInterleavedUpdate = lastInterleavedUpdate.next;
              var lastPendingUpdate = queue.pending;
              if (lastPendingUpdate !== null) {
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = firstInterleavedUpdate;
                lastInterleavedUpdate.next = firstPendingUpdate;
              }
              queue.pending = lastInterleavedUpdate;
            }
          }
          concurrentQueues = null;
        }
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
      }
      function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, lane);
        }
        {
          if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          }
        }
        var node = sourceFiber;
        var parent = sourceFiber.return;
        while (parent !== null) {
          parent.childLanes = mergeLanes(parent.childLanes, lane);
          alternate = parent.alternate;
          if (alternate !== null) {
            alternate.childLanes = mergeLanes(alternate.childLanes, lane);
          } else {
            {
              if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
          }
          node = parent;
          parent = parent.return;
        }
        if (node.tag === HostRoot) {
          var root22 = node.stateNode;
          return root22;
        } else {
          return null;
        }
      }
      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate;
      var currentlyProcessingQueue;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;
      }
      function initializeUpdateQueue(fiber) {
        var queue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: NoLanes
          },
          effects: null
        };
        fiber.updateQueue = queue;
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        var queue = workInProgress2.updateQueue;
        var currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
          var clone = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: currentQueue.firstBaseUpdate,
            lastBaseUpdate: currentQueue.lastBaseUpdate,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          };
          workInProgress2.updateQueue = clone;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return null;
        }
        var sharedQueue = updateQueue.shared;
        {
          if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
        if (isUnsafeClassRenderPhaseUpdate()) {
          var pending = sharedQueue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          sharedQueue.pending = update;
          return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
        } else {
          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
        }
      }
      function entangleTransitions(root22, fiber, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return;
        }
        var sharedQueue = updateQueue.shared;
        if (isTransitionLane(lane)) {
          var queueLanes = sharedQueue.lanes;
          queueLanes = intersectLanes(queueLanes, root22.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          sharedQueue.lanes = newQueueLanes;
          markRootEntangled(root22, newQueueLanes);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue;
        var current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var newFirst = null;
            var newLast = null;
            var firstBaseUpdate = queue.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLast === null) {
                  newFirst = newLast = clone;
                } else {
                  newLast.next = clone;
                  newLast = clone;
                }
                update = update.next;
              } while (update !== null);
              if (newLast === null) {
                newFirst = newLast = capturedUpdate;
              } else {
                newLast.next = capturedUpdate;
                newLast = capturedUpdate;
              }
            } else {
              newFirst = newLast = capturedUpdate;
            }
            queue = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = queue;
            return;
          }
        }
        var lastBaseUpdate = queue.lastBaseUpdate;
        if (lastBaseUpdate === null) {
          queue.firstBaseUpdate = capturedUpdate;
        } else {
          lastBaseUpdate.next = capturedUpdate;
        }
        queue.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              var nextState = payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate: {
            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
          }
          case UpdateState: {
            var _payload = update.payload;
            var partialState;
            if (typeof _payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              partialState = _payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    _payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else {
              partialState = _payload;
            }
            if (partialState === null || partialState === void 0) {
              return prevState;
            }
            return assign({}, prevState, partialState);
          }
          case ForceUpdate: {
            hasForceUpdate = true;
            return prevState;
          }
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = false;
        {
          currentlyProcessingQueue = queue.shared;
        }
        var firstBaseUpdate = queue.firstBaseUpdate;
        var lastBaseUpdate = queue.lastBaseUpdate;
        var pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue;
          var firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          if (lastBaseUpdate === null) {
            firstBaseUpdate = firstPendingUpdate;
          } else {
            lastBaseUpdate.next = firstPendingUpdate;
          }
          lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
            if (currentLastBaseUpdate !== lastBaseUpdate) {
              if (currentLastBaseUpdate === null) {
                currentQueue.firstBaseUpdate = firstPendingUpdate;
              } else {
                currentLastBaseUpdate.next = firstPendingUpdate;
              }
              currentQueue.lastBaseUpdate = lastPendingUpdate;
            }
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue.baseState;
          var newLanes = NoLanes;
          var newBaseState = null;
          var newFirstBaseUpdate = null;
          var newLastBaseUpdate = null;
          var update = firstBaseUpdate;
          do {
            var updateLane = update.lane;
            var updateEventTime = update.eventTime;
            if (!isSubsetOfLanes(renderLanes2, updateLane)) {
              var clone = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              if (newLastBaseUpdate === null) {
                newFirstBaseUpdate = newLastBaseUpdate = clone;
                newBaseState = newState;
              } else {
                newLastBaseUpdate = newLastBaseUpdate.next = clone;
              }
              newLanes = mergeLanes(newLanes, updateLane);
            } else {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
              var callback = update.callback;
              if (callback !== null && // If the update was already committed, we should not queue its
              // callback again.
              update.lane !== NoLane) {
                workInProgress2.flags |= Callback;
                var effects = queue.effects;
                if (effects === null) {
                  queue.effects = [update];
                } else {
                  effects.push(update);
                }
              }
            }
            update = update.next;
            if (update === null) {
              pendingQueue = queue.shared.pending;
              if (pendingQueue === null) {
                break;
              } else {
                var _lastPendingUpdate = pendingQueue;
                var _firstPendingUpdate = _lastPendingUpdate.next;
                _lastPendingUpdate.next = null;
                update = _firstPendingUpdate;
                queue.lastBaseUpdate = _lastPendingUpdate;
                queue.shared.pending = null;
              }
            }
          } while (true);
          if (newLastBaseUpdate === null) {
            newBaseState = newState;
          }
          queue.baseState = newBaseState;
          queue.firstBaseUpdate = newFirstBaseUpdate;
          queue.lastBaseUpdate = newLastBaseUpdate;
          var lastInterleaved = queue.shared.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              newLanes = mergeLanes(newLanes, interleaved.lane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (firstBaseUpdate === null) {
            queue.shared.lanes = NoLanes;
          }
          markSkippedUpdateLanes(newLanes);
          workInProgress2.lanes = newLanes;
          workInProgress2.memoizedState = newState;
        }
        {
          currentlyProcessingQueue = null;
        }
      }
      function callCallback(callback, context) {
        if (typeof callback !== "function") {
          throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
        }
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) {
          for (var i2 = 0; i2 < effects.length; i2++) {
            var effect = effects[i2];
            var callback = effect.callback;
            if (callback !== null) {
              effect.callback = null;
              callCallback(callback, instance);
            }
          }
        }
      }
      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c) {
        if (c === NO_CONTEXT) {
          throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        }
        return c;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type);
        if (context === nextContext) {
          return;
        }
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }
      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }
      var DefaultSuspenseContext = 0;
      var SubtreeSuspenseContextMask = 1;
      var InvisibleParentSuspenseContext = 1;
      var ForceSuspenseFallback = 2;
      var suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null) {
          if (nextState.dehydrated !== null) {
            return true;
          }
          return false;
        }
        workInProgress2.memoizedProps;
        {
          return true;
        }
      }
      function findFirstSuspended(row) {
        var node = row;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                return node;
              }
            }
          } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
          // keep track of whether it suspended or not.
          node.memoizedProps.revealOrder !== void 0) {
            var didSuspend = (node.flags & DidCapture) !== NoFlags;
            if (didSuspend) {
              return node;
            }
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) {
            return null;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === row) {
              return null;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var NoFlags$1 = (
        /*   */
        0
      );
      var HasEffect = (
        /* */
        1
      );
      var Insertion = (
        /*  */
        2
      );
      var Layout = (
        /*    */
        4
      );
      var Passive$1 = (
        /*   */
        8
      );
      var workInProgressSources = [];
      function resetWorkInProgressVersions() {
        for (var i2 = 0; i2 < workInProgressSources.length; i2++) {
          var mutableSource = workInProgressSources[i2];
          {
            mutableSource._workInProgressVersionPrimary = null;
          }
        }
        workInProgressSources.length = 0;
      }
      function registerMutableSourceForHydration(root22, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source);
        if (root22.mutableSourceEagerHydrationData == null) {
          root22.mutableSourceEagerHydrationData = [mutableSource, version];
        } else {
          root22.mutableSourceEagerHydrationData.push(mutableSource, version);
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
      var didWarnAboutMismatchedHooksForComponent;
      var didWarnUncachedGetSnapshot;
      {
        didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      }
      var renderLanes = NoLanes;
      var currentlyRenderingFiber$1 = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var localIdCounter = 0;
      var globalClientIdCounter = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;
      var hookTypesDev = null;
      var hookTypesUpdateIndexDev = -1;
      var ignorePreviousDependencies = false;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev === null) {
            hookTypesDev = [hookName];
          } else {
            hookTypesDev.push(hookName);
          }
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
              warnOnHookMismatchInDev(hookName);
            }
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        {
          if (deps !== void 0 && deps !== null && !isArray(deps)) {
            error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
          }
        }
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
              var table = "";
              var secondColumnStart = 30;
              for (var i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                var oldHookName = hookTypesDev[i2];
                var newHookName = i2 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                var row = i2 + 1 + ". " + oldHookName;
                while (row.length < secondColumnStart) {
                  row += " ";
                }
                row += newHookName + "\n";
                table += row;
              }
              error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
          }
        }
      }
      function throwInvalidHookError() {
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        {
          if (ignorePreviousDependencies) {
            return false;
          }
        }
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
          }
        }
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
          if (objectIs(nextDeps[i2], prevDeps[i2])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress2;
        {
          hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
        }
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = NoLanes;
        {
          if (current2 !== null && current2.memoizedState !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
          } else if (hookTypesDev !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
          } else {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
          }
        }
        var children = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            numberOfReRenders += 1;
            {
              ignorePreviousDependencies = false;
            }
            currentHook = null;
            workInProgressHook = null;
            workInProgress2.updateQueue = null;
            {
              hookTypesUpdateIndexDev = -1;
            }
            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
            children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        {
          workInProgress2._debugHookTypes = hookTypesDev;
        }
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          currentHookNameInDev = null;
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
          // and creates false positives. To make this work in legacy mode, we'd
          // need to mark fibers that commit in an incomplete state, somehow. For
          // now I'll disable the warning that most of the bugs that would trigger
          // it are either exclusive to concurrent mode or exist in both.
          (current2.mode & ConcurrentMode) !== NoMode) {
            error("Internal React error: Expected static flag was missing. Please notify the React team.");
          }
        }
        didScheduleRenderPhaseUpdate = false;
        if (didRenderTooFewHooks) {
          throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        }
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue;
        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
          workInProgress2.flags &= -50333701;
        } else {
          workInProgress2.flags &= -2053;
        }
        current2.lanes = removeLanes(current2.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
          var hook = currentlyRenderingFiber$1.memoizedState;
          while (hook !== null) {
            var queue = hook.queue;
            if (queue !== null) {
              queue.pending = null;
            }
            hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          isUpdatingOpaqueValueInRenderPhase = false;
        }
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        localIdCounter = 0;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        if (workInProgressHook === null) {
          currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current2 = currentlyRenderingFiber$1.alternate;
          if (current2 !== null) {
            nextCurrentHook = current2.memoizedState;
          } else {
            nextCurrentHook = null;
          }
        } else {
          nextCurrentHook = currentHook.next;
        }
        var nextWorkInProgressHook;
        if (workInProgressHook === null) {
          nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        } else {
          nextWorkInProgressHook = workInProgressHook.next;
        }
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
        } else {
          if (nextCurrentHook === null) {
            throw new Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null,
          stores: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState;
        if (init !== void 0) {
          initialState = init(initialArg);
        } else {
          initialState = initialArg;
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var current2 = currentHook;
        var baseQueue = current2.baseQueue;
        var pendingQueue = queue.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next;
            var pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst;
            pendingQueue.next = baseFirst;
          }
          {
            if (current2.baseQueue !== baseQueue) {
              error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            }
          }
          current2.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next;
          var newState = current2.baseState;
          var newBaseState = null;
          var newBaseQueueFirst = null;
          var newBaseQueueLast = null;
          var update = first;
          do {
            var updateLane = update.lane;
            if (!isSubsetOfLanes(renderLanes, updateLane)) {
              var clone = {
                lane: updateLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              if (newBaseQueueLast === null) {
                newBaseQueueFirst = newBaseQueueLast = clone;
                newBaseState = newState;
              } else {
                newBaseQueueLast = newBaseQueueLast.next = clone;
              }
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
              markSkippedUpdateLanes(updateLane);
            } else {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.hasEagerState) {
                newState = update.eagerState;
              } else {
                var action = update.action;
                newState = reducer(newState, action);
              }
            }
            update = update.next;
          } while (update !== null && update !== first);
          if (newBaseQueueLast === null) {
            newBaseState = newState;
          } else {
            newBaseQueueLast.next = newBaseQueueFirst;
          }
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          hook.baseState = newBaseState;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = newState;
        }
        var lastInterleaved = queue.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do {
            var interleavedLane = interleaved.lane;
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
            markSkippedUpdateLanes(interleavedLane);
            interleaved = interleaved.next;
          } while (interleaved !== lastInterleaved);
        } else if (baseQueue === null) {
          queue.lanes = NoLanes;
        }
        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch;
        var lastRenderPhaseUpdate = queue.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          var update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer(newState, action);
            update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          if (hook.baseQueue === null) {
            hook.baseState = newState;
          }
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = mountWorkInProgressHook();
        var nextSnapshot;
        var isHydrating2 = getIsHydrating();
        if (isHydrating2) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          nextSnapshot = getServerSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              if (nextSnapshot !== getServerSnapshot()) {
                error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
        } else {
          nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var root22 = getWorkInProgressRoot();
          if (root22 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root22, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        hook.memoizedState = nextSnapshot;
        var inst = {
          value: nextSnapshot,
          getSnapshot
        };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        fiber.flags |= Passive;
        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = updateWorkInProgressHook();
        var nextSnapshot = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            if (!objectIs(nextSnapshot, cachedSnapshot)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var prevSnapshot = hook.memoizedState;
        var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
        if (snapshotChanged) {
          hook.memoizedState = nextSnapshot;
          markWorkInProgressReceivedUpdate();
        }
        var inst = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
        // checking whether we scheduled a subscription effect above.
        workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          var root22 = getWorkInProgressRoot();
          if (root22 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root22, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        return nextSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= StoreConsistency;
        var check = {
          getSnapshot,
          value: renderedSnapshot
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.stores = [check];
        } else {
          var stores = componentUpdateQueue.stores;
          if (stores === null) {
            componentUpdateQueue.stores = [check];
          } else {
            stores.push(check);
          }
        }
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceStoreRerender(fiber);
        }
      }
      function subscribeToStore(fiber, inst, subscribe) {
        var handleStoreChange = function() {
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        };
        return subscribe(handleStoreChange);
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        if (root22 !== null) {
          scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
        }
      }
      function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState === "function") {
          initialState = initialState();
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag,
          create,
          destroy,
          deps,
          // Circular
          next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        {
          var _ref2 = {
            current: initialValue
          };
          hook.memoizedState = _ref2;
          return _ref2;
        }
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var destroy = void 0;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
      }
      function mountEffect(create, deps) {
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
        } else {
          return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
        }
      }
      function updateEffect(create, deps) {
        return updateEffectImpl(Passive, Passive$1, create, deps);
      }
      function mountInsertionEffect(create, deps) {
        return mountEffectImpl(Update, Insertion, create, deps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(Update, Insertion, create, deps);
      }
      function mountLayoutEffect(create, deps) {
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if (typeof ref === "function") {
          var refCallback = ref;
          var _inst = create();
          refCallback(_inst);
          return function() {
            refCallback(null);
          };
        } else if (ref !== null && ref !== void 0) {
          var refObject = ref;
          {
            if (!refObject.hasOwnProperty("current")) {
              error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
            }
          }
          var _inst2 = create();
          refObject.current = _inst2;
          return function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function updateImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function mountDebugValue(value, formatterFn) {
      }
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function mountDeferredValue(value) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = value;
        return value;
      }
      function updateDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        var resolvedCurrentHook = currentHook;
        var prevValue = resolvedCurrentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value);
      }
      function rerenderDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        if (currentHook === null) {
          hook.memoizedState = value;
          return value;
        } else {
          var prevValue = currentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
      }
      function updateDeferredValueImpl(hook, prevValue, value) {
        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
        if (shouldDeferValue) {
          if (!objectIs(value, prevValue)) {
            var deferredLane = claimNextTransitionLane();
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
            markSkippedUpdateLanes(deferredLane);
            hook.baseState = true;
          }
          return prevValue;
        } else {
          if (hook.baseState) {
            hook.baseState = false;
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = value;
          return value;
        }
      }
      function startTransition(setPending, callback, options2) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
        setPending(true);
        var prevTransition = ReactCurrentBatchConfig$2.transition;
        ReactCurrentBatchConfig$2.transition = {};
        var currentTransition = ReactCurrentBatchConfig$2.transition;
        {
          ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
        }
        try {
          setPending(false);
          callback();
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$2.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      function mountTransition() {
        var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
        var start = startTransition.bind(null, setPending);
        var hook = mountWorkInProgressHook();
        hook.memoizedState = start;
        return [isPending, start];
      }
      function updateTransition() {
        var _updateState = updateState(), isPending = _updateState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      function rerenderTransition() {
        var _rerenderState = rerenderState(), isPending = _rerenderState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      var isUpdatingOpaqueValueInRenderPhase = false;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        {
          return isUpdatingOpaqueValueInRenderPhase;
        }
      }
      function mountId() {
        var hook = mountWorkInProgressHook();
        var root22 = getWorkInProgressRoot();
        var identifierPrefix = root22.identifierPrefix;
        var id;
        if (getIsHydrating()) {
          var treeId = getTreeId();
          id = ":" + identifierPrefix + "R" + treeId;
          var localId = localIdCounter++;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          id += ":";
        } else {
          var globalClientId = globalClientIdCounter++;
          id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
        }
        hook.memoizedState = id;
        return id;
      }
      function updateId() {
        var hook = updateWorkInProgressHook();
        var id = hook.memoizedState;
        return id;
      }
      function dispatchReducerAction(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var root22 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root22 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
            entangleTransitionUpdate(root22, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function dispatchSetState(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var alternate = fiber.alternate;
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }
              try {
                var currentState = queue.lastRenderedState;
                var eagerState = lastRenderedReducer(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState)) {
                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                  return;
                }
              } catch (error2) {
              } finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }
          var root22 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root22 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
            entangleTransitionUpdate(root22, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        if (pending === null) {
          update.next = update;
        } else {
          update.next = pending.next;
          pending.next = update;
        }
        queue.pending = update;
      }
      function entangleTransitionUpdate(root22, queue, lane) {
        if (isTransitionLane(lane)) {
          var queueLanes = queue.lanes;
          queueLanes = intersectLanes(queueLanes, root22.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          queue.lanes = newQueueLanes;
          markRootEntangled(root22, newQueueLanes);
        }
      }
      function markUpdateInDevTools(fiber, lane, action) {
        {
          markStateUpdateScheduled(fiber, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnMountWithHookTypesInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var HooksDispatcherOnRerenderInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        };
        var warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now;
      var commitTime = 0;
      var layoutEffectStartTime = -1;
      var profilerStartTime = -1;
      var passiveEffectStartTime = -1;
      var currentUpdateIsNested = false;
      var nestedUpdateScheduled = false;
      function isCurrentUpdateNested() {
        return currentUpdateIsNested;
      }
      function markNestedUpdateScheduled() {
        {
          nestedUpdateScheduled = true;
        }
      }
      function resetNestedUpdateFlag() {
        {
          currentUpdateIsNested = false;
          nestedUpdateScheduled = false;
        }
      }
      function syncNestedUpdateFlag() {
        {
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
        }
      }
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$1();
        }
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }
          profilerStartTime = -1;
        }
      }
      function recordLayoutEffectDuration(fiber) {
        if (layoutEffectStartTime >= 0) {
          var elapsedTime = now$1() - layoutEffectStartTime;
          layoutEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root22 = parentFiber.stateNode;
                root22.effectDuration += elapsedTime;
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode.effectDuration += elapsedTime;
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function recordPassiveEffectDuration(fiber) {
        if (passiveEffectStartTime >= 0) {
          var elapsedTime = now$1() - passiveEffectStartTime;
          passiveEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root22 = parentFiber.stateNode;
                if (root22 !== null) {
                  root22.passiveEffectDuration += elapsedTime;
                }
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                if (parentStateNode !== null) {
                  parentStateNode.passiveEffectDuration += elapsedTime;
                }
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function startLayoutEffectTimer() {
        layoutEffectStartTime = now$1();
      }
      function startPassiveEffectTimer() {
        passiveEffectStartTime = now$1();
      }
      function transferActualDuration(fiber) {
        var child = fiber.child;
        while (child) {
          fiber.actualDuration += child.actualDuration;
          child = child.sibling;
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      var fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent;
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      var didWarnAboutLegacyContext$1;
      {
        didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function() {
            throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState;
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
        workInProgress2.memoizedState = memoizedState;
        if (workInProgress2.lanes === NoLanes) {
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }
          var root22 = enqueueUpdate(fiber, update, lane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
            entangleTransitions(root22, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ReplaceState;
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }
          var root22 = enqueueUpdate(fiber, update, lane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
            entangleTransitions(root22, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }
          var root22 = enqueueUpdate(fiber, update, lane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
            entangleTransitions(root22, fiber, lane);
          }
          {
            markForceUpdateScheduled(fiber, lane);
          }
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if (typeof instance.shouldComponentUpdate === "function") {
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            if (shouldUpdate === void 0) {
              error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
            }
          }
          return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }
        return true;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance = workInProgress2.stateNode;
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
            }
            if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name);
            }
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== void 0 && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function adoptClassInstance(workInProgress2, instance) {
        instance.updater = classComponentUpdater;
        workInProgress2.stateNode = instance;
        set(instance, workInProgress2);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = (
              // Allow null for conditional declaration
              contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
            );
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === void 0) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== void 0) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        var instance = new ctor(props, context);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              instance = new ctor(props, context);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
        adoptClassInstance(workInProgress2, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        if (isLegacyContextConsumer) {
          cacheContext(workInProgress2, unmaskedContext, context);
        }
        return instance;
      }
      function callComponentWillMount(workInProgress2, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }
        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }
        if (instance.state !== oldState) {
          {
            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        {
          checkClassInstance(workInProgress2, ctor, newProps);
        }
        var instance = workInProgress2.stateNode;
        instance.props = newProps;
        instance.state = workInProgress2.memoizedState;
        instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          instance.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
          }
          {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
          }
        }
        instance.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress2, instance);
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof instance.componentDidMount === "function") {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          workInProgress2.flags |= fiberFlags;
        }
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        var oldProps = workInProgress2.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
          }
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags = Update;
            {
              _fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags2 = Update;
            {
              _fiberFlags2 |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags2 |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags2;
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps;
        var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
        // both before and after `shouldComponentUpdate` has been called. Not ideal,
        // but I'm loath to refactor this function. This only happens for memoized
        // components so it's not that common.
        enableLazyContextPropagation;
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
          }
          if (typeof instance.componentDidUpdate === "function") {
            workInProgress2.flags |= Update;
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress2.flags |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function createCapturedValueAtFiber(value, source) {
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source),
          digest: null
        };
      }
      function createCapturedValue(value, digest, stack) {
        return {
          value,
          source: null,
          stack: stack != null ? stack : null,
          digest: digest != null ? digest : null
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return true;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === false) {
            return;
          }
          var error2 = errorInfo.value;
          if (true) {
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : "";
            if (error2 != null && error2._suppressLogging) {
              if (boundary.tag === ClassComponent) {
                return;
              }
              console["error"](error2);
            }
            var componentName = source ? getComponentNameFromFiber(source) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
            var errorBoundaryMessage;
            if (boundary.tag === HostRoot) {
              errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            } else {
              var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            }
            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
            console["error"](combinedMessage);
          }
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        update.callback = function() {
          onUncaughtError(error2);
          logCapturedError(fiber, errorInfo);
        };
        return update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error$1);
          };
          update.callback = function() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }
            var error$12 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$12, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                if (!includesSomeLane(fiber.lanes, SyncLane)) {
                  error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                }
              }
            }
          };
        }
        return update;
      }
      function attachPingListener(root22, wakeable, lanes) {
        var pingCache = root22.pingCache;
        var threadIDs;
        if (pingCache === null) {
          pingCache = root22.pingCache = new PossiblyWeakMap$1();
          threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else {
          threadIDs = pingCache.get(wakeable);
          if (threadIDs === void 0) {
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          }
        }
        if (!threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root22, wakeable, lanes);
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root22, lanes);
            }
          }
          wakeable.then(ping, ping);
        }
      }
      function attachRetryListener(suspenseBoundary, root22, wakeable, lanes) {
        var wakeables = suspenseBoundary.updateQueue;
        if (wakeables === null) {
          var updateQueue = /* @__PURE__ */ new Set();
          updateQueue.add(wakeable);
          suspenseBoundary.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        }
      }
      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
        var tag = sourceFiber.tag;
        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
          var currentSource = sourceFiber.alternate;
          if (currentSource) {
            sourceFiber.updateQueue = currentSource.updateQueue;
            sourceFiber.memoizedState = currentSource.memoizedState;
            sourceFiber.lanes = currentSource.lanes;
          } else {
            sourceFiber.updateQueue = null;
            sourceFiber.memoizedState = null;
          }
        }
      }
      function getNearestSuspenseBoundaryToCapture(returnFiber) {
        var node = returnFiber;
        do {
          if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
            return node;
          }
          node = node.return;
        } while (node !== null);
        return null;
      }
      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root22, rootRenderLanes) {
        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
          if (suspenseBoundary === returnFiber) {
            suspenseBoundary.flags |= ShouldCapture;
          } else {
            suspenseBoundary.flags |= DidCapture;
            sourceFiber.flags |= ForceUpdateForLegacySuspense;
            sourceFiber.flags &= -52805;
            if (sourceFiber.tag === ClassComponent) {
              var currentSourceFiber = sourceFiber.alternate;
              if (currentSourceFiber === null) {
                sourceFiber.tag = IncompleteClassComponent;
              } else {
                var update = createUpdate(NoTimestamp, SyncLane);
                update.tag = ForceUpdate;
                enqueueUpdate(sourceFiber, update, SyncLane);
              }
            }
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
          }
          return suspenseBoundary;
        }
        suspenseBoundary.flags |= ShouldCapture;
        suspenseBoundary.lanes = rootRenderLanes;
        return suspenseBoundary;
      }
      function throwException(root22, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= Incomplete;
        {
          if (isDevToolsPresent) {
            restorePendingUpdaters(root22, rootRenderLanes);
          }
        }
        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var wakeable = value;
          resetSuspendedComponent(sourceFiber);
          {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
            }
          }
          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (suspenseBoundary !== null) {
            suspenseBoundary.flags &= ~ForceClientRender;
            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root22, rootRenderLanes);
            if (suspenseBoundary.mode & ConcurrentMode) {
              attachPingListener(root22, wakeable, rootRenderLanes);
            }
            attachRetryListener(suspenseBoundary, root22, wakeable);
            return;
          } else {
            if (!includesSyncLane(rootRenderLanes)) {
              attachPingListener(root22, wakeable, rootRenderLanes);
              renderDidSuspendDelayIfPossible();
              return;
            }
            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            value = uncaughtSuspenseError;
          }
        } else {
          if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
            markDidThrowWhileHydratingDEV();
            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (_suspenseBoundary !== null) {
              if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                _suspenseBoundary.flags |= ForceClientRender;
              }
              markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root22, rootRenderLanes);
              queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
              return;
            }
          }
        }
        value = createCapturedValueAtFiber(value, sourceFiber);
        renderDidError(value);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, update);
              return;
            }
            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress2.type;
              var instance = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      function getSuspendedCache() {
        {
          return null;
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass;
      var didWarnAboutModulePatternComponent;
      var didWarnAboutContextTypeOnFunctionComponent;
      var didWarnAboutGetDerivedStateOnFunctionComponent;
      var didWarnAboutFunctionRefs;
      var didWarnAboutReassigningProps;
      var didWarnAboutRevealOrder;
      var didWarnAboutTailOptions;
      var didWarnAboutDefaultPropsOnFunctionComponent;
      {
        didWarnAboutBadClass = {};
        didWarnAboutModulePatternComponent = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
        didWarnAboutRevealOrder = {};
        didWarnAboutTailOptions = {};
        didWarnAboutDefaultPropsOnFunctionComponent = {};
      }
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        if (current2 === null) {
          workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
        }
      }
      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var render2 = Component.render;
        var ref = workInProgress2.ref;
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (current2 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
          Component.defaultProps === void 0) {
            var resolvedType = type;
            {
              resolvedType = resolveFunctionForHotReloading(type);
            }
            workInProgress2.tag = SimpleMemoComponent;
            workInProgress2.type = resolvedType;
            {
              validateFunctionComponentInDev(workInProgress2, type);
            }
            return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(type)
              );
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          child.ref = workInProgress2.ref;
          child.return = workInProgress2;
          workInProgress2.child = child;
          return child;
        }
        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;
          if (_innerPropTypes) {
            checkPropTypes(
              _innerPropTypes,
              nextProps,
              // Resolved props
              "prop",
              getComponentNameFromType(_type)
            );
          }
        }
        var currentChild = current2.child;
        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
        if (!hasScheduledUpdateOrContext) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;
          if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress2.ref;
        newChild.return = workInProgress2;
        workInProgress2.child = newChild;
        return newChild;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerMemoType = workInProgress2.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              var lazyComponent = outerMemoType;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                outerMemoType = init(payload);
              } catch (x) {
                outerMemoType = null;
              }
              var outerPropTypes = outerMemoType && outerMemoType.propTypes;
              if (outerPropTypes) {
                checkPropTypes(
                  outerPropTypes,
                  nextProps,
                  // Resolved (SimpleMemoComponent has no defaultProps)
                  "prop",
                  getComponentNameFromType(outerMemoType)
                );
              }
            }
          }
        }
        if (current2 !== null) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
          workInProgress2.type === current2.type) {
            didReceiveUpdate = false;
            workInProgress2.pendingProps = nextProps = prevProps;
            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
              workInProgress2.lanes = current2.lanes;
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            }
          }
        }
        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current2 !== null ? current2.memoizedState : null;
        if (nextProps.mode === "hidden" || enableLegacyHidden) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = nextState;
            pushRenderLanes(workInProgress2, renderLanes2);
          } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
            var spawnedCachePool = null;
            var nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else {
              nextBaseLanes = renderLanes2;
            }
            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
            var _nextState = {
              baseLanes: nextBaseLanes,
              cachePool: spawnedCachePool,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState;
            workInProgress2.updateQueue = null;
            pushRenderLanes(workInProgress2, nextBaseLanes);
            return null;
          } else {
            var _nextState2 = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          }
        } else {
          var _subtreeRenderLanes;
          if (prevState !== null) {
            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
            workInProgress2.memoizedState = null;
          } else {
            _subtreeRenderLanes = renderLanes2;
          }
          pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateFragment(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMode(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateProfiler(current2, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update;
          {
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
        }
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          switch (shouldError(workInProgress2)) {
            case false: {
              var _instance = workInProgress2.stateNode;
              var ctor = workInProgress2.type;
              var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
              var state = tempInstance.state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            }
            case true: {
              workInProgress2.flags |= DidCapture;
              workInProgress2.flags |= ShouldCapture;
              var error$1 = new Error("Simulated error coming from DevTools");
              var lane = pickArbitraryLane(renderLanes2);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
              enqueueCapturedUpdate(workInProgress2, update);
              break;
            }
          }
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode;
        var shouldUpdate;
        if (instance === null) {
          resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          shouldUpdate = true;
        } else if (current2 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        } else {
          shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current2, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, false);
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        var instance = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;
          {
            stopProfilerTimerIfRunning();
          }
        } else {
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            setIsRendering(true);
            nextChildren = instance.render();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance.render();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
        }
        workInProgress2.flags |= PerformedWork;
        if (current2 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        workInProgress2.memoizedState = instance.state;
        if (hasContext) {
          invalidateContextProvider(workInProgress2, Component, true);
        }
        return workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root22 = workInProgress2.stateNode;
        if (root22.pendingContext) {
          pushTopLevelContextObject(workInProgress2, root22.pendingContext, root22.pendingContext !== root22.context);
        } else if (root22.context) {
          pushTopLevelContextObject(workInProgress2, root22.context, false);
        }
        pushHostContainer(workInProgress2, root22.containerInfo);
      }
      function updateHostRoot(current2, workInProgress2, renderLanes2) {
        pushHostRootContext(workInProgress2);
        if (current2 === null) {
          throw new Error("Should have a current fiber. This is a bug in React.");
        }
        var nextProps = workInProgress2.pendingProps;
        var prevState = workInProgress2.memoizedState;
        var prevChildren = prevState.element;
        cloneUpdateQueue(current2, workInProgress2);
        processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState;
        workInProgress2.stateNode;
        var nextChildren = nextState.element;
        if (prevState.isDehydrated) {
          var overrideState = {
            element: nextChildren,
            isDehydrated: false,
            cache: nextState.cache,
            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
            transitions: nextState.transitions
          };
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = overrideState;
          workInProgress2.memoizedState = overrideState;
          if (workInProgress2.flags & ForceClientRender) {
            var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
          } else if (nextChildren !== prevChildren) {
            var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
          } else {
            enterHydrationState(workInProgress2);
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            var node = child;
            while (node) {
              node.flags = node.flags & ~Placement | Hydrating;
              node = node.sibling;
            }
          }
        } else {
          resetHydrationState();
          if (nextChildren === prevChildren) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
        resetHydrationState();
        queueHydrationError(recoverableError);
        workInProgress2.flags |= ForceClientRender;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostComponent(current2, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        var type = workInProgress2.type;
        var nextProps = workInProgress2.pendingProps;
        var prevProps = current2 !== null ? current2.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress2.flags |= ContentReset;
        }
        markRef(current2, workInProgress2);
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostText(current2, workInProgress2) {
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        return null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch (resolvedTag) {
          case FunctionComponent: {
            {
              validateFunctionComponentInDev(workInProgress2, Component);
              workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
            }
            child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ClassComponent: {
            {
              workInProgress2.type = Component = resolveClassForHotReloading(Component);
            }
            child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ForwardRef: {
            {
              workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
            }
            child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case MemoComponent: {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = Component.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    resolvedProps,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            child = updateMemoComponent(
              null,
              workInProgress2,
              Component,
              resolveDefaultProps(Component.type, resolvedProps),
              // The inner type can have defaults too
              renderLanes2
            );
            return child;
          }
        }
        var hint = "";
        {
          if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
            hint = " Did you wrap a component in React.lazy() more than once?";
          }
        }
        throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        workInProgress2.tag = ClassComponent;
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        constructClassInstance(workInProgress2, Component, nextProps);
        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value;
        var hasId;
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
          }
          setIsRendering(true);
          ReactCurrentOwner$1.current = workInProgress2;
          value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          workInProgress2.tag = ClassComponent;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          var hasContext = false;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
          initializeUpdateQueue(workInProgress2);
          adoptClassInstance(workInProgress2, value);
          mountClassInstance(workInProgress2, Component, props, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        } else {
          workInProgress2.tag = FunctionComponent;
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          reconcileChildren(null, workInProgress2, value, renderLanes2);
          {
            validateFunctionComponentInDev(workInProgress2, Component);
          }
          return workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (workInProgress2.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }
            var warningKey = ownerName || "";
            var debugSource = workInProgress2._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutFunctionRefs[warningKey]) {
              didWarnAboutFunctionRefs[warningKey] = true;
              error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
            }
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2,
          cachePool: getSuspendedCache(),
          transitions: null
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        var cachePool = null;
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
          cachePool,
          transitions: prevOffscreenState.transitions
        };
      }
      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          var suspenseState = current2.memoizedState;
          if (suspenseState === null) {
            return false;
          }
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
        return removeLanes(current2.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        {
          if (shouldSuspend(workInProgress2)) {
            workInProgress2.flags |= DidCapture;
          }
        }
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
          showFallback = true;
          workInProgress2.flags &= ~DidCapture;
        } else {
          if (current2 === null || current2.memoizedState !== null) {
            {
              suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
          }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress2, suspenseContext);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null) {
            var dehydrated = suspenseState.dehydrated;
            if (dehydrated !== null) {
              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
            }
          }
          var nextPrimaryChildren = nextProps.children;
          var nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var primaryChildFragment = workInProgress2.child;
            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackFragment;
          } else {
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
          }
        } else {
          var prevState = current2.memoizedState;
          if (prevState !== null) {
            var _dehydrated = prevState.dehydrated;
            if (_dehydrated !== null) {
              return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
            }
          }
          if (showFallback) {
            var _nextFallbackChildren = nextProps.fallback;
            var _nextPrimaryChildren = nextProps.children;
            var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
            var _primaryChildFragment2 = workInProgress2.child;
            var prevOffscreenState = current2.child.memoizedState;
            _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
            _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          } else {
            var _nextPrimaryChildren2 = nextProps.children;
            var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
            workInProgress2.memoizedState = null;
            return _primaryChildFragment3;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
        primaryChildFragment.return = workInProgress2;
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var progressedPrimaryFragment = workInProgress2.child;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = 0;
            primaryChildFragment.treeBaseDuration = 0;
          }
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        } else {
          primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        }
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
      }
      function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
        return createWorkInProgress(current2, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          primaryChildFragment.lanes = renderLanes2;
        }
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
          var deletions = workInProgress2.deletions;
          if (deletions === null) {
            workInProgress2.deletions = [currentFallbackChildFragment];
            workInProgress2.flags |= ChildDeletion;
          } else {
            deletions.push(currentFallbackChildFragment);
          }
        }
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        if (
          // In legacy mode, we commit the primary tree as if it successfully
          // completed, even though it's in an inconsistent state.
          (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
          // already cloned. In legacy mode, the only case where this isn't true is
          // when DevTools forces us to display a fallback; we skip the first render
          // pass entirely and go straight to rendering the fallback. (In Concurrent
          // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
          // only codepath.)
          workInProgress2.child !== currentPrimaryChildFragment
        ) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
          }
          workInProgress2.deletions = null;
        } else {
          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
          primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
        }
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) {
          fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        } else {
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
        if (recoverableError !== null) {
          queueHydrationError(recoverableError);
        }
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        var nextProps = workInProgress2.pendingProps;
        var primaryChildren = nextProps.children;
        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
        primaryChildFragment.flags |= Placement;
        workInProgress2.memoizedState = null;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var fiberMode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
        var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
        fallbackChildFragment.flags |= Placement;
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        }
        return fallbackChildFragment;
      }
      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          {
            error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
          }
          workInProgress2.lanes = laneToLanes(SyncLane);
        } else if (isSuspenseInstanceFallback(suspenseInstance)) {
          workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
        } else {
          workInProgress2.lanes = laneToLanes(OffscreenLane);
        }
        return null;
      }
      function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
        if (!didSuspend) {
          warnIfHydrating();
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            return retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2,
              // TODO: When we delete legacy mode, we should make this error argument
              // required \u2014 every concurrent mode path that causes hydration to
              // de-opt to client rendering should have an error message.
              null
            );
          }
          if (isSuspenseInstanceFallback(suspenseInstance)) {
            var digest, message, stack;
            {
              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
              digest = _getSuspenseInstanceF.digest;
              message = _getSuspenseInstanceF.message;
              stack = _getSuspenseInstanceF.stack;
            }
            var error2;
            if (message) {
              error2 = new Error(message);
            } else {
              error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
            }
            var capturedValue = createCapturedValue(error2, digest, stack);
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
          }
          var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
          if (didReceiveUpdate || hasContextChanged2) {
            var root22 = getWorkInProgressRoot();
            if (root22 !== null) {
              var attemptHydrationAtLane = getBumpedLaneForHydration(root22, renderLanes2);
              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                suspenseState.retryLane = attemptHydrationAtLane;
                var eventTime = NoTimestamp;
                enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                scheduleUpdateOnFiber(root22, current2, attemptHydrationAtLane, eventTime);
              }
            }
            renderDidSuspendDelayIfPossible();
            var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
          } else if (isSuspenseInstancePending(suspenseInstance)) {
            workInProgress2.flags |= DidCapture;
            workInProgress2.child = current2.child;
            var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
            registerSuspenseInstanceRetry(suspenseInstance, retry);
            return null;
          } else {
            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Hydrating;
            return primaryChildFragment;
          }
        } else {
          if (workInProgress2.flags & ForceClientRender) {
            workInProgress2.flags &= ~ForceClientRender;
            var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
          } else if (workInProgress2.memoizedState !== null) {
            workInProgress2.child = current2.child;
            workInProgress2.flags |= DidCapture;
            return null;
          } else {
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var _primaryChildFragment4 = workInProgress2.child;
            _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          }
        }
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
        }
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        var node = firstChild;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            }
          } else if (node.tag === SuspenseListComponent) {
            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress2) {
            return;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === workInProgress2) {
              return;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        var row = firstChild;
        var lastContentRow = null;
        while (row !== null) {
          var currentRow = row.alternate;
          if (currentRow !== null && findFirstSuspended(currentRow) === null) {
            lastContentRow = row;
          }
          row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        {
          if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === "string") {
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                case "forward":
                case "backward": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                default:
                  error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                  break;
              }
            } else {
              error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
          }
        }
      }
      function validateTailOptions(tailMode, revealOrder) {
        {
          if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== "collapsed" && tailMode !== "hidden") {
              didWarnAboutTailOptions[tailMode] = true;
              error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
            } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
              didWarnAboutTailOptions[tailMode] = true;
              error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
            }
          }
        }
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isAnArray = isArray(childSlot);
          var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
          if (isAnArray || isIterable) {
            var type = isAnArray ? "array" : "iterable";
            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
            return false;
          }
        }
        return true;
      }
      function validateSuspenseListChildren(children, revealOrder) {
        {
          if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
            if (isArray(children)) {
              for (var i2 = 0; i2 < children.length; i2++) {
                if (!validateSuspenseListNestedChild(children[i2], i2)) {
                  return;
                }
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var childrenIterator = iteratorFn.call(children);
                if (childrenIterator) {
                  var step = childrenIterator.next();
                  var _i = 0;
                  for (; !step.done; step = childrenIterator.next()) {
                    if (!validateSuspenseListNestedChild(step.value, _i)) {
                      return;
                    }
                    _i++;
                  }
                }
              } else {
                error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
              }
            }
          }
        }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        if (renderState === null) {
          workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          };
        } else {
          renderState.isBackwards = isBackwards;
          renderState.rendering = null;
          renderState.renderingStartTime = 0;
          renderState.last = lastContentRow;
          renderState.tail = tail;
          renderState.tailMode = tailMode;
        }
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          workInProgress2.flags |= DidCapture;
        } else {
          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
          if (didSuspendBefore) {
            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress2, suspenseContext);
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          workInProgress2.memoizedState = null;
        } else {
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child);
              var tail;
              if (lastContentRow === null) {
                tail = workInProgress2.child;
                workInProgress2.child = null;
              } else {
                tail = lastContentRow.sibling;
                lastContentRow.sibling = null;
              }
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                tail,
                lastContentRow,
                tailMode
              );
              break;
            }
            case "backwards": {
              var _tail = null;
              var row = workInProgress2.child;
              workInProgress2.child = null;
              while (row !== null) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail;
                _tail = row;
                row = nextRow;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                // isBackwards
                _tail,
                null,
                // last
                tailMode
              );
              break;
            }
            case "together": {
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                null,
                // tail
                null,
                // last
                void 0
              );
              break;
            }
            default: {
              workInProgress2.memoizedState = null;
            }
          }
        }
        return workInProgress2.child;
      }
      function updatePortalComponent(current2, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        if (current2 === null) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
      function updateContextProvider(current2, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type;
        var context = providerType._context;
        var newProps = workInProgress2.pendingProps;
        var oldProps = workInProgress2.memoizedProps;
        var newValue = newProps.value;
        {
          if (!("value" in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
              hasWarnedAboutUsingNoValuePropOnContextProvider = true;
              error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
            }
          }
          var providerPropTypes = workInProgress2.type.propTypes;
          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
          }
        }
        pushProvider(workInProgress2, context, newValue);
        {
          if (oldProps !== null) {
            var oldValue = oldProps.value;
            if (objectIs(oldValue, newValue)) {
              if (oldProps.children === newProps.children && !hasContextChanged()) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            } else {
              propagateContextChange(workInProgress2, context, renderLanes2);
            }
          }
        }
        var newChildren = newProps.children;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = false;
      function updateContextConsumer(current2, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress2.pendingProps;
        var render2 = newProps.children;
        {
          if (typeof render2 !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context);
        {
          markComponentRenderStarted(workInProgress2);
        }
        var newChildren;
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          newChildren = render2(newValue);
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }
      function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          if (current2 !== null) {
            current2.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
        }
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          workInProgress2.dependencies = current2.dependencies;
        }
        {
          stopProfilerTimerIfRunning();
        }
        markSkippedUpdateLanes(workInProgress2.lanes);
        if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
          {
            return null;
          }
        }
        cloneChildFibers(current2, workInProgress2);
        return workInProgress2.child;
      }
      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null) {
            throw new Error("Cannot swap the root fiber.");
          }
          current2.alternate = null;
          oldWorkInProgress.alternate = null;
          newWorkInProgress.index = oldWorkInProgress.index;
          newWorkInProgress.sibling = oldWorkInProgress.sibling;
          newWorkInProgress.return = oldWorkInProgress.return;
          newWorkInProgress.ref = oldWorkInProgress.ref;
          if (oldWorkInProgress === returnFiber.child) {
            returnFiber.child = newWorkInProgress;
          } else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) {
              throw new Error("Expected parent to have a child.");
            }
            while (prevSibling.sibling !== oldWorkInProgress) {
              prevSibling = prevSibling.sibling;
              if (prevSibling === null) {
                throw new Error("Expected to find the previous sibling.");
              }
            }
            prevSibling.sibling = newWorkInProgress;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [current2];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(current2);
          }
          newWorkInProgress.flags |= Placement;
          return newWorkInProgress;
        }
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        var updateLanes = current2.lanes;
        if (includesSomeLane(updateLanes, renderLanes2)) {
          return true;
        }
        return false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress2);
            workInProgress2.stateNode;
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress2);
            break;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress2);
            }
            break;
          }
          case HostPortal:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case ContextProvider: {
            var newValue = workInProgress2.memoizedProps.value;
            var context = workInProgress2.type._context;
            pushProvider(workInProgress2, context, newValue);
            break;
          }
          case Profiler:
            {
              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (hasChildWork) {
                workInProgress2.flags |= Update;
              }
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            break;
          case SuspenseComponent: {
            var state = workInProgress2.memoizedState;
            if (state !== null) {
              if (state.dehydrated !== null) {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                workInProgress2.flags |= DidCapture;
                return null;
              }
              var primaryChildFragment = workInProgress2.child;
              var primaryChildLanes = primaryChildFragment.childLanes;
              if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                if (child !== null) {
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }
            break;
          }
          case SuspenseListComponent: {
            var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
            var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            if (didSuspendBefore) {
              if (_hasChildWork) {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              workInProgress2.flags |= DidCapture;
            }
            var renderState = workInProgress2.memoizedState;
            if (renderState !== null) {
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }
            pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
            if (_hasChildWork) {
              break;
            } else {
              return null;
            }
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            workInProgress2.lanes = NoLanes;
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        {
          if (workInProgress2._debugNeedsRemount && current2 !== null) {
            return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
          }
        }
        if (current2 !== null) {
          var oldProps = current2.memoizedProps;
          var newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
          workInProgress2.type !== current2.type) {
            didReceiveUpdate = true;
          } else {
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
            // may not be work scheduled on `current`, so we check for this flag.
            (workInProgress2.flags & DidCapture) === NoFlags) {
              didReceiveUpdate = false;
              return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
            }
            if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            } else {
              didReceiveUpdate = false;
            }
          }
        } else {
          didReceiveUpdate = false;
          if (getIsHydrating() && isForkedChild(workInProgress2)) {
            var slotIndex = workInProgress2.index;
            var numberOfForks = getForksAtLevel();
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        workInProgress2.lanes = NoLanes;
        switch (workInProgress2.tag) {
          case IndeterminateComponent: {
            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
          }
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
          }
          case FunctionComponent: {
            var Component = workInProgress2.type;
            var unresolvedProps = workInProgress2.pendingProps;
            var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component = workInProgress2.type;
            var _unresolvedProps = workInProgress2.pendingProps;
            var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
            return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current2, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current2, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current2, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current2, workInProgress2, renderLanes2);
          case ForwardRef: {
            var type = workInProgress2.type;
            var _unresolvedProps2 = workInProgress2.pendingProps;
            var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment:
            return updateFragment(current2, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current2, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current2, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current2, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current2, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type;
            var _unresolvedProps3 = workInProgress2.pendingProps;
            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = _type2.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    _resolvedProps3,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(_type2)
                  );
                }
              }
            }
            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
            return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
          }
          case SimpleMemoComponent: {
            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
          }
          case IncompleteClassComponent: {
            var _Component2 = workInProgress2.type;
            var _unresolvedProps4 = workInProgress2.pendingProps;
            var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
            return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent: {
            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent: {
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref;
        {
          workInProgress2.flags |= RefStatic;
        }
      }
      var appendAllChildren;
      var updateHostContainer;
      var updateHostComponent$1;
      var updateHostText$1;
      {
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
          var node = workInProgress2.child;
          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        };
        updateHostContainer = function(current2, workInProgress2) {
        };
        updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
          var oldProps = current2.memoizedProps;
          if (oldProps === newProps) {
            return;
          }
          var instance = workInProgress2.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress2.updateQueue = updatePayload;
          if (updatePayload) {
            markUpdate(workInProgress2);
          }
        };
        updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress2);
          }
        };
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) {
          return;
        }
        switch (renderState.tailMode) {
          case "hidden": {
            var tailNode = renderState.tail;
            var lastTailNode = null;
            while (tailNode !== null) {
              if (tailNode.alternate !== null) {
                lastTailNode = tailNode;
              }
              tailNode = tailNode.sibling;
            }
            if (lastTailNode === null) {
              renderState.tail = null;
            } else {
              lastTailNode.sibling = null;
            }
            break;
          }
          case "collapsed": {
            var _tailNode = renderState.tail;
            var _lastTailNode = null;
            while (_tailNode !== null) {
              if (_tailNode.alternate !== null) {
                _lastTailNode = _tailNode;
              }
              _tailNode = _tailNode.sibling;
            }
            if (_lastTailNode === null) {
              if (!hasRenderedATailFallback && renderState.tail !== null) {
                renderState.tail.sibling = null;
              } else {
                renderState.tail = null;
              }
            } else {
              _lastTailNode.sibling = null;
            }
            break;
          }
        }
      }
      function bubbleProperties(completedWork) {
        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
        var newChildLanes = NoLanes;
        var subtreeFlags = NoFlags;
        if (!didBailout) {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration;
            var child = completedWork.child;
            while (child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
              subtreeFlags |= child.subtreeFlags;
              subtreeFlags |= child.flags;
              actualDuration += child.actualDuration;
              treeBaseDuration += child.treeBaseDuration;
              child = child.sibling;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
          } else {
            var _child = completedWork.child;
            while (_child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
              subtreeFlags |= _child.subtreeFlags;
              subtreeFlags |= _child.flags;
              _child.return = completedWork;
              _child = _child.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        } else {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var _treeBaseDuration = completedWork.selfBaseDuration;
            var _child2 = completedWork.child;
            while (_child2 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
              subtreeFlags |= _child2.subtreeFlags & StaticMask;
              subtreeFlags |= _child2.flags & StaticMask;
              _treeBaseDuration += _child2.treeBaseDuration;
              _child2 = _child2.sibling;
            }
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else {
            var _child3 = completedWork.child;
            while (_child3 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
              subtreeFlags |= _child3.subtreeFlags & StaticMask;
              subtreeFlags |= _child3.flags & StaticMask;
              _child3.return = completedWork;
              _child3 = _child3.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        }
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
          warnIfUnhydratedTailNodes(workInProgress2);
          resetHydrationState();
          workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
          return false;
        }
        var wasHydrated = popHydrationState(workInProgress2);
        if (nextState !== null && nextState.dehydrated !== null) {
          if (current2 === null) {
            if (!wasHydrated) {
              throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
            }
            prepareToHydrateHostSuspenseInstance(workInProgress2);
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var isTimedOutSuspense = nextState !== null;
                if (isTimedOutSuspense) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          } else {
            resetHydrationState();
            if ((workInProgress2.flags & DidCapture) === NoFlags) {
              workInProgress2.memoizedState = null;
            }
            workInProgress2.flags |= Update;
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var _isTimedOutSuspense = nextState !== null;
                if (_isTimedOutSuspense) {
                  var _primaryChildFragment = workInProgress2.child;
                  if (_primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          }
        } else {
          upgradeHydrationErrorsToRecoverable();
          return true;
        }
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef:
          case Fragment:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            bubbleProperties(workInProgress2);
            return null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostRoot: {
            var fiberRoot = workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current2 === null || current2.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              if (wasHydrated) {
                markUpdate(workInProgress2);
              } else {
                if (current2 !== null) {
                  var prevState = current2.memoizedState;
                  if (
                    // Check if this is a client root
                    !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                    (workInProgress2.flags & ForceClientRender) !== NoFlags
                  ) {
                    workInProgress2.flags |= Snapshot;
                    upgradeHydrationErrorsToRecoverable();
                  }
                }
              }
            }
            updateHostContainer(current2, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null) {
              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
              if (current2.ref !== workInProgress2.ref) {
                markRef$1(workInProgress2);
              }
            } else {
              if (!newProps) {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              var currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated) {
                if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress2);
                }
              } else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance, workInProgress2, false, false);
                workInProgress2.stateNode = instance;
                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress2);
                }
              }
              if (workInProgress2.ref !== null) {
                markRef$1(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostText: {
            var newText = newProps;
            if (current2 && workInProgress2.stateNode != null) {
              var oldText = current2.memoizedProps;
              updateHostText$1(current2, workInProgress2, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated2 = popHydrationState(workInProgress2);
              if (_wasHydrated2) {
                if (prepareToHydrateHostTextInstance(workInProgress2)) {
                  markUpdate(workInProgress2);
                }
              } else {
                workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
              if (!fallthroughToNormalSuspensePath) {
                if (workInProgress2.flags & ShouldCapture) {
                  return workInProgress2;
                } else {
                  return null;
                }
              }
            }
            if ((workInProgress2.flags & DidCapture) !== NoFlags) {
              workInProgress2.lanes = renderLanes2;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            var nextDidTimeout = nextState !== null;
            var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
            if (nextDidTimeout !== prevDidTimeout) {
              if (nextDidTimeout) {
                var _offscreenFiber2 = workInProgress2.child;
                _offscreenFiber2.flags |= Visibility;
                if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                  var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || true);
                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                    renderDidSuspend();
                  } else {
                    renderDidSuspendDelayIfPossible();
                  }
                }
              }
            }
            var wakeables = workInProgress2.updateQueue;
            if (wakeables !== null) {
              workInProgress2.flags |= Update;
            }
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                if (nextDidTimeout) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            updateHostContainer(current2, workInProgress2);
            if (current2 === null) {
              preparePortalMount(workInProgress2.stateNode.containerInfo);
            }
            bubbleProperties(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            if (isContextProvider(_Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              bubbleProperties(workInProgress2);
              return null;
            }
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
            var renderedTail = renderState.rendering;
            if (renderedTail === null) {
              if (!didSuspendAlready) {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended) {
                  var row = workInProgress2.child;
                  while (row !== null) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = true;
                      workInProgress2.flags |= DidCapture;
                      cutOffTailIfNeeded(renderState, false);
                      var newThenables = suspended.updateQueue;
                      if (newThenables !== null) {
                        workInProgress2.updateQueue = newThenables;
                        workInProgress2.flags |= Update;
                      }
                      workInProgress2.subtreeFlags = NoFlags;
                      resetChildFibers(workInProgress2, renderLanes2);
                      pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                      return workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                }
                if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              } else {
                cutOffTailIfNeeded(renderState, false);
              }
            } else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  var _newThenables = _suspended.updateQueue;
                  if (_newThenables !== null) {
                    workInProgress2.updateQueue = _newThenables;
                    workInProgress2.flags |= Update;
                  }
                  cutOffTailIfNeeded(renderState, true);
                  if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                } else if (
                  // The time it took to render last row is greater than the remaining
                  // time we have to render. So rendering one more row would likely
                  // exceed it.
                  now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                ) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              }
              if (renderState.isBackwards) {
                renderedTail.sibling = workInProgress2.child;
                workInProgress2.child = renderedTail;
              } else {
                var previousSibling = renderState.last;
                if (previousSibling !== null) {
                  previousSibling.sibling = renderedTail;
                } else {
                  workInProgress2.child = renderedTail;
                }
                renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next2 = renderState.tail;
              renderState.rendering = next2;
              renderState.tail = next2.sibling;
              renderState.renderingStartTime = now2();
              next2.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              if (didSuspendAlready) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              } else {
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
              }
              pushSuspenseContext(workInProgress2, suspenseContext);
              return next2;
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            popRenderLanes(workInProgress2);
            var _nextState = workInProgress2.memoizedState;
            var nextIsHidden = _nextState !== null;
            if (current2 !== null) {
              var _prevState = current2.memoizedState;
              var prevIsHidden = _prevState !== null;
              if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding \u2014 it only pre-renders.
              !enableLegacyHidden) {
                workInProgress2.flags |= Visibility;
              }
            }
            if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
              bubbleProperties(workInProgress2);
            } else {
              if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                bubbleProperties(workInProgress2);
                {
                  if (workInProgress2.subtreeFlags & (Placement | Update)) {
                    workInProgress2.flags |= Visibility;
                  }
                }
              }
            }
            return null;
          }
          case CacheComponent: {
            return null;
          }
          case TracingMarkerComponent: {
            return null;
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function unwindWork(current2, workInProgress2, renderLanes2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            var flags = workInProgress2.flags;
            if (flags & ShouldCapture) {
              workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case HostRoot: {
            workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
              workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
              return workInProgress2;
            }
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (workInProgress2.alternate === null) {
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              }
              resetHydrationState();
            }
            var _flags2 = workInProgress2.flags;
            if (_flags2 & ShouldCapture) {
              workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            return null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(workInProgress2);
            return null;
          case CacheComponent:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              popContext(interruptedWork);
            }
            break;
          }
          case HostRoot: {
            interruptedWork.stateNode;
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            var context = interruptedWork.type._context;
            popProvider(context, interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var nextEffect = null;
      var inProgressLanes = null;
      var inProgressRoot = null;
      function reportUncaughtErrorInDEV(error2) {
        {
          invokeGuardedCallback(null, function() {
            throw error2;
          });
          clearCaughtError();
        }
      }
      var callComponentWillUnmountWithTimer = function(current2, instance) {
        instance.props = current2.memoizedProps;
        instance.state = current2.memoizedState;
        if (current2.mode & ProfileMode) {
          try {
            startLayoutEffectTimer();
            instance.componentWillUnmount();
          } finally {
            recordLayoutEffectDuration(current2);
          }
        } else {
          instance.componentWillUnmount();
        }
      };
      function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
        try {
          commitHookEffectListMount(Layout, current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        try {
          callComponentWillUnmountWithTimer(current2, instance);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentDidMount();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          commitAttachRef(current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref = current2.ref;
        if (ref !== null) {
          if (typeof ref === "function") {
            var retVal;
            try {
              if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(null);
                } finally {
                  recordLayoutEffectDuration(current2);
                }
              } else {
                retVal = ref(null);
              }
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
              }
            }
          } else {
            ref.current = null;
          }
        }
      }
      function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      var shouldFireAfterActiveInstanceBlur = false;
      function commitBeforeMutationEffects(root22, firstChild) {
        prepareForCommit(root22.containerInfo);
        nextEffect = firstChild;
        commitBeforeMutationEffects_begin();
        var shouldFire = shouldFireAfterActiveInstanceBlur;
        shouldFireAfterActiveInstanceBlur = false;
        return shouldFire;
      }
      function commitBeforeMutationEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitBeforeMutationEffects_complete();
          }
        }
      }
      function commitBeforeMutationEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            commitBeforeMutationEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitBeforeMutationEffectsOnFiber(finishedWork) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        if ((flags & Snapshot) !== NoFlags) {
          setCurrentFiber(finishedWork);
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              break;
            }
            case ClassComponent: {
              if (current2 !== null) {
                var prevProps = current2.memoizedProps;
                var prevState = current2.memoizedState;
                var instance = finishedWork.stateNode;
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }
              break;
            }
            case HostRoot: {
              {
                var root22 = finishedWork.stateNode;
                clearContainer(root22.containerInfo);
              }
              break;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              break;
            default: {
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          resetCurrentFiber();
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              var destroy = effect.destroy;
              effect.destroy = void 0;
              if (destroy !== void 0) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStarted(finishedWork);
                  }
                }
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStopped();
                  }
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStarted(finishedWork);
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStarted(finishedWork);
                }
              }
              var create = effect.create;
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(true);
                }
              }
              effect.destroy = create();
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(false);
                }
              }
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStopped();
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStopped();
                }
              }
              {
                var destroy = effect.destroy;
                if (destroy !== void 0 && typeof destroy !== "function") {
                  var hookName = void 0;
                  if ((effect.tag & Layout) !== NoFlags) {
                    hookName = "useLayoutEffect";
                  } else if ((effect.tag & Insertion) !== NoFlags) {
                    hookName = "useInsertionEffect";
                  } else {
                    hookName = "useEffect";
                  }
                  var addendum = void 0;
                  if (destroy === null) {
                    addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                  } else if (typeof destroy.then === "function") {
                    addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                  } else {
                    addendum = " You returned: " + destroy;
                  }
                  error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitPassiveEffectDurations(finishedRoot, finishedWork) {
        {
          if ((finishedWork.flags & Update) !== NoFlags) {
            switch (finishedWork.tag) {
              case Profiler: {
                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                var commitTime2 = getCommitTime();
                var phase = finishedWork.alternate === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onPostCommit === "function") {
                  onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                }
                var parentFiber = finishedWork.return;
                outer: while (parentFiber !== null) {
                  switch (parentFiber.tag) {
                    case HostRoot:
                      var root22 = parentFiber.stateNode;
                      root22.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                    case Profiler:
                      var parentStateNode = parentFiber.stateNode;
                      parentStateNode.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                  }
                  parentFiber = parentFiber.return;
                }
                break;
              }
            }
          }
        }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
        if ((finishedWork.flags & LayoutMask) !== NoFlags) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Layout | HasEffect, finishedWork);
                }
              }
              break;
            }
            case ClassComponent: {
              var instance = finishedWork.stateNode;
              if (finishedWork.flags & Update) {
                if (!offscreenSubtreeWasHidden) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidMount();
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
              }
              var updateQueue = finishedWork.updateQueue;
              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance);
              }
              break;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              break;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current2 === null && finishedWork.flags & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props);
              }
              break;
            }
            case HostText: {
              break;
            }
            case HostPortal: {
              break;
            }
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime2 = getCommitTime();
                var phase = current2 === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onRender === "function") {
                  onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                }
                {
                  if (typeof onCommit === "function") {
                    onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                  }
                  enqueuePendingPassiveProfilerEffect(finishedWork);
                  var parentFiber = finishedWork.return;
                  outer: while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root22 = parentFiber.stateNode;
                        root22.effectDuration += effectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.effectDuration += effectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                }
              }
              break;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
            case TracingMarkerComponent: {
              break;
            }
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (!offscreenSubtreeWasHidden) {
          {
            if (finishedWork.flags & Ref) {
              commitAttachRef(finishedWork);
            }
          }
        }
      }
      function reappearLayoutEffectsOnFiber(node) {
        switch (node.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (node.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              } finally {
                recordLayoutEffectDuration(node);
              }
            } else {
              safelyCallCommitHookLayoutEffectListMount(node, node.return);
            }
            break;
          }
          case ClassComponent: {
            var instance = node.stateNode;
            if (typeof instance.componentDidMount === "function") {
              safelyCallComponentDidMount(node, node.return, instance);
            }
            safelyAttachRef(node, node.return);
            break;
          }
          case HostComponent: {
            safelyAttachRef(node, node.return);
            break;
          }
        }
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        var hostSubtreeRoot = null;
        {
          var node = finishedWork;
          while (true) {
            if (node.tag === HostComponent) {
              if (hostSubtreeRoot === null) {
                hostSubtreeRoot = node;
                try {
                  var instance = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if (node.tag === HostText) {
              if (hostSubtreeRoot === null) {
                try {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === finishedWork) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node = node.return;
            }
            if (hostSubtreeRoot === node) {
              hostSubtreeRoot = null;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;
            default:
              instanceToUse = instance;
          }
          if (typeof ref === "function") {
            var retVal;
            if (finishedWork.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                retVal = ref(instanceToUse);
              } finally {
                recordLayoutEffectDuration(finishedWork);
              }
            } else {
              retVal = ref(instanceToUse);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
              }
            }
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }
      function detachFiberMutation(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.return = null;
        }
        fiber.return = null;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          fiber.alternate = null;
          detachFiberAfterEffects(alternate);
        }
        {
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          if (fiber.tag === HostComponent) {
            var hostInstance = fiber.stateNode;
            if (hostInstance !== null) {
              detachDeletedInstance(hostInstance);
            }
          }
          fiber.stateNode = null;
          {
            fiber._debugOwner = null;
          }
          {
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
          }
        }
      }
      function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }
          parent = parent.return;
        }
        throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node = fiber;
        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
            if (node.flags & Placement) {
              continue siblings;
            }
            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }
          if (!(node.flags & Placement)) {
            return node.stateNode;
          }
        }
      }
      function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork);
        switch (parentFiber.tag) {
          case HostComponent: {
            var parent = parentFiber.stateNode;
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          }
          case HostRoot:
          case HostPortal: {
            var _parent = parentFiber.stateNode.containerInfo;
            var _before = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertInContainerBefore(parent, stateNode, before);
          } else {
            appendChildToContainer(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertBefore(parent, stateNode, before);
          } else {
            appendChild(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNode(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function commitDeletionEffects(root22, returnFiber, deletedFiber) {
        {
          var parent = returnFiber;
          findParent: while (parent !== null) {
            switch (parent.tag) {
              case HostComponent: {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break findParent;
              }
              case HostRoot: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
              case HostPortal: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
            }
            parent = parent.return;
          }
          if (hostParent === null) {
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          commitDeletionEffectsOnFiber(root22, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
        }
        detachFiberMutation(deletedFiber);
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        var child = parent.child;
        while (child !== null) {
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
          child = child.sibling;
        }
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        onCommitUnmount(deletedFiber);
        switch (deletedFiber.tag) {
          case HostComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
            }
          }
          case HostText: {
            {
              var prevHostParent = hostParent;
              var prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  removeChildFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  removeChild(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case DehydratedFragment: {
            {
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case HostPortal: {
            {
              var _prevHostParent = hostParent;
              var _prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = _prevHostParent;
              hostParentIsContainer = _prevHostParentIsContainer;
            }
            return;
          }
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden) {
              var updateQueue = deletedFiber.updateQueue;
              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;
                  do {
                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                    if (destroy !== void 0) {
                      if ((tag & Insertion) !== NoFlags$1) {
                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                      } else if ((tag & Layout) !== NoFlags$1) {
                        {
                          markComponentLayoutEffectUnmountStarted(deletedFiber);
                        }
                        if (deletedFiber.mode & ProfileMode) {
                          startLayoutEffectTimer();
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          recordLayoutEffectDuration(deletedFiber);
                        } else {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        }
                        {
                          markComponentLayoutEffectUnmountStopped();
                        }
                      }
                    }
                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ClassComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var instance = deletedFiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ScopeComponent: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case OffscreenComponent: {
            if (
              // TODO: Remove this dead flag
              deletedFiber.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            }
            break;
          }
          default: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
        }
      }
      function commitSuspenseCallback(finishedWork) {
        finishedWork.memoizedState;
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
          var current2 = finishedWork.alternate;
          if (current2 !== null) {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var suspenseInstance = prevState.dehydrated;
              if (suspenseInstance !== null) {
                commitHydratedSuspenseInstance(suspenseInstance);
              }
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          if (retryCache === null) {
            retryCache = finishedWork.stateNode = new PossiblyWeakSet();
          }
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              {
                if (isDevToolsPresent) {
                  if (inProgressLanes !== null && inProgressRoot !== null) {
                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                  } else {
                    throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                  }
                }
              }
              wakeable.then(retry, retry);
            }
          });
        }
      }
      function commitMutationEffects(root22, finishedWork, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root22;
        setCurrentFiber(finishedWork);
        commitMutationEffectsOnFiber(finishedWork, root22);
        setCurrentFiber(finishedWork);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function recursivelyTraverseMutationEffects(root22, parentFiber, lanes) {
        var deletions = parentFiber.deletions;
        if (deletions !== null) {
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            try {
              commitDeletionEffects(root22, parentFiber, childToDelete);
            } catch (error2) {
              captureCommitPhaseError(childToDelete, parentFiber, error2);
            }
          }
        }
        var prevDebugFiber = getCurrentFiber();
        if (parentFiber.subtreeFlags & MutationMask) {
          var child = parentFiber.child;
          while (child !== null) {
            setCurrentFiber(child);
            commitMutationEffectsOnFiber(child, root22);
            child = child.sibling;
          }
        }
        setCurrentFiber(prevDebugFiber);
      }
      function commitMutationEffectsOnFiber(finishedWork, root22, lanes) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              try {
                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                recordLayoutEffectDuration(finishedWork);
              } else {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case ClassComponent: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            return;
          }
          case HostComponent: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            {
              if (finishedWork.flags & ContentReset) {
                var instance = finishedWork.stateNode;
                try {
                  resetTextContent(instance);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              if (flags & Update) {
                var _instance4 = finishedWork.stateNode;
                if (_instance4 != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    try {
                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostText: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (finishedWork.stateNode === null) {
                  throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                try {
                  commitTextUpdate(textInstance, oldText, newText);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case HostRoot: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (current2 !== null) {
                  var prevRootState = current2.memoizedState;
                  if (prevRootState.isDehydrated) {
                    try {
                      commitHydratedContainer(root22.containerInfo);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostPortal: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
          case SuspenseComponent: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            var offscreenFiber = finishedWork.child;
            if (offscreenFiber.flags & Visibility) {
              var offscreenInstance = offscreenFiber.stateNode;
              var newState = offscreenFiber.memoizedState;
              var isHidden = newState !== null;
              offscreenInstance.isHidden = isHidden;
              if (isHidden) {
                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                if (!wasHidden) {
                  markCommitTimeOfFallback();
                }
              }
            }
            if (flags & Update) {
              try {
                commitSuspenseCallback(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case OffscreenComponent: {
            var _wasHidden = current2 !== null && current2.memoizedState !== null;
            if (
              // TODO: Remove this dead flag
              finishedWork.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
              recursivelyTraverseMutationEffects(root22, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseMutationEffects(root22, finishedWork);
            }
            commitReconciliationEffects(finishedWork);
            if (flags & Visibility) {
              var _offscreenInstance = finishedWork.stateNode;
              var _newState = finishedWork.memoizedState;
              var _isHidden = _newState !== null;
              var offscreenBoundary = finishedWork;
              _offscreenInstance.isHidden = _isHidden;
              {
                if (_isHidden) {
                  if (!_wasHidden) {
                    if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                      nextEffect = offscreenBoundary;
                      var offscreenChild = offscreenBoundary.child;
                      while (offscreenChild !== null) {
                        nextEffect = offscreenChild;
                        disappearLayoutEffects_begin(offscreenChild);
                        offscreenChild = offscreenChild.sibling;
                      }
                    }
                  }
                }
              }
              {
                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
              }
            }
            return;
          }
          case SuspenseListComponent: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case ScopeComponent: {
            return;
          }
          default: {
            recursivelyTraverseMutationEffects(root22, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & Placement) {
          try {
            commitPlacement(finishedWork);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= ~Placement;
        }
        if (flags & Hydrating) {
          finishedWork.flags &= ~Hydrating;
        }
      }
      function commitLayoutEffects(finishedWork, root22, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root22;
        nextEffect = finishedWork;
        commitLayoutEffects_begin(finishedWork, root22, committedLanes);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function commitLayoutEffects_begin(subtreeRoot, root22, committedLanes) {
        var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent && isModernRoot) {
            var isHidden = fiber.memoizedState !== null;
            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
            if (newOffscreenSubtreeIsHidden) {
              commitLayoutMountEffects_complete(subtreeRoot, root22, committedLanes);
              continue;
            } else {
              var current2 = fiber.alternate;
              var wasHidden = current2 !== null && current2.memoizedState !== null;
              var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
              var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
              if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                nextEffect = fiber;
                reappearLayoutEffects_begin(fiber);
              }
              var child = firstChild;
              while (child !== null) {
                nextEffect = child;
                commitLayoutEffects_begin(
                  child,
                  // New root; bubble back up to here and stop.
                  root22,
                  committedLanes
                );
                child = child.sibling;
              }
              nextEffect = fiber;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              commitLayoutMountEffects_complete(subtreeRoot, root22, committedLanes);
              continue;
            }
          }
          if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitLayoutMountEffects_complete(subtreeRoot, root22, committedLanes);
          }
        }
      }
      function commitLayoutMountEffects_complete(subtreeRoot, root22, committedLanes) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & LayoutMask) !== NoFlags) {
            var current2 = fiber.alternate;
            setCurrentFiber(fiber);
            try {
              commitLayoutEffectOnFiber(root22, current2, fiber, committedLanes);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function disappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (fiber.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                } finally {
                  recordLayoutEffectDuration(fiber);
                }
              } else {
                commitHookEffectListUnmount(Layout, fiber, fiber.return);
              }
              break;
            }
            case ClassComponent: {
              safelyDetachRef(fiber, fiber.return);
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
            case HostComponent: {
              safelyDetachRef(fiber, fiber.return);
              break;
            }
            case OffscreenComponent: {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                disappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
              break;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            disappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function disappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function reappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent) {
            var isHidden = fiber.memoizedState !== null;
            if (isHidden) {
              reappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            reappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function reappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            reappearLayoutEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountEffects(root22, finishedWork, committedLanes, committedTransitions) {
        nextEffect = finishedWork;
        commitPassiveMountEffects_begin(finishedWork, root22, committedLanes, committedTransitions);
      }
      function commitPassiveMountEffects_begin(subtreeRoot, root22, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitPassiveMountEffects_complete(subtreeRoot, root22, committedLanes, committedTransitions);
          }
        }
      }
      function commitPassiveMountEffects_complete(subtreeRoot, root22, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            try {
              commitPassiveMountOnFiber(root22, fiber, committedLanes, committedTransitions);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              } finally {
                recordPassiveEffectDuration(finishedWork);
              }
            } else {
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffects(firstChild) {
        nextEffect = firstChild;
        commitPassiveUnmountEffects_begin();
      }
      function commitPassiveUnmountEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
            var deletions = fiber.deletions;
            if (deletions !== null) {
              for (var i2 = 0; i2 < deletions.length; i2++) {
                var fiberToDelete = deletions[i2];
                nextEffect = fiberToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
              }
              {
                var previousFiber = fiber.alternate;
                if (previousFiber !== null) {
                  var detachedChild = previousFiber.child;
                  if (detachedChild !== null) {
                    previousFiber.child = null;
                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (detachedChild !== null);
                  }
                }
              }
              nextEffect = fiber;
            }
          }
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffects_complete();
          }
        }
      }
      function commitPassiveUnmountEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            commitPassiveUnmountOnFiber(fiber);
            resetCurrentFiber();
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              recordPassiveEffectDuration(finishedWork);
            } else {
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
          resetCurrentFiber();
          var child = fiber.child;
          if (child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var sibling = fiber.sibling;
          var returnFiber = fiber.return;
          {
            detachFiberAfterEffects(fiber);
            if (fiber === deletedSubtreeRoot) {
              nextEffect = null;
              return;
            }
          }
          if (sibling !== null) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            return;
          }
          nextEffect = returnFiber;
        }
      }
      function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
        switch (current2.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (current2.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              recordPassiveEffectDuration(current2);
            } else {
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
            }
            break;
          }
        }
      }
      function invokeLayoutEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Layout | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              try {
                instance.componentDidMount();
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokeLayoutEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
            }
          }
        }
      }
      if (typeof Symbol === "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        symbolFor("selector.component");
        symbolFor("selector.has_pseudo_class");
        symbolFor("selector.role");
        symbolFor("selector.test_id");
        symbolFor("selector.text");
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
      }
      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
      function isLegacyActEnvironment(fiber) {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          var jestIsDefined = typeof jest !== "undefined";
          return jestIsDefined && isReactActEnvironmentGlobal !== false;
        }
      }
      function isConcurrentActEnvironment() {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
            error("The current testing environment is not configured to support act(...)");
          }
          return isReactActEnvironmentGlobal;
        }
      }
      var ceil = Math.ceil;
      var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
      var NoContext = (
        /*             */
        0
      );
      var BatchedContext = (
        /*               */
        1
      );
      var RenderContext = (
        /*                */
        2
      );
      var CommitContext = (
        /*                */
        4
      );
      var RootInProgress = 0;
      var RootFatalErrored = 1;
      var RootErrored = 2;
      var RootSuspended = 3;
      var RootSuspendedWithDelay = 4;
      var RootCompleted = 5;
      var RootDidNotComplete = 6;
      var executionContext = NoContext;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = NoLanes;
      var subtreeRenderLanes = NoLanes;
      var subtreeRenderLanesCursor = createCursor(NoLanes);
      var workInProgressRootExitStatus = RootInProgress;
      var workInProgressRootFatalError = null;
      var workInProgressRootSkippedLanes = NoLanes;
      var workInProgressRootInterleavedUpdatedLanes = NoLanes;
      var workInProgressRootPingedLanes = NoLanes;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var globalMostRecentFallbackTime = 0;
      var FALLBACK_THROTTLE_MS = 500;
      var workInProgressRootRenderTargetTime = Infinity;
      var RENDER_TIMEOUT_MS = 500;
      var workInProgressTransitions = null;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var hasUncaughtError = false;
      var firstUncaughtError = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var rootDoesHavePassiveEffects = false;
      var rootWithPendingPassiveEffects = null;
      var pendingPassiveEffectsLanes = NoLanes;
      var pendingPassiveProfilerEffects = [];
      var pendingPassiveTransitions = null;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      var isFlushingPassiveEffects = false;
      var didScheduleUpdateDuringPassiveEffects = false;
      var NESTED_PASSIVE_UPDATE_LIMIT = 50;
      var nestedPassiveUpdateCount = 0;
      var rootWithPassiveNestedUpdates = null;
      var currentEventTime = NoTimestamp;
      var currentEventTransitionLane = NoLanes;
      var isRunningInsertionEffect = false;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          return now2();
        }
        if (currentEventTime !== NoTimestamp) {
          return currentEventTime;
        }
        currentEventTime = now2();
        return currentEventTime;
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
          return pickArbitraryLane(workInProgressRootRenderLanes);
        }
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
          if (ReactCurrentBatchConfig$3.transition !== null) {
            var transition = ReactCurrentBatchConfig$3.transition;
            if (!transition._updatedFibers) {
              transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            transition._updatedFibers.add(fiber);
          }
          if (currentEventTransitionLane === NoLane) {
            currentEventTransitionLane = claimNextTransitionLane();
          }
          return currentEventTransitionLane;
        }
        var updateLane = getCurrentUpdatePriority();
        if (updateLane !== NoLane) {
          return updateLane;
        }
        var eventLane = getCurrentEventPriority();
        return eventLane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        }
        return claimNextRetryLane();
      }
      function scheduleUpdateOnFiber(root22, fiber, lane, eventTime) {
        checkForNestedUpdates();
        {
          if (isRunningInsertionEffect) {
            error("useInsertionEffect must not schedule updates.");
          }
        }
        {
          if (isFlushingPassiveEffects) {
            didScheduleUpdateDuringPassiveEffects = true;
          }
        }
        markRootUpdated(root22, lane, eventTime);
        if ((executionContext & RenderContext) !== NoLanes && root22 === workInProgressRoot) {
          warnAboutRenderPhaseUpdatesInDEV(fiber);
        } else {
          {
            if (isDevToolsPresent) {
              addFiberToLanesMap(root22, fiber, lane);
            }
          }
          warnIfUpdatesNotWrappedWithActDEV(fiber);
          if (root22 === workInProgressRoot) {
            if ((executionContext & RenderContext) === NoContext) {
              workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
            }
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
              markRootSuspended$1(root22, workInProgressRootRenderLanes);
            }
          }
          ensureRootIsScheduled(root22, eventTime);
          if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function scheduleInitialHydrationOnRoot(root22, lane, eventTime) {
        var current2 = root22.current;
        current2.lanes = lane;
        markRootUpdated(root22, lane, eventTime);
        ensureRootIsScheduled(root22, eventTime);
      }
      function isUnsafeClassRenderPhaseUpdate(fiber) {
        return (
          // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
          // decided not to enable it.
          (executionContext & RenderContext) !== NoContext
        );
      }
      function ensureRootIsScheduled(root22, currentTime) {
        var existingCallbackNode = root22.callbackNode;
        markStarvedLanesAsExpired(root22, currentTime);
        var nextLanes = getNextLanes(root22, root22 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (nextLanes === NoLanes) {
          if (existingCallbackNode !== null) {
            cancelCallback$1(existingCallbackNode);
          }
          root22.callbackNode = null;
          root22.callbackPriority = NoLane;
          return;
        }
        var newCallbackPriority = getHighestPriorityLane(nextLanes);
        var existingCallbackPriority = root22.callbackPriority;
        if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
        // Scheduler task, rather than an `act` task, cancel it and re-scheduled
        // on the `act` queue.
        !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
          {
            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
              error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return;
        }
        if (existingCallbackNode != null) {
          cancelCallback$1(existingCallbackNode);
        }
        var newCallbackNode;
        if (newCallbackPriority === SyncLane) {
          if (root22.tag === LegacyRoot) {
            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
              ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
            }
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root22));
          } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root22));
          }
          {
            if (ReactCurrentActQueue$1.current !== null) {
              ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
            } else {
              scheduleMicrotask(function() {
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                  flushSyncCallbacks();
                }
              });
            }
          }
          newCallbackNode = null;
        } else {
          var schedulerPriorityLevel;
          switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
              schedulerPriorityLevel = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriorityLevel = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriorityLevel = NormalPriority;
              break;
            case IdleEventPriority:
              schedulerPriorityLevel = IdlePriority;
              break;
            default:
              schedulerPriorityLevel = NormalPriority;
              break;
          }
          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root22));
        }
        root22.callbackPriority = newCallbackPriority;
        root22.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root22, didTimeout) {
        {
          resetNestedUpdateFlag();
        }
        currentEventTime = NoTimestamp;
        currentEventTransitionLane = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var originalCallbackNode = root22.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
          if (root22.callbackNode !== originalCallbackNode) {
            return null;
          }
        }
        var lanes = getNextLanes(root22, root22 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) {
          return null;
        }
        var shouldTimeSlice = !includesBlockingLane(root22, lanes) && !includesExpiredLane(root22, lanes) && !didTimeout;
        var exitStatus = shouldTimeSlice ? renderRootConcurrent(root22, lanes) : renderRootSync(root22, lanes);
        if (exitStatus !== RootInProgress) {
          if (exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root22);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root22, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root22, NoLanes);
            markRootSuspended$1(root22, lanes);
            ensureRootIsScheduled(root22, now2());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            markRootSuspended$1(root22, lanes);
          } else {
            var renderWasConcurrent = !includesBlockingLane(root22, lanes);
            var finishedWork = root22.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
              exitStatus = renderRootSync(root22, lanes);
              if (exitStatus === RootErrored) {
                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root22);
                if (_errorRetryLanes !== NoLanes) {
                  lanes = _errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root22, _errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var _fatalError = workInProgressRootFatalError;
                prepareFreshStack(root22, NoLanes);
                markRootSuspended$1(root22, lanes);
                ensureRootIsScheduled(root22, now2());
                throw _fatalError;
              }
            }
            root22.finishedWork = finishedWork;
            root22.finishedLanes = lanes;
            finishConcurrentRender(root22, exitStatus, lanes);
          }
        }
        ensureRootIsScheduled(root22, now2());
        if (root22.callbackNode === originalCallbackNode) {
          return performConcurrentWorkOnRoot.bind(null, root22);
        }
        return null;
      }
      function recoverFromConcurrentError(root22, errorRetryLanes) {
        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
        if (isRootDehydrated(root22)) {
          var rootWorkInProgress = prepareFreshStack(root22, errorRetryLanes);
          rootWorkInProgress.flags |= ForceClientRender;
          {
            errorHydratingContainer(root22.containerInfo);
          }
        }
        var exitStatus = renderRootSync(root22, errorRetryLanes);
        if (exitStatus !== RootErrored) {
          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
          workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
          if (errorsFromSecondAttempt !== null) {
            queueRecoverableErrors(errorsFromSecondAttempt);
          }
        }
        return exitStatus;
      }
      function queueRecoverableErrors(errors) {
        if (workInProgressRootRecoverableErrors === null) {
          workInProgressRootRecoverableErrors = errors;
        } else {
          workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
        }
      }
      function finishConcurrentRender(root22, exitStatus, lanes) {
        switch (exitStatus) {
          case RootInProgress:
          case RootFatalErrored: {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          case RootErrored: {
            commitRoot(root22, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspended: {
            markRootSuspended$1(root22, lanes);
            if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
            !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root22, NoLanes);
                if (nextLanes !== NoLanes) {
                  break;
                }
                var suspendedLanes = root22.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  requestEventTime();
                  markRootPinged(root22, suspendedLanes);
                  break;
                }
                root22.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root22, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                break;
              }
            }
            commitRoot(root22, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspendedWithDelay: {
            markRootSuspended$1(root22, lanes);
            if (includesOnlyTransitions(lanes)) {
              break;
            }
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root22, lanes);
              var eventTimeMs = mostRecentEventTime;
              var timeElapsedMs = now2() - eventTimeMs;
              var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root22.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root22, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root22, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootCompleted: {
            commitRoot(root22, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          default: {
            throw new Error("Unknown root exit status.");
          }
        }
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        var node = finishedWork;
        while (true) {
          if (node.flags & StoreConsistency) {
            var updateQueue = node.updateQueue;
            if (updateQueue !== null) {
              var checks = updateQueue.stores;
              if (checks !== null) {
                for (var i2 = 0; i2 < checks.length; i2++) {
                  var check = checks[i2];
                  var getSnapshot = check.getSnapshot;
                  var renderedValue = check.value;
                  try {
                    if (!objectIs(getSnapshot(), renderedValue)) {
                      return false;
                    }
                  } catch (error2) {
                    return false;
                  }
                }
              }
            }
          }
          var child = node.child;
          if (node.subtreeFlags & StoreConsistency && child !== null) {
            child.return = node;
            node = child;
            continue;
          }
          if (node === finishedWork) {
            return true;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return true;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return true;
      }
      function markRootSuspended$1(root22, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
        markRootSuspended(root22, suspendedLanes);
      }
      function performSyncWorkOnRoot(root22) {
        {
          syncNestedUpdateFlag();
        }
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        flushPassiveEffects();
        var lanes = getNextLanes(root22, NoLanes);
        if (!includesSomeLane(lanes, SyncLane)) {
          ensureRootIsScheduled(root22, now2());
          return null;
        }
        var exitStatus = renderRootSync(root22, lanes);
        if (root22.tag !== LegacyRoot && exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root22);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root22, errorRetryLanes);
          }
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          prepareFreshStack(root22, NoLanes);
          markRootSuspended$1(root22, lanes);
          ensureRootIsScheduled(root22, now2());
          throw fatalError;
        }
        if (exitStatus === RootDidNotComplete) {
          throw new Error("Root did not complete. This is a bug in React.");
        }
        var finishedWork = root22.current.alternate;
        root22.finishedWork = finishedWork;
        root22.finishedLanes = lanes;
        commitRoot(root22, workInProgressRootRecoverableErrors, workInProgressTransitions);
        ensureRootIsScheduled(root22, now2());
        return null;
      }
      function flushRoot(root22, lanes) {
        if (lanes !== NoLanes) {
          markRootEntangled(root22, mergeLanes(lanes, SyncLane));
          ensureRootIsScheduled(root22, now2());
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            resetRenderTimer();
            flushSyncCallbacks();
          }
        }
      }
      function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext;
          if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function discreteUpdates(fn, a, b, c, d) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          return fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          if (executionContext === NoContext) {
            resetRenderTimer();
          }
        }
      }
      function flushSync(fn) {
        if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
          flushPassiveEffects();
        }
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        var previousPriority = getCurrentUpdatePriority();
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          if (fn) {
            return fn();
          } else {
            return void 0;
          }
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          executionContext = prevExecutionContext;
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushSyncCallbacks();
          }
        }
      }
      function isAlreadyRendering() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root22, lanes) {
        root22.finishedWork = null;
        root22.finishedLanes = NoLanes;
        var timeoutHandle = root22.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
          root22.timeoutHandle = noTimeout;
          cancelTimeout(timeoutHandle);
        }
        if (workInProgress !== null) {
          var interruptedWork = workInProgress.return;
          while (interruptedWork !== null) {
            var current2 = interruptedWork.alternate;
            unwindInterruptedWork(current2, interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }
        workInProgressRoot = root22;
        var rootWorkInProgress = createWorkInProgress(root22.current, null);
        workInProgress = rootWorkInProgress;
        workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootInterleavedUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        workInProgressRootConcurrentErrors = null;
        workInProgressRootRecoverableErrors = null;
        finishQueueingConcurrentUpdates();
        {
          ReactStrictModeWarnings.discardPendingWarnings();
        }
        return rootWorkInProgress;
      }
      function handleError(root22, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            resetContextDependencies();
            resetHooksAfterThrow();
            resetCurrentFiber();
            ReactCurrentOwner$2.current = null;
            if (erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored;
              workInProgressRootFatalError = thrownValue;
              workInProgress = null;
              return;
            }
            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
            }
            if (enableSchedulingProfiler) {
              markComponentRenderStopped();
              if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                var wakeable = thrownValue;
                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
              } else {
                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
              }
            }
            throwException(root22, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
            completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue;
            if (workInProgress === erroredWork && erroredWork !== null) {
              erroredWork = erroredWork.return;
              workInProgress = erroredWork;
            } else {
              erroredWork = workInProgress;
            }
            continue;
          }
          return;
        } while (true);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) {
          return ContextOnlyDispatcher;
        } else {
          return prevDispatcher;
        }
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now2();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootSuspended;
        }
      }
      function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
        }
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
          markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
      }
      function renderDidError(error2) {
        if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
          workInProgressRootExitStatus = RootErrored;
        }
        if (workInProgressRootConcurrentErrors === null) {
          workInProgressRootConcurrentErrors = [error2];
        } else {
          workInProgressRootConcurrentErrors.push(error2);
        }
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootInProgress;
      }
      function renderRootSync(root22, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root22 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root22.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root22, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root22, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          prepareFreshStack(root22, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root22, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress !== null) {
          throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        }
        {
          markRenderStopped();
        }
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
      }
      function workLoopSync() {
        while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
        }
      }
      function renderRootConcurrent(root22, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root22 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root22.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root22, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root22, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          resetRenderTimer();
          prepareFreshStack(root22, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root22, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress !== null) {
          {
            markRenderYielded();
          }
          return RootInProgress;
        } else {
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
      }
      function workLoopConcurrent() {
        while (workInProgress !== null && !shouldYield()) {
          performUnitOfWork(workInProgress);
        }
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next2;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          startProfilerTimer(unitOfWork);
          next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else {
          next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
        }
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next2 === null) {
          completeUnitOfWork(unitOfWork);
        } else {
          workInProgress = next2;
        }
        ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current2 = completedWork.alternate;
          var returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next2 = void 0;
            if ((completedWork.mode & ProfileMode) === NoMode) {
              next2 = completeWork(current2, completedWork, subtreeRenderLanes);
            } else {
              startProfilerTimer(completedWork);
              next2 = completeWork(current2, completedWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
            }
            resetCurrentFiber();
            if (next2 !== null) {
              workInProgress = next2;
              return;
            }
          } else {
            var _next = unwindWork(current2, completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask;
              workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              var actualDuration = completedWork.actualDuration;
              var child = completedWork.child;
              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
            }
            if (returnFiber !== null) {
              returnFiber.flags |= Incomplete;
              returnFiber.subtreeFlags = NoFlags;
              returnFiber.deletions = null;
            } else {
              workInProgressRootExitStatus = RootDidNotComplete;
              workInProgress = null;
              return;
            }
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber;
          workInProgress = completedWork;
        } while (completedWork !== null);
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootCompleted;
        }
      }
      function commitRoot(root22, recoverableErrors, transitions) {
        var previousUpdateLanePriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          commitRootImpl(root22, recoverableErrors, transitions, previousUpdateLanePriority);
        } finally {
          ReactCurrentBatchConfig$3.transition = prevTransition;
          setCurrentUpdatePriority(previousUpdateLanePriority);
        }
        return null;
      }
      function commitRootImpl(root22, recoverableErrors, transitions, renderPriorityLevel) {
        do {
          flushPassiveEffects();
        } while (rootWithPendingPassiveEffects !== null);
        flushRenderPhaseStrictModeWarningsInDEV();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var finishedWork = root22.finishedWork;
        var lanes = root22.finishedLanes;
        {
          markCommitStarted(lanes);
        }
        if (finishedWork === null) {
          {
            markCommitStopped();
          }
          return null;
        } else {
          {
            if (lanes === NoLanes) {
              error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
            }
          }
        }
        root22.finishedWork = null;
        root22.finishedLanes = NoLanes;
        if (finishedWork === root22.current) {
          throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        }
        root22.callbackNode = null;
        root22.callbackPriority = NoLane;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root22, remainingLanes);
        if (root22 === workInProgressRoot) {
          workInProgressRoot = null;
          workInProgress = null;
          workInProgressRootRenderLanes = NoLanes;
        }
        if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            pendingPassiveTransitions = transitions;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        if (subtreeHasEffects || rootHasEffect) {
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          ReactCurrentBatchConfig$3.transition = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(DiscreteEventPriority);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          ReactCurrentOwner$2.current = null;
          commitBeforeMutationEffects(root22, finishedWork);
          {
            recordCommitTime();
          }
          commitMutationEffects(root22, finishedWork, lanes);
          resetAfterCommit(root22.containerInfo);
          root22.current = finishedWork;
          {
            markLayoutEffectsStarted(lanes);
          }
          commitLayoutEffects(finishedWork, root22, lanes);
          {
            markLayoutEffectsStopped();
          }
          requestPaint();
          executionContext = prevExecutionContext;
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
        } else {
          root22.current = finishedWork;
          {
            recordCommitTime();
          }
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
          rootDoesHavePassiveEffects = false;
          rootWithPendingPassiveEffects = root22;
          pendingPassiveEffectsLanes = lanes;
        } else {
          {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
          }
        }
        remainingLanes = root22.pendingLanes;
        if (remainingLanes === NoLanes) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }
        {
          if (!rootDidHavePassiveEffects) {
            commitDoubleInvokeEffectsInDEV(root22.current, false);
          }
        }
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        {
          if (isDevToolsPresent) {
            root22.memoizedUpdaters.clear();
          }
        }
        {
          onCommitRoot$1();
        }
        ensureRootIsScheduled(root22, now2());
        if (recoverableErrors !== null) {
          var onRecoverableError = root22.onRecoverableError;
          for (var i2 = 0; i2 < recoverableErrors.length; i2++) {
            var recoverableError = recoverableErrors[i2];
            var componentStack = recoverableError.stack;
            var digest = recoverableError.digest;
            onRecoverableError(recoverableError.value, {
              componentStack,
              digest
            });
          }
        }
        if (hasUncaughtError) {
          hasUncaughtError = false;
          var error$1 = firstUncaughtError;
          firstUncaughtError = null;
          throw error$1;
        }
        if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root22.tag !== LegacyRoot) {
          flushPassiveEffects();
        }
        remainingLanes = root22.pendingLanes;
        if (includesSomeLane(remainingLanes, SyncLane)) {
          {
            markNestedUpdateScheduled();
          }
          if (root22 === rootWithNestedUpdates) {
            nestedUpdateCount++;
          } else {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = root22;
          }
        } else {
          nestedUpdateCount = 0;
        }
        flushSyncCallbacks();
        {
          markCommitStopped();
        }
        return null;
      }
      function flushPassiveEffects() {
        if (rootWithPendingPassiveEffects !== null) {
          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
          var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(priority);
            return flushPassiveEffectsImpl();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          }
        }
        return false;
      }
      function enqueuePendingPassiveProfilerEffect(fiber) {
        {
          pendingPassiveProfilerEffects.push(fiber);
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) {
          return false;
        }
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root22 = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Cannot flush passive effects while already rendering.");
        }
        {
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        {
          markPassiveEffectsStarted(lanes);
        }
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountEffects(root22.current);
        commitPassiveMountEffects(root22, root22.current, lanes, transitions);
        {
          var profilerEffects = pendingPassiveProfilerEffects;
          pendingPassiveProfilerEffects = [];
          for (var i2 = 0; i2 < profilerEffects.length; i2++) {
            var _fiber = profilerEffects[i2];
            commitPassiveEffectDurations(root22, _fiber);
          }
        }
        {
          markPassiveEffectsStopped();
        }
        {
          commitDoubleInvokeEffectsInDEV(root22.current, true);
        }
        executionContext = prevExecutionContext;
        flushSyncCallbacks();
        {
          if (didScheduleUpdateDuringPassiveEffects) {
            if (root22 === rootWithPassiveNestedUpdates) {
              nestedPassiveUpdateCount++;
            } else {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = root22;
            }
          } else {
            nestedPassiveUpdateCount = 0;
          }
          isFlushingPassiveEffects = false;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        onPostCommitRoot(root22);
        {
          var stateNode = root22.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
        }
        return true;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }
      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }
      function prepareToThrowUncaughtError(error2) {
        if (!hasUncaughtError) {
          hasUncaughtError = true;
          firstUncaughtError = error2;
        }
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        var root22 = enqueueUpdate(rootFiber, update, SyncLane);
        var eventTime = requestEventTime();
        if (root22 !== null) {
          markRootUpdated(root22, SyncLane, eventTime);
          ensureRootIsScheduled(root22, eventTime);
        }
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
        {
          reportUncaughtErrorInDEV(error$1);
          setIsRunningInsertionEffect(false);
        }
        if (sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
          return;
        }
        var fiber = null;
        {
          fiber = nearestMountedAncestor;
        }
        while (fiber !== null) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type;
            var instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
              var root22 = enqueueUpdate(fiber, update, SyncLane);
              var eventTime = requestEventTime();
              if (root22 !== null) {
                markRootUpdated(root22, SyncLane, eventTime);
                ensureRootIsScheduled(root22, eventTime);
              }
              return;
            }
          }
          fiber = fiber.return;
        }
        {
          error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
        }
      }
      function pingSuspendedRoot(root22, wakeable, pingedLanes) {
        var pingCache = root22.pingCache;
        if (pingCache !== null) {
          pingCache.delete(wakeable);
        }
        var eventTime = requestEventTime();
        markRootPinged(root22, pingedLanes);
        warnIfSuspenseResolutionNotWrappedWithActDEV(root22);
        if (workInProgressRoot === root22 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
          if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
            prepareFreshStack(root22, NoLanes);
          } else {
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
          }
        }
        ensureRootIsScheduled(root22, eventTime);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        if (retryLane === NoLane) {
          retryLane = requestRetryLane(boundaryFiber);
        }
        var eventTime = requestEventTime();
        var root22 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        if (root22 !== null) {
          markRootUpdated(root22, retryLane, eventTime);
          ensureRootIsScheduled(root22, eventTime);
        }
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState;
        var retryLane = NoLane;
        if (suspenseState !== null) {
          retryLane = suspenseState.retryLane;
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane;
        var retryCache;
        switch (boundaryFiber.tag) {
          case SuspenseComponent:
            retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            break;
          case SuspenseListComponent:
            retryCache = boundaryFiber.stateNode;
            break;
          default:
            throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
        if (retryCache !== null) {
          retryCache.delete(wakeable);
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          rootWithNestedUpdates = null;
          throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        }
        {
          if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
            error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
          }
        }
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        {
          ReactStrictModeWarnings.flushLegacyContextWarning();
          {
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          }
        }
      }
      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
        {
          setCurrentFiber(fiber);
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
          }
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
          }
          resetCurrentFiber();
        }
      }
      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
        {
          var current2 = firstChild;
          var subtreeRoot = null;
          while (current2 !== null) {
            var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
            if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
              current2 = current2.child;
            } else {
              if ((current2.flags & fiberFlags) !== NoFlags) {
                invokeEffectFn(current2);
              }
              if (current2.sibling !== null) {
                current2 = current2.sibling;
              } else {
                current2 = subtreeRoot = current2.return;
              }
            }
          }
        }
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext) {
            return;
          }
          if (!(fiber.mode & ConcurrentMode)) {
            return;
          }
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
            return;
          }
          var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
              return;
            }
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else {
            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
          }
          var previousFiber = current;
          try {
            setCurrentFiber(fiber);
            error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            if (previousFiber) {
              setCurrentFiber(fiber);
            } else {
              resetCurrentFiber();
            }
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current2, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current2, unitOfWork, lanes);
          } catch (originalError) {
            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
              throw originalError;
            }
            resetContextDependencies();
            resetHooksAfterThrow();
            unwindInterruptedWork(current2, unitOfWork);
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) {
              startProfilerTimer(unitOfWork);
            }
            invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
            if (hasCaughtError()) {
              var replayError = clearCaughtError();
              if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                originalError._suppressLogging = true;
              }
            }
            throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent;
      {
        didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      }
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        {
          if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                  var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                  error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
              }
              case ClassComponent: {
                if (!didWarnAboutUpdateInRender) {
                  error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                  didWarnAboutUpdateInRender = true;
                }
                break;
              }
            }
          }
        }
      }
      function restorePendingUpdaters(root22, lanes) {
        {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root22.memoizedUpdaters;
            memoizedUpdaters.forEach(function(schedulingFiber) {
              addFiberToLanesMap(root22, schedulingFiber, lanes);
            });
          }
        }
      }
      var fakeActCallbackNode = {};
      function scheduleCallback$1(priorityLevel, callback) {
        {
          var actQueue = ReactCurrentActQueue$1.current;
          if (actQueue !== null) {
            actQueue.push(callback);
            return fakeActCallbackNode;
          } else {
            return scheduleCallback(priorityLevel, callback);
          }
        }
      }
      function cancelCallback$1(callbackNode) {
        if (callbackNode === fakeActCallbackNode) {
          return;
        }
        return cancelCallback(callbackNode);
      }
      function shouldForceFlushFallbacksInDEV() {
        return ReactCurrentActQueue$1.current !== null;
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        {
          if (fiber.mode & ConcurrentMode) {
            if (!isConcurrentActEnvironment()) {
              return;
            }
          } else {
            if (!isLegacyActEnvironment()) {
              return;
            }
            if (executionContext !== NoContext) {
              return;
            }
            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
              return;
            }
          }
          if (ReactCurrentActQueue$1.current === null) {
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
      }
      function warnIfSuspenseResolutionNotWrappedWithActDEV(root22) {
        {
          if (root22.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
            error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
          }
        }
      }
      function setIsRunningInsertionEffect(isRunning) {
        {
          isRunningInsertionEffect = isRunning;
        }
      }
      var resolveFamily = null;
      var failedBoundaries = null;
      var setRefreshHandler = function(handler) {
        {
          resolveFamily = handler;
        }
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            return type;
          }
          return family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            if (type !== null && type !== void 0 && typeof type.render === "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                if (type.displayName !== void 0) {
                  syntheticType.displayName = type.displayName;
                }
                return syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null) {
            return false;
          }
          var prevType = fiber.elementType;
          var nextType = element.type;
          var needsCompareFamilies = false;
          var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              }
              break;
            }
            case FunctionComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case ForwardRef: {
              if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              if ($$typeofNextType === REACT_MEMO_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            default:
              return false;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
              return true;
            }
          }
          return false;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null) {
            return;
          }
          if (typeof WeakSet !== "function") {
            return;
          }
          if (failedBoundaries === null) {
            failedBoundaries = /* @__PURE__ */ new WeakSet();
          }
          failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root22, update) {
        {
          if (resolveFamily === null) {
            return;
          }
          var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
          flushPassiveEffects();
          flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root22.current, updatedFamilies, staleFamilies);
          });
        }
      };
      var scheduleRoot = function(root22, element) {
        {
          if (root22.context !== emptyContextObject) {
            return;
          }
          flushPassiveEffects();
          flushSync(function() {
            updateContainer(element, root22, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null) {
            throw new Error("Expected resolveFamily to be set during hot reload.");
          }
          var needsRender = false;
          var needsRemount = false;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== void 0) {
              if (staleFamilies.has(family)) {
                needsRemount = true;
              } else if (updatedFamilies.has(family)) {
                if (tag === ClassComponent) {
                  needsRemount = true;
                } else {
                  needsRender = true;
                }
              }
            }
          }
          if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
              needsRemount = true;
            }
          }
          if (needsRemount) {
            fiber._debugNeedsRemount = true;
          }
          if (needsRemount || needsRender) {
            var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (_root !== null) {
              scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
            }
          }
          if (child !== null && !needsRemount) {
            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
          }
          if (sibling !== null) {
            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
          }
        }
      }
      var findHostInstancesForRefresh = function(root22, families) {
        {
          var hostInstances = /* @__PURE__ */ new Set();
          var types = new Set(families.map(function(family) {
            return family.current;
          }));
          findHostInstancesForMatchingFibersRecursively(root22.current, types, hostInstances);
          return hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        {
          var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          var didMatch = false;
          if (candidateType !== null) {
            if (types.has(candidateType)) {
              didMatch = true;
            }
          }
          if (didMatch) {
            findHostInstancesForFiberShallowly(fiber, hostInstances);
          } else {
            if (child !== null) {
              findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
            }
          }
          if (sibling !== null) {
            findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
          }
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances) {
            return;
          }
          var node = fiber;
          while (true) {
            switch (node.tag) {
              case HostComponent:
                hostInstances.add(node.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node.stateNode.containerInfo);
                return;
            }
            if (node.return === null) {
              throw new Error("Expected to reach root first.");
            }
            node = node.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var node = fiber;
          var foundHostInstances = false;
          while (true) {
            if (node.tag === HostComponent) {
              foundHostInstances = true;
              hostInstances.add(node.stateNode);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === fiber) {
              return foundHostInstances;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === fiber) {
                return foundHostInstances;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return false;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode;
        this.flags = NoFlags;
        this.subtreeFlags = NoFlags;
        this.deletions = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }
        {
          this._debugSource = null;
          this._debugOwner = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }
      var createFiber = function(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== void 0 && Component !== null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }
          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        if (workInProgress2 === null) {
          workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
          workInProgress2.elementType = current2.elementType;
          workInProgress2.type = current2.type;
          workInProgress2.stateNode = current2.stateNode;
          {
            workInProgress2._debugSource = current2._debugSource;
            workInProgress2._debugOwner = current2._debugOwner;
            workInProgress2._debugHookTypes = current2._debugHookTypes;
          }
          workInProgress2.alternate = current2;
          current2.alternate = workInProgress2;
        } else {
          workInProgress2.pendingProps = pendingProps;
          workInProgress2.type = current2.type;
          workInProgress2.flags = NoFlags;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          {
            workInProgress2.actualDuration = 0;
            workInProgress2.actualStartTime = -1;
          }
        }
        workInProgress2.flags = current2.flags & StaticMask;
        workInProgress2.childLanes = current2.childLanes;
        workInProgress2.lanes = current2.lanes;
        workInProgress2.child = current2.child;
        workInProgress2.memoizedProps = current2.memoizedProps;
        workInProgress2.memoizedState = current2.memoizedState;
        workInProgress2.updateQueue = current2.updateQueue;
        var currentDependencies = current2.dependencies;
        workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        };
        workInProgress2.sibling = current2.sibling;
        workInProgress2.index = current2.index;
        workInProgress2.ref = current2.ref;
        {
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        }
        {
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case ClassComponent:
              workInProgress2.type = resolveClassForHotReloading(current2.type);
              break;
            case ForwardRef:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
              break;
          }
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= StaticMask | Placement;
        var current2 = workInProgress2.alternate;
        if (current2 === null) {
          workInProgress2.childLanes = NoLanes;
          workInProgress2.lanes = renderLanes2;
          workInProgress2.child = null;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.memoizedProps = null;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.dependencies = null;
          workInProgress2.stateNode = null;
          {
            workInProgress2.selfBaseDuration = 0;
            workInProgress2.treeBaseDuration = 0;
          }
        } else {
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.type = current2.type;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
        var mode;
        if (tag === ConcurrentRoot) {
          mode = ConcurrentMode;
          if (isStrictMode === true) {
            mode |= StrictLegacyMode;
            {
              mode |= StrictEffectsMode;
            }
          }
        } else {
          mode = NoMode;
        }
        if (isDevToolsPresent) {
          mode |= ProfileMode;
        }
        return createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            fiberTag = ClassComponent;
            {
              resolvedType = resolveClassForHotReloading(resolvedType);
            }
          } else {
            {
              resolvedType = resolveFunctionForHotReloading(resolvedType);
            }
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = Mode;
              mode |= StrictLegacyMode;
              if ((mode & ConcurrentMode) !== NoMode) {
                mode |= StrictEffectsMode;
              }
              break;
            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_LIST_TYPE:
              return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
            case REACT_OFFSCREEN_TYPE:
              return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_SCOPE_TYPE:
            case REACT_CACHE_TYPE:
            case REACT_TRACING_MARKER_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            default: {
              if (typeof type === "object" && type !== null) {
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:
                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    {
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    }
                    break getTag;
                  case REACT_MEMO_TYPE:
                    fiberTag = MemoComponent;
                    break getTag;
                  case REACT_LAZY_TYPE:
                    fiberTag = LazyComponent;
                    resolvedType = null;
                    break getTag;
                }
              }
              var info = "";
              {
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
            }
          }
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        {
          fiber._debugOwner = owner;
        }
        return fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        {
          if (typeof pendingProps.id !== "string") {
            error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        {
          fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          };
        }
        return fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        var primaryChildInstance = {
          isHidden: false
        };
        fiber.stateNode = primaryChildInstance;
        return fiber;
      }
      function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        fiber.elementType = "DELETED";
        return fiber;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(DehydratedFragment, null, null, NoMode);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          // Used by persistent updates
          implementation: portal.implementation
        };
        return fiber;
      }
      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoMode);
        }
        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.dependencies = source.dependencies;
        target.mode = source.mode;
        target.flags = source.flags;
        target.subtreeFlags = source.subtreeFlags;
        target.deletions = source.deletions;
        target.lanes = source.lanes;
        target.childLanes = source.childLanes;
        target.alternate = source.alternate;
        {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugNeedsRemount = source._debugNeedsRemount;
        target._debugHookTypes = source._debugHookTypes;
        return target;
      }
      function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.callbackNode = null;
        this.callbackPriority = NoLane;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.identifierPrefix = identifierPrefix;
        this.onRecoverableError = onRecoverableError;
        {
          this.mutableSourceEagerHydrationData = null;
        }
        {
          this.effectDuration = 0;
          this.passiveEffectDuration = 0;
        }
        {
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
          for (var _i = 0; _i < TotalLanes; _i++) {
            pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
          }
        }
        {
          switch (tag) {
            case ConcurrentRoot:
              this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
              break;
            case LegacyRoot:
              this._debugRootType = hydrate2 ? "hydrate()" : "render()";
              break;
          }
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var root22 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
        var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
        root22.current = uninitializedFiber;
        uninitializedFiber.stateNode = root22;
        {
          var _initialState = {
            element: initialChildren,
            isDehydrated: hydrate2,
            cache: null,
            // not enabled yet
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          uninitializedFiber.memoizedState = _initialState;
        }
        initializeUpdateQueue(uninitializedFiber);
        return root22;
      }
      var ReactVersion = "18.3.1";
      function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        {
          checkKeyStringCoercion(key);
        }
        return {
          // This tag allow us to uniquely identify this as a React Portal
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates;
      var didWarnAboutFindNodeInStrictMode;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }
        var fiber = get(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }
        return parentContext;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get(component);
          if (fiber === void 0) {
            if (typeof component.render === "function") {
              throw new Error("Unable to find node on an unmounted component.");
            } else {
              var keys = Object.keys(component).join(",");
              throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
            }
          }
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          if (hostFiber.mode & StrictLegacyMode) {
            var componentName = getComponentNameFromFiber(fiber) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;
              var previousFiber = current;
              try {
                setCurrentFiber(hostFiber);
                if (fiber.mode & StrictLegacyMode) {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } else {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                }
              } finally {
                if (previousFiber) {
                  setCurrentFiber(previousFiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = false;
        var initialChildren = null;
        return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      }
      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = true;
        var root22 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        root22.context = getContextForSubtree(null);
        var current2 = root22.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current2);
        var update = createUpdate(eventTime, lane);
        update.callback = callback !== void 0 && callback !== null ? callback : null;
        enqueueUpdate(current2, update, lane);
        scheduleInitialHydrationOnRoot(root22, lane, eventTime);
        return root22;
      }
      function updateContainer(element, container, parentComponent, callback) {
        {
          onScheduleRoot(container, element);
        }
        var current$1 = container.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current$1);
        {
          markRenderScheduled(lane);
        }
        var context = getContextForSubtree(parentComponent);
        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }
        {
          if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
          }
        }
        var update = createUpdate(eventTime, lane);
        update.payload = {
          element
        };
        callback = callback === void 0 ? null : callback;
        if (callback !== null) {
          {
            if (typeof callback !== "function") {
              error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
            }
          }
          update.callback = callback;
        }
        var root22 = enqueueUpdate(current$1, update, lane);
        if (root22 !== null) {
          scheduleUpdateOnFiber(root22, current$1, lane, eventTime);
          entangleTransitions(root22, current$1, lane);
        }
        return lane;
      }
      function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child) {
          return null;
        }
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      }
      function attemptSynchronousHydration$1(fiber) {
        switch (fiber.tag) {
          case HostRoot: {
            var root22 = fiber.stateNode;
            if (isRootDehydrated(root22)) {
              var lanes = getHighestPriorityPendingLanes(root22);
              flushRoot(root22, lanes);
            }
            break;
          }
          case SuspenseComponent: {
            flushSync(function() {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
              }
            });
            var retryLane = SyncLane;
            markRetryLaneIfNotHydrated(fiber, retryLane);
            break;
          }
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) {
          suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) {
          markRetryLaneImpl(alternate, retryLane);
        }
      }
      function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = SelectiveHydrationLane;
        var root22 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root22 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = requestUpdateLane(fiber);
        var root22 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root22 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root22, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      var shouldErrorImpl = function(fiber) {
        return null;
      };
      function shouldError(fiber) {
        return shouldErrorImpl(fiber);
      }
      var shouldSuspendImpl = function(fiber) {
        return false;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null;
      var overrideHookStateDeletePath = null;
      var overrideHookStateRenamePath = null;
      var overrideProps = null;
      var overridePropsDeletePath = null;
      var overridePropsRenamePath = null;
      var scheduleUpdate = null;
      var setErrorHandler = null;
      var setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path, index2) {
          var key = path[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === path.length) {
            if (isArray(updated)) {
              updated.splice(key, 1);
            } else {
              delete updated[key];
            }
            return updated;
          }
          updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
          return updated;
        };
        var copyWithDelete = function(obj, path) {
          return copyWithDeleteImpl(obj, path, 0);
        };
        var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey];
            if (isArray(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRenameImpl(
              // $FlowFixMe number or string is fine here
              obj[oldKey],
              oldPath,
              newPath,
              index2 + 1
            );
          }
          return updated;
        };
        var copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn("copyWithRename() expects paths of the same length");
            return;
          } else {
            for (var i2 = 0; i2 < newPath.length - 1; i2++) {
              if (oldPath[i2] !== newPath[i2]) {
                warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
            }
          }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        };
        var copyWithSetImpl = function(obj, path, index2, value) {
          if (index2 >= path.length) {
            return value;
          }
          var key = path[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
          return updated;
        };
        var copyWithSet = function(obj, path, value) {
          return copyWithSetImpl(obj, path, 0, value);
        };
        var findHook = function(fiber, id) {
          var currentHook2 = fiber.memoizedState;
          while (currentHook2 !== null && id > 0) {
            currentHook2 = currentHook2.next;
            id--;
          }
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path, value) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root22 !== null) {
              scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root22 !== null) {
              scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root22 !== null) {
              scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
          }
        };
        scheduleUpdate = function(fiber) {
          var root22 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root22 !== null) {
            scheduleUpdateOnFiber(root22, fiber, SyncLane, NoTimestamp);
          }
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setErrorHandler,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          // React Refresh
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          // Enables DevTools to append owner stacks to error messages in DEV mode.
          getCurrentFiber: getCurrentFiberForDevTools,
          // Enables DevTools to detect reconciler version rather than renderer version
          // which may not match for third party renderers.
          reconcilerVersion: ReactVersion
        });
      }
      var defaultOnRecoverableError = typeof reportError === "function" ? (
        // In modern browsers, reportError will dispatch an error event,
        // emulating an uncaught JavaScript error.
        reportError
      ) : function(error2) {
        console["error"](error2);
      };
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root22 = this._internalRoot;
        if (root22 === null) {
          throw new Error("Cannot update an unmounted root.");
        }
        {
          if (typeof arguments[1] === "function") {
            error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          } else if (isValidContainer(arguments[1])) {
            error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
          } else if (typeof arguments[1] !== "undefined") {
            error("You passed a second argument to root.render(...) but it only accepts one argument.");
          }
          var container = root22.containerInfo;
          if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root22.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
              }
            }
          }
        }
        updateContainer(children, root22, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        {
          if (typeof arguments[0] === "function") {
            error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          }
        }
        var root22 = this._internalRoot;
        if (root22 !== null) {
          this._internalRoot = null;
          var container = root22.containerInfo;
          {
            if (isAlreadyRendering()) {
              error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
            }
          }
          flushSync(function() {
            updateContainer(null, root22, null, null);
          });
          unmarkContainerAsRoot(container);
        }
      };
      function createRoot(container, options2) {
        if (!isValidContainer(container)) {
          throw new Error("createRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          {
            if (options2.hydrate) {
              warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
            } else {
              if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
              }
            }
          }
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
          if (options2.transitionCallbacks !== void 0) {
            options2.transitionCallbacks;
          }
        }
        var root22 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root22.current, container);
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        listenToAllSupportedEvents(rootContainerElement);
        return new ReactDOMRoot(root22);
      }
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function scheduleHydration(target) {
        if (target) {
          queueExplicitHydrationTarget(target);
        }
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
      function hydrateRoot(container, initialChildren, options2) {
        if (!isValidContainer(container)) {
          throw new Error("hydrateRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        {
          if (initialChildren === void 0) {
            error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
          }
        }
        var hydrationCallbacks = options2 != null ? options2 : null;
        var mutableSources = options2 != null && options2.hydratedSources || null;
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
        }
        var root22 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root22.current, container);
        listenToAllSupportedEvents(container);
        if (mutableSources) {
          for (var i2 = 0; i2 < mutableSources.length; i2++) {
            var mutableSource = mutableSources[i2];
            registerMutableSourceForHydration(root22, mutableSource);
          }
        }
        return new ReactDOMHydrationRoot(root22);
      }
      function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || false));
      }
      function isValidContainerLegacy(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
      }
      function warnIfReactDOMContainerInDEV(container) {
        {
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
          }
          if (isContainerMarkedAsRoot(container)) {
            if (container._reactRootContainer) {
              error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
            } else {
              error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
            }
          }
        }
      }
      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var topLevelUpdateWarnings;
      {
        topLevelUpdateWarnings = function(container) {
          if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
              }
            }
          }
          var isRootRenderedBySomeReact = !!container._reactRootContainer;
          var rootEl = getReactRootElementInContainer(container);
          var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
          if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
            error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
          }
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
          }
        };
      }
      function getReactRootElementInContainer(container) {
        if (!container) {
          return null;
        }
        if (container.nodeType === DOCUMENT_NODE) {
          return container.documentElement;
        } else {
          return container.firstChild;
        }
      }
      function noopOnRecoverableError() {
      }
      function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
        if (isHydrationContainer) {
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root22);
              originalCallback.call(instance);
            };
          }
          var root22 = createHydrationContainer(
            initialChildren,
            callback,
            container,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container._reactRootContainer = root22;
          markContainerAsRoot(root22.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          flushSync();
          return root22;
        } else {
          var rootSibling;
          while (rootSibling = container.lastChild) {
            container.removeChild(rootSibling);
          }
          if (typeof callback === "function") {
            var _originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(_root);
              _originalCallback.call(instance);
            };
          }
          var _root = createContainer(
            container,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container._reactRootContainer = _root;
          markContainerAsRoot(_root.current, container);
          var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(_rootContainerElement);
          flushSync(function() {
            updateContainer(initialChildren, _root, parentComponent, callback);
          });
          return _root;
        }
      }
      function warnOnInvalidCallback$1(callback, callerName) {
        {
          if (callback !== null && typeof callback !== "function") {
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        }
      }
      function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        {
          topLevelUpdateWarnings(container);
          warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
        }
        var maybeRoot = container._reactRootContainer;
        var root22;
        if (!maybeRoot) {
          root22 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
        } else {
          root22 = maybeRoot;
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root22);
              originalCallback.call(instance);
            };
          }
          updateContainer(children, root22, parentComponent, callback);
        }
        return getPublicRootInstance(root22);
      }
      var didWarnAboutFindDOMNode = false;
      function findDOMNode(componentOrElement) {
        {
          if (!didWarnAboutFindDOMNode) {
            didWarnAboutFindDOMNode = true;
            error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
          }
          var owner = ReactCurrentOwner$3.current;
          if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) {
              error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
            }
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }
        if (componentOrElement == null) {
          return null;
        }
        if (componentOrElement.nodeType === ELEMENT_NODE) {
          return componentOrElement;
        }
        {
          return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
        }
      }
      function hydrate(element, container, callback) {
        {
          error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
      }
      function render(element, container, callback) {
        {
          error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
      }
      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        {
          error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(containerNode)) {
          throw new Error("Target container is not a DOM element.");
        }
        if (parentComponent == null || !has2(parentComponent)) {
          throw new Error("parentComponent must be a valid React Component");
        }
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
      }
      var didWarnAboutUnmountComponentAtNode = false;
      function unmountComponentAtNode(container) {
        {
          if (!didWarnAboutUnmountComponentAtNode) {
            didWarnAboutUnmountComponentAtNode = true;
            error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
          }
        }
        if (container._reactRootContainer) {
          {
            var rootEl = getReactRootElementInContainer(container);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
            }
          }
          flushSync(function() {
            legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
              container._reactRootContainer = null;
              unmarkContainerAsRoot(container);
            });
          });
          return true;
        } else {
          {
            var _rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
            if (hasNonRootReactChild) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
            }
          }
          return false;
        }
      }
      setAttemptSynchronousHydration(attemptSynchronousHydration$1);
      setAttemptContinuousHydration(attemptContinuousHydration$1);
      setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
      setGetCurrentUpdatePriority(getCurrentUpdatePriority);
      setAttemptHydrationAtPriority(runWithPriority);
      {
        if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
        Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
        Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
          error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
      }
      setRestoreImplementation(restoreControlledState$3);
      setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
      function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!isValidContainer(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        return createPortal(children, container, null, key);
      }
      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
      }
      var Internals = {
        usingClientEntryPoint: false,
        // Keep in sync with ReactTestUtils.js.
        // This is an array for better minification.
        Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
      };
      function createRoot$1(container, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return createRoot(container, options2);
      }
      function hydrateRoot$1(container, initialChildren, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return hydrateRoot(container, initialChildren, options2);
      }
      function flushSync$1(fn) {
        {
          if (isAlreadyRendering()) {
            error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
          }
        }
        return flushSync(fn);
      }
      var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-dom"
      });
      {
        if (!foundDevTools && canUseDOM && window.top === window.self) {
          if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
            var protocol = window.location.protocol;
            if (/^(https?|file):$/.test(protocol)) {
              console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
            }
          }
        }
      }
      reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
      reactDom_development.createPortal = createPortal$1;
      reactDom_development.createRoot = createRoot$1;
      reactDom_development.findDOMNode = findDOMNode;
      reactDom_development.flushSync = flushSync$1;
      reactDom_development.hydrate = hydrate;
      reactDom_development.hydrateRoot = hydrateRoot$1;
      reactDom_development.render = render;
      reactDom_development.unmountComponentAtNode = unmountComponentAtNode;
      reactDom_development.unstable_batchedUpdates = batchedUpdates$1;
      reactDom_development.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
      reactDom_development.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  {
    reactDom.exports = reactDom_development;
  }
  var reactDomExports = reactDom.exports;
  var m = reactDomExports;
  {
    var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    client.createRoot = function(c, o) {
      i.usingClientEntryPoint = true;
      try {
        return m.createRoot(c, o);
      } finally {
        i.usingClientEntryPoint = false;
      }
    };
    client.hydrateRoot = function(c, h, o) {
      i.usingClientEntryPoint = true;
      try {
        return m.hydrateRoot(c, h, o);
      } finally {
        i.usingClientEntryPoint = false;
      }
    };
  }
  let runtime;
  const getRuntime = () => {
    return runtime;
  };
  const setRuntime = (r) => {
    runtime = r;
  };
  _utils_csui;
  var browserPolyfill = { exports: {} };
  (function(module, exports) {
    (function(global2, factory) {
      {
        factory(module);
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : commonjsGlobal, function(module2) {
      var _a2, _b2;
      if (!((_b2 = (_a2 = globalThis.chrome) == null ? void 0 : _a2.runtime) == null ? void 0 : _b2.id)) {
        throw new Error("This script should only be loaded in a browser extension.");
      }
      if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
        const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
        const wrapAPIs = (extensionAPIs) => {
          const apiMetadata = {
            "alarms": {
              "clear": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "clearAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "get": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "bookmarks": {
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getChildren": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getRecent": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getSubTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTree": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "browserAction": {
              "disable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "enable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "getBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getBadgeText": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "openPopup": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setBadgeText": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "browsingData": {
              "remove": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "removeCache": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCookies": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeDownloads": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFormData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeHistory": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeLocalStorage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePasswords": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePluginData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "settings": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "commands": {
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "contextMenus": {
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "cookies": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAllCookieStores": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "set": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "devtools": {
              "inspectedWindow": {
                "eval": {
                  "minArgs": 1,
                  "maxArgs": 2,
                  "singleCallbackArg": false
                }
              },
              "panels": {
                "create": {
                  "minArgs": 3,
                  "maxArgs": 3,
                  "singleCallbackArg": true
                },
                "elements": {
                  "createSidebarPane": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              }
            },
            "downloads": {
              "cancel": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "download": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "erase": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFileIcon": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "open": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "pause": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFile": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "resume": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "extension": {
              "isAllowedFileSchemeAccess": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "isAllowedIncognitoAccess": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "history": {
              "addUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "deleteRange": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getVisits": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "i18n": {
              "detectLanguage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAcceptLanguages": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "identity": {
              "launchWebAuthFlow": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "idle": {
              "queryState": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "management": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getSelf": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setEnabled": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "uninstallSelf": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "notifications": {
              "clear": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPermissionLevel": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "pageAction": {
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "hide": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "permissions": {
              "contains": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "request": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "runtime": {
              "getBackgroundPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPlatformInfo": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "openOptionsPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "requestUpdateCheck": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "sendMessage": {
                "minArgs": 1,
                "maxArgs": 3
              },
              "sendNativeMessage": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "setUninstallURL": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "sessions": {
              "getDevices": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getRecentlyClosed": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "restore": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "storage": {
              "local": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "managed": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "sync": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              }
            },
            "tabs": {
              "captureVisibleTab": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "detectLanguage": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "discard": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "duplicate": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "executeScript": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getZoom": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getZoomSettings": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goBack": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goForward": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "highlight": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "insertCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "query": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "reload": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "sendMessage": {
                "minArgs": 2,
                "maxArgs": 3
              },
              "setZoom": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "setZoomSettings": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "update": {
                "minArgs": 1,
                "maxArgs": 2
              }
            },
            "topSites": {
              "get": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "webNavigation": {
              "getAllFrames": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFrame": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "webRequest": {
              "handlerBehaviorChanged": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "windows": {
              "create": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getLastFocused": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            }
          };
          if (Object.keys(apiMetadata).length === 0) {
            throw new Error("api-metadata.json has not been included in browser-polyfill");
          }
          class DefaultWeakMap extends WeakMap {
            constructor(createItem, items = void 0) {
              super(items);
              this.createItem = createItem;
            }
            get(key) {
              if (!this.has(key)) {
                this.set(key, this.createItem(key));
              }
              return super.get(key);
            }
          }
          const isThenable = (value) => {
            return value && typeof value === "object" && typeof value.then === "function";
          };
          const makeCallback = (promise, metadata) => {
            return (...callbackArgs) => {
              if (extensionAPIs.runtime.lastError) {
                promise.reject(new Error(extensionAPIs.runtime.lastError.message));
              } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                promise.resolve(callbackArgs[0]);
              } else {
                promise.resolve(callbackArgs);
              }
            };
          };
          const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
          const wrapAsyncFunction = (name, metadata) => {
            return function asyncFunctionWrapper(target, ...args) {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                if (metadata.fallbackToNoCallback) {
                  try {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  } catch (cbError) {
                    console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                    target[name](...args);
                    metadata.fallbackToNoCallback = false;
                    metadata.noCallback = true;
                    resolve();
                  }
                } else if (metadata.noCallback) {
                  target[name](...args);
                  resolve();
                } else {
                  target[name](...args, makeCallback({
                    resolve,
                    reject
                  }, metadata));
                }
              });
            };
          };
          const wrapMethod = (target, method, wrapper) => {
            return new Proxy(method, {
              apply(targetMethod, thisObj, args) {
                return wrapper.call(thisObj, target, ...args);
              }
            });
          };
          let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
          const wrapObject = (target, wrappers = {}, metadata = {}) => {
            let cache = /* @__PURE__ */ Object.create(null);
            let handlers = {
              has(proxyTarget2, prop) {
                return prop in target || prop in cache;
              },
              get(proxyTarget2, prop, receiver) {
                if (prop in cache) {
                  return cache[prop];
                }
                if (!(prop in target)) {
                  return void 0;
                }
                let value = target[prop];
                if (typeof value === "function") {
                  if (typeof wrappers[prop] === "function") {
                    value = wrapMethod(target, target[prop], wrappers[prop]);
                  } else if (hasOwnProperty(metadata, prop)) {
                    let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                    value = wrapMethod(target, target[prop], wrapper);
                  } else {
                    value = value.bind(target);
                  }
                } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
                  value = wrapObject(value, wrappers[prop], metadata[prop]);
                } else if (hasOwnProperty(metadata, "*")) {
                  value = wrapObject(value, wrappers[prop], metadata["*"]);
                } else {
                  Object.defineProperty(cache, prop, {
                    configurable: true,
                    enumerable: true,
                    get() {
                      return target[prop];
                    },
                    set(value2) {
                      target[prop] = value2;
                    }
                  });
                  return value;
                }
                cache[prop] = value;
                return value;
              },
              set(proxyTarget2, prop, value, receiver) {
                if (prop in cache) {
                  cache[prop] = value;
                } else {
                  target[prop] = value;
                }
                return true;
              },
              defineProperty(proxyTarget2, prop, desc) {
                return Reflect.defineProperty(cache, prop, desc);
              },
              deleteProperty(proxyTarget2, prop) {
                return Reflect.deleteProperty(cache, prop);
              }
            };
            let proxyTarget = Object.create(target);
            return new Proxy(proxyTarget, handlers);
          };
          const wrapEvent = (wrapperMap) => ({
            addListener(target, listener, ...args) {
              target.addListener(wrapperMap.get(listener), ...args);
            },
            hasListener(target, listener) {
              return target.hasListener(wrapperMap.get(listener));
            },
            removeListener(target, listener) {
              target.removeListener(wrapperMap.get(listener));
            }
          });
          const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onRequestFinished(req) {
              const wrappedReq = wrapObject(
                req,
                {},
                {
                  getContent: {
                    minArgs: 0,
                    maxArgs: 0
                  }
                }
              );
              listener(wrappedReq);
            };
          });
          const onMessageWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onMessage2(message, sender, sendResponse) {
              let didCallSendResponse = false;
              let wrappedSendResponse;
              let sendResponsePromise = new Promise((resolve) => {
                wrappedSendResponse = function(response) {
                  didCallSendResponse = true;
                  resolve(response);
                };
              });
              let result2;
              try {
                result2 = listener(message, sender, wrappedSendResponse);
              } catch (err) {
                result2 = Promise.reject(err);
              }
              const isResultThenable = result2 !== true && isThenable(result2);
              if (result2 !== true && !isResultThenable && !didCallSendResponse) {
                return false;
              }
              const sendPromisedResult = (promise) => {
                promise.then((msg) => {
                  sendResponse(msg);
                }, (error) => {
                  let message2;
                  if (error && (error instanceof Error || typeof error.message === "string")) {
                    message2 = error.message;
                  } else {
                    message2 = "An unexpected error occurred";
                  }
                  sendResponse({
                    __mozWebExtensionPolyfillReject__: true,
                    message: message2
                  });
                }).catch((err) => {
                  console.error("Failed to send onMessage rejected reply", err);
                });
              };
              if (isResultThenable) {
                sendPromisedResult(result2);
              } else {
                sendPromisedResult(sendResponsePromise);
              }
              return true;
            };
          });
          const wrappedSendMessageCallback = ({
            reject,
            resolve
          }, reply) => {
            if (extensionAPIs.runtime.lastError) {
              if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                resolve();
              } else {
                reject(new Error(extensionAPIs.runtime.lastError.message));
              }
            } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
              reject(new Error(reply.message));
            } else {
              resolve(reply);
            }
          };
          const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
            if (args.length < metadata.minArgs) {
              throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
            }
            if (args.length > metadata.maxArgs) {
              throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
            }
            return new Promise((resolve, reject) => {
              const wrappedCb = wrappedSendMessageCallback.bind(null, {
                resolve,
                reject
              });
              args.push(wrappedCb);
              apiNamespaceObj.sendMessage(...args);
            });
          };
          const staticWrappers = {
            devtools: {
              network: {
                onRequestFinished: wrapEvent(onRequestFinishedWrappers)
              }
            },
            runtime: {
              onMessage: wrapEvent(onMessageWrappers),
              onMessageExternal: wrapEvent(onMessageWrappers),
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 1,
                maxArgs: 3
              })
            },
            tabs: {
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 2,
                maxArgs: 3
              })
            }
          };
          const settingMetadata = {
            clear: {
              minArgs: 1,
              maxArgs: 1
            },
            get: {
              minArgs: 1,
              maxArgs: 1
            },
            set: {
              minArgs: 1,
              maxArgs: 1
            }
          };
          apiMetadata.privacy = {
            network: {
              "*": settingMetadata
            },
            services: {
              "*": settingMetadata
            },
            websites: {
              "*": settingMetadata
            }
          };
          return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
        };
        module2.exports = wrapAPIs(chrome);
      } else {
        module2.exports = globalThis.browser;
      }
    });
  })(browserPolyfill);
  var browserPolyfillExports = browserPolyfill.exports;
  const originalBrowser = /* @__PURE__ */ getDefaultExportFromCjs(browserPolyfillExports);
  var browser$1 = originalBrowser;
  var regex = /^[a-z](?:[\.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-(?:[\x2D\.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
  var isPotentialCustomElementName = function(string) {
    return regex.test(string);
  };
  var isPotentialCustomElementName_1 = isPotentialCustomElementName;
  const isPotentialCustomElementName$1 = /* @__PURE__ */ getDefaultExportFromCjs(isPotentialCustomElementName_1);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  function createIsolatedElement(options) {
    return __async(this, null, function* () {
      const {
        name,
        mode = "closed",
        css,
        isolateEvents = false
      } = options;
      if (!isPotentialCustomElementName$1(name)) {
        throw Error(`"${name}" is not a valid custom element name. It must be two words and kebab-case, with a few exceptions. See spec for more details: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name`);
      }
      const parentElement = document.createElement(name);
      const shadow = parentElement.attachShadow({
        mode
      });
      const isolatedElement = document.createElement("html");
      const body = document.createElement("body");
      const head = document.createElement("head");
      if (css) {
        const style = document.createElement("style");
        if ("url" in css) {
          style.textContent = yield fetch(css.url).then((res) => res.text());
        } else {
          style.textContent = css.textContent;
        }
        head.appendChild(style);
      }
      isolatedElement.appendChild(head);
      isolatedElement.appendChild(body);
      shadow.appendChild(isolatedElement);
      if (isolateEvents) {
        const eventTypes = Array.isArray(isolateEvents) ? isolateEvents : ["keydown", "keyup", "keypress"];
        eventTypes.forEach((eventType) => {
          body.addEventListener(eventType, (e) => e.stopPropagation());
        });
      }
      return {
        parentElement,
        shadow,
        isolatedElement: body
      };
    });
  }
  const __vite_import_meta_env__ = {};
  function print$1(method, ...args) {
    if (typeof args[0] === "string") {
      const message = args.shift();
      method(`[wxt] ${message}`, ...args);
    } else {
      method("[wxt]", ...args);
    }
  }
  var logger$2 = {
    debug: (...args) => print$1(console.debug, ...args),
    log: (...args) => print$1(console.log, ...args),
    warn: (...args) => print$1(console.warn, ...args),
    error: (...args) => print$1(console.error, ...args)
  };
  var WxtLocationChangeEvent = (_a = class extends Event {
    constructor(newUrl, oldUrl) {
      super(_a.EVENT_NAME, {});
      this.newUrl = newUrl;
      this.oldUrl = oldUrl;
    }
  }, __publicField(_a, "EVENT_NAME", getUniqueEventName("wxt:locationchange")), _a);
  function getUniqueEventName(eventName) {
    const entrypointName = typeof __vite_import_meta_env__ === "undefined" ? "build" : "utils-csui";
    return `${browser$1.runtime.id}:${entrypointName}:${eventName}`;
  }
  function createLocationWatcher(ctx) {
    let interval;
    let oldUrl;
    return {
      /**
       * Ensure the location watcher is actively looking for URL changes. If it's already watching,
       * this is a noop.
       */
      run() {
        if (interval != null) return;
        oldUrl = new URL(location.href);
        interval = ctx.setInterval(() => {
          let newUrl = new URL(location.href);
          if (newUrl.href !== oldUrl.href) {
            window.dispatchEvent(new WxtLocationChangeEvent(newUrl, oldUrl));
            oldUrl = newUrl;
          }
        }, 1e3);
      }
    };
  }
  var ContentScriptContext = (_b = class {
    constructor(contentScriptName, options) {
      __privateAdd(this, __ContentScriptContext_instances);
      __privateAdd(this, _isTopFrame, window.self === window.top);
      __privateAdd(this, _abortController);
      __privateAdd(this, _locationWatcher, createLocationWatcher(this));
      this.contentScriptName = contentScriptName;
      this.options = options;
      __privateSet(this, _abortController, new AbortController());
      if (__privateGet(this, _isTopFrame)) {
        __privateMethod(this, __ContentScriptContext_instances, stopOldScripts_fn).call(this);
      }
      this.setTimeout(() => {
        __privateMethod(this, __ContentScriptContext_instances, listenForNewerScripts_fn).call(this);
      });
    }
    get signal() {
      return __privateGet(this, _abortController).signal;
    }
    abort(reason) {
      return __privateGet(this, _abortController).abort(reason);
    }
    get isInvalid() {
      if (browser$1.runtime.id == null) {
        this.notifyInvalidated();
      }
      return this.signal.aborted;
    }
    get isValid() {
      return !this.isInvalid;
    }
    /**
     * Add a listener that is called when the content script's context is invalidated.
     *
     * @returns A function to remove the listener.
     *
     * @example
     * browser.runtime.onMessage.addListener(cb);
     * const removeInvalidatedListener = ctx.onInvalidated(() => {
     *   browser.runtime.onMessage.removeListener(cb);
     * })
     * // ...
     * removeInvalidatedListener();
     */
    onInvalidated(cb) {
      this.signal.addEventListener("abort", cb);
      return () => this.signal.removeEventListener("abort", cb);
    }
    /**
     * Return a promise that never resolves. Useful if you have an async function that shouldn't run
     * after the context is expired.
     *
     * @example
     * const getValueFromStorage = async () => {
     *   if (ctx.isInvalid) return ctx.block();
     *
     *   // ...
     * }
     */
    block() {
      return new Promise(() => {
      });
    }
    /**
     * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.
     */
    setInterval(handler, timeout) {
      const id = setInterval(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearInterval(id));
      return id;
    }
    /**
     * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.
     */
    setTimeout(handler, timeout) {
      const id = setTimeout(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearTimeout(id));
      return id;
    }
    /**
     * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when
     * invalidated.
     */
    requestAnimationFrame(callback) {
      const id = requestAnimationFrame((...args) => {
        if (this.isValid) callback(...args);
      });
      this.onInvalidated(() => cancelAnimationFrame(id));
      return id;
    }
    /**
     * Wrapper around `window.requestIdleCallback` that automatically cancels the request when
     * invalidated.
     */
    requestIdleCallback(callback, options) {
      const id = requestIdleCallback((...args) => {
        if (!this.signal.aborted) callback(...args);
      }, options);
      this.onInvalidated(() => cancelIdleCallback(id));
      return id;
    }
    /**
     * Call `target.addEventListener` and remove the event listener when the context is invalidated.
     *
     * Includes additional events useful for content scripts:
     *
     * - `"wxt:locationchange"` - Triggered when HTML5 history mode is used to change URL. Content
     *   scripts are not reloaded when navigating this way, so this can be used to reset the content
     *   script state on URL change, or run custom code.
     *
     * @example
     * ctx.addEventListener(document, "visibilitychange", () => {
     *   // ...
     * });
     * ctx.addEventListener(document, "wxt:locationchange", () => {
     *   // ...
     * });
     */
    addEventListener(target, type, handler, options) {
      var _a2;
      if (type === "wxt:locationchange") {
        if (this.isValid) __privateGet(this, _locationWatcher).run();
      }
      (_a2 = target.addEventListener) == null ? void 0 : _a2.call(
        target,
        type.startsWith("wxt:") ? getUniqueEventName(type) : type,
        // @ts-expect-error: Event don't match, but that's OK, EventTarget doesn't allow custom types in the callback
        handler,
        {
          ...options,
          signal: this.signal
        }
      );
    }
    /**
     * @internal
     * Abort the abort controller and execute all `onInvalidated` listeners.
     */
    notifyInvalidated() {
      this.abort("Content script context invalidated");
      logger$2.debug(`Content script "${this.contentScriptName}" context invalidated`);
    }
  }, _isTopFrame = new WeakMap(), _abortController = new WeakMap(), _locationWatcher = new WeakMap(), __ContentScriptContext_instances = new WeakSet(), stopOldScripts_fn = function() {
    window.postMessage({
      type: _b.SCRIPT_STARTED_MESSAGE_TYPE,
      contentScriptName: this.contentScriptName
    }, "*");
  }, listenForNewerScripts_fn = function() {
    const cb = (event) => {
      var _a2, _b2;
      if (((_a2 = event.data) == null ? void 0 : _a2.type) === _b.SCRIPT_STARTED_MESSAGE_TYPE && ((_b2 = event.data) == null ? void 0 : _b2.contentScriptName) === this.contentScriptName) {
        this.notifyInvalidated();
      }
    };
    addEventListener("message", cb);
    this.onInvalidated(() => removeEventListener("message", cb));
  }, __publicField(_b, "SCRIPT_STARTED_MESSAGE_TYPE", "wxt:content-script-started"), _b);
  async function createShadowRootUi(ctx, options) {
    var _a2;
    const css = [options.css ?? ""];
    if (((_a2 = ctx.options) == null ? void 0 : _a2.cssInjectionMode) === "ui") {
      const entryCss = await loadCss();
      css.push(entryCss.replaceAll(":root", ":host"));
    }
    const {
      isolatedElement: uiContainer,
      parentElement: shadowHost,
      shadow
    } = await createIsolatedElement({
      name: options.name,
      css: {
        textContent: css.join("\n").trim()
      },
      mode: options.mode ?? "open",
      isolateEvents: options.isolateEvents
    });
    shadowHost.setAttribute("data-wxt-shadow-root", "");
    let mounted;
    const mount = () => {
      mountUi(shadowHost, options);
      applyPosition(shadowHost, shadow.querySelector("html"), options);
      mounted = options.onMount(uiContainer, shadow, shadowHost);
    };
    const remove2 = () => {
      var _a3;
      (_a3 = options.onRemove) == null ? void 0 : _a3.call(options, mounted);
      shadowHost.remove();
      while (uiContainer.lastChild) uiContainer.removeChild(uiContainer.lastChild);
      mounted = void 0;
    };
    ctx.onInvalidated(remove2);
    return {
      shadow,
      shadowHost,
      uiContainer,
      mount,
      remove: remove2,
      get mounted() {
        return mounted;
      }
    };
  }
  function applyPosition(root2, positionedElement, options) {
    var _a2, _b2;
    if (options.position === "inline") return;
    if (options.zIndex != null) root2.style.zIndex = String(options.zIndex);
    root2.style.overflow = "visible";
    root2.style.position = "relative";
    root2.style.width = "0";
    root2.style.height = "0";
    root2.style.display = "block";
    if (positionedElement) {
      if (options.position === "overlay") {
        positionedElement.style.position = "absolute";
        if ((_a2 = options.alignment) == null ? void 0 : _a2.startsWith("bottom-")) positionedElement.style.bottom = "0";
        else positionedElement.style.top = "0";
        if ((_b2 = options.alignment) == null ? void 0 : _b2.endsWith("-right")) positionedElement.style.right = "0";
        else positionedElement.style.left = "0";
      } else {
        positionedElement.style.position = "fixed";
        positionedElement.style.top = "0";
        positionedElement.style.bottom = "0";
        positionedElement.style.left = "0";
        positionedElement.style.right = "0";
      }
    }
  }
  function getAnchor(options) {
    if (options.anchor == null) return document.body;
    let resolved = typeof options.anchor === "function" ? options.anchor() : options.anchor;
    if (typeof resolved === "string") return document.querySelector(resolved) ?? void 0;
    return resolved ?? void 0;
  }
  function mountUi(root2, options) {
    var _a2, _b2;
    const anchor = getAnchor(options);
    if (anchor == null) throw Error("Failed to mount content script UI: could not find anchor element");
    switch (options.append) {
      case void 0:
      case "last":
        anchor.append(root2);
        break;
      case "first":
        anchor.prepend(root2);
        break;
      case "replace":
        anchor.replaceWith(root2);
        break;
      case "after":
        (_a2 = anchor.parentElement) == null ? void 0 : _a2.insertBefore(root2, anchor.nextElementSibling);
        break;
      case "before":
        (_b2 = anchor.parentElement) == null ? void 0 : _b2.insertBefore(root2, anchor);
        break;
      default:
        options.append(anchor, root2);
        break;
    }
  }
  async function loadCss() {
    const url = browser$1.runtime.getURL(`/content-scripts/${"utils-csui"}.css`);
    try {
      const res = await fetch(url);
      return await res.text();
    } catch (err) {
      logger$2.warn(`Failed to load styles @ ${url}. Did you forget to import the stylesheet in your entrypoint?`, err);
      return "";
    }
  }
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$1 = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now = function() {
    return root$1.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result2 = func.apply(thisArg, args);
      return result2;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result2;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result2;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result2 : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result2;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var lodash_throttle = throttle;
  const throttle$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_throttle);
  const sendMessage = throttle$1(async (message, needResponse = true) => {
    var _a2, _b2, _c;
    const fromRuntime = message == null ? void 0 : message.source;
    let browser$12;
    try {
      if (fromRuntime !== "web") {
        const {
          browser: _browser
        } = await Promise.resolve().then(() => browser);
        browser$12 = _browser;
      }
      const waitForResponse = new Promise((resolve) => {
        var _a3;
        const listener = (response) => {
          var _a4, _b3;
          if ((response == null ? void 0 : response.name) === (message == null ? void 0 : message.name)) {
            if ((_a4 = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _a4.onMessage) {
              browser$12.runtime.onMessage.removeListener(listener);
            }
            if (fromRuntime !== "extension-background") {
              if (window == null ? void 0 : window.addEventListener) {
                window.removeEventListener("message", listener);
              }
            }
            resolve((response == null ? void 0 : response.currentTarget) ? (_b3 = response == null ? void 0 : response.data) == null ? void 0 : _b3.body : response == null ? void 0 : response.body);
          }
        };
        if ((_a3 = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _a3.onMessage) {
          browser$12.runtime.onMessage.addListener(listener);
        }
        if (fromRuntime !== "extension-background") {
          if (window == null ? void 0 : window.addEventListener) {
            window.addEventListener("message", listener);
          }
        }
      });
      if (["extension-sidepanel", "extension-background", "extension-popup"].includes(fromRuntime)) {
        const tabs = await browser$12.tabs.query({
          active: true,
          currentWindow: true
        });
        const activeTabId = (_a2 = tabs == null ? void 0 : tabs[0]) == null ? void 0 : _a2.id;
        if (activeTabId) {
          await browser$12.tabs.sendMessage(activeTabId, message);
        }
        if ((_b2 = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _b2.sendMessage) {
          await browser$12.runtime.sendMessage(message);
        }
      } else if (fromRuntime === "extension-csui") {
        if (window == null ? void 0 : window.postMessage) {
          window.postMessage(message, "*");
        }
        if ((_c = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _c.sendMessage) {
          await browser$12.runtime.sendMessage(message);
        }
      } else if (fromRuntime === "web") {
        if (window == null ? void 0 : window.postMessage) {
          window.postMessage(message, "*");
        }
      }
      if (needResponse) {
        const res = await waitForResponse;
        return res;
      }
    } catch (err) {
      console.log("sendMessage error", err);
    }
  }, 300);
  const onMessage = async (_callback, fromRuntime) => {
    var _a2;
    const callback = _callback;
    const windowCallback = (event) => {
      callback(event == null ? void 0 : event.data);
    };
    let browser$12;
    if (fromRuntime !== "web") {
      const {
        browser: _browser
      } = await Promise.resolve().then(() => browser);
      browser$12 = _browser;
    }
    if (["extension-sidepanel", "extension-background", "extension-popup"].includes(fromRuntime)) {
      browser$12.runtime.onMessage.addListener(callback);
    } else if (fromRuntime === "extension-csui") {
      if (window == null ? void 0 : window.addEventListener) {
        window.addEventListener("message", windowCallback);
      }
      if ((_a2 = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _a2.onMessage) {
        browser$12.runtime.onMessage.addListener(callback);
      }
    } else if (fromRuntime === "web") {
      if (window == null ? void 0 : window.addEventListener) {
        window.addEventListener("message", windowCallback);
      }
    }
    return () => {
      var _a3;
      if (["extension-sidepanel", "extension-background", "extension-popup"].includes(fromRuntime)) {
        browser$12.runtime.onMessage.removeListener(callback);
      } else if (fromRuntime === "extension-csui") {
        if (window == null ? void 0 : window.removeEventListener) {
          window.removeEventListener("message", windowCallback);
        }
        if ((_a3 = browser$12 == null ? void 0 : browser$12.runtime) == null ? void 0 : _a3.onMessage) {
          browser$12.runtime.onMessage.removeListener(callback);
        }
      } else if (fromRuntime === "web") {
        if (window == null ? void 0 : window.removeEventListener) {
          window.removeEventListener("message", windowCallback);
        }
      }
    };
  };
  _utils_csui;
  var Readability = { exports: {} };
  (function(module) {
    function Readability2(doc, options) {
      if (options && options.documentElement) {
        doc = options;
        options = arguments[2];
      } else if (!doc || !doc.documentElement) {
        throw new Error("First argument to Readability constructor should be a document object.");
      }
      options = options || {};
      this._doc = doc;
      this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
      this._articleTitle = null;
      this._articleByline = null;
      this._articleDir = null;
      this._articleSiteName = null;
      this._attempts = [];
      this._debug = !!options.debug;
      this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
      this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
      this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
      this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
      this._keepClasses = !!options.keepClasses;
      this._serializer = options.serializer || function(el) {
        return el.innerHTML;
      };
      this._disableJSONLD = !!options.disableJSONLD;
      this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
      this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
      if (this._debug) {
        let logNode = function(node) {
          if (node.nodeType == node.TEXT_NODE) {
            return `${node.nodeName} ("${node.textContent}")`;
          }
          let attrPairs = Array.from(node.attributes || [], function(attr) {
            return `${attr.name}="${attr.value}"`;
          }).join(" ");
          return `<${node.localName} ${attrPairs}>`;
        };
        this.log = function() {
          if (typeof console !== "undefined") {
            let args = Array.from(arguments, (arg) => {
              if (arg && arg.nodeType == this.ELEMENT_NODE) {
                return logNode(arg);
              }
              return arg;
            });
            args.unshift("Reader: (Readability)");
            console.log.apply(console, args);
          } else if (typeof dump !== "undefined") {
            var msg = Array.prototype.map.call(arguments, function(x) {
              return x && x.nodeName ? logNode(x) : x;
            }).join(" ");
            dump("Reader: (Readability) " + msg + "\n");
          }
        };
      } else {
        this.log = function() {
        };
      }
    }
    Readability2.prototype = {
      FLAG_STRIP_UNLIKELYS: 1,
      FLAG_WEIGHT_CLASSES: 2,
      FLAG_CLEAN_CONDITIONALLY: 4,
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
      // Max number of nodes supported by this parser. Default: 0 (no limit)
      DEFAULT_MAX_ELEMS_TO_PARSE: 0,
      // The number of top candidates to consider when analysing how
      // tight the competition is among candidates.
      DEFAULT_N_TOP_CANDIDATES: 5,
      // Element tags to score by default.
      DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
      // The default number of chars an article must have in order to return a result
      DEFAULT_CHAR_THRESHOLD: 500,
      // All of the regular expressions in use within readability.
      // Defined up here so we don't instantiate them repeatedly in loops.
      REGEXPS: {
        // NOTE: These two regular expressions are duplicated in
        // Readability-readerable.js. Please keep both copies in sync.
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
        positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
        negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
        extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
        byline: /byline|author|dateline|writtenby|p-author/i,
        replaceFonts: /<(\/?)font[^>]*>/gi,
        normalize: /\s{2,}/g,
        videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
        shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
        nextLink: /(next|weiter|continue|>([^\|]|$)|\u00bb([^\|]|$))/i,
        prevLink: /(prev|earl|old|new|<|\u00ab)/i,
        tokenize: /\W+/g,
        whitespace: /^\s*$/,
        hasContent: /\S$/,
        hashUrl: /^#.+/,
        srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
        b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
        // Commas as used in Latin, Sindhi, Chinese and various other scripts.
        // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
        commas: /\u002C|\u060C|\uFE50|\uFE10|\uFE11|\u2E41|\u2E34|\u2E32|\uFF0C/g,
        // See: https://schema.org/Article
        jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
      },
      UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
      DIV_TO_P_ELEMS: /* @__PURE__ */ new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
      ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
      PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
      DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
      // The commented out elements qualify as phrasing content but tend to be
      // removed by readability when put into paragraphs, so we ignore them here.
      PHRASING_ELEMS: [
        // "CANVAS", "IFRAME", "SVG", "VIDEO",
        "ABBR",
        "AUDIO",
        "B",
        "BDO",
        "BR",
        "BUTTON",
        "CITE",
        "CODE",
        "DATA",
        "DATALIST",
        "DFN",
        "EM",
        "EMBED",
        "I",
        "IMG",
        "INPUT",
        "KBD",
        "LABEL",
        "MARK",
        "MATH",
        "METER",
        "NOSCRIPT",
        "OBJECT",
        "OUTPUT",
        "PROGRESS",
        "Q",
        "RUBY",
        "SAMP",
        "SCRIPT",
        "SELECT",
        "SMALL",
        "SPAN",
        "STRONG",
        "SUB",
        "SUP",
        "TEXTAREA",
        "TIME",
        "VAR",
        "WBR"
      ],
      // These are the classes that readability sets itself.
      CLASSES_TO_PRESERVE: ["page"],
      // These are the list of HTML entities that need to be escaped.
      HTML_ESCAPE_MAP: {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'"
      },
      /**
       * Run any post-process modifications to article content as necessary.
       *
       * @param Element
       * @return void
      **/
      _postProcessContent: function(articleContent) {
        this._fixRelativeUris(articleContent);
        this._simplifyNestedElements(articleContent);
        if (!this._keepClasses) {
          this._cleanClasses(articleContent);
        }
      },
      /**
       * Iterates over a NodeList, calls `filterFn` for each node and removes node
       * if function returned `true`.
       *
       * If function is not passed, removes all the nodes in node list.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param Function filterFn the function to use as a filter
       * @return void
       */
      _removeNodes: function(nodeList, filterFn) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _removeNodes");
        }
        for (var i2 = nodeList.length - 1; i2 >= 0; i2--) {
          var node = nodeList[i2];
          var parentNode = node.parentNode;
          if (parentNode) {
            if (!filterFn || filterFn.call(this, node, i2, nodeList)) {
              parentNode.removeChild(node);
            }
          }
        }
      },
      /**
       * Iterates over a NodeList, and calls _setNodeTag for each node.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param String newTagName the new tag name to use
       * @return void
       */
      _replaceNodeTags: function(nodeList, newTagName) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _replaceNodeTags");
        }
        for (const node of nodeList) {
          this._setNodeTag(node, newTagName);
        }
      },
      /**
       * Iterate over a NodeList, which doesn't natively fully implement the Array
       * interface.
       *
       * For convenience, the current object context is applied to the provided
       * iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return void
       */
      _forEachNode: function(nodeList, fn) {
        Array.prototype.forEach.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, and return the first node that passes
       * the supplied test function
       *
       * For convenience, the current object context is applied to the provided
       * test function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The test function.
       * @return void
       */
      _findNode: function(nodeList, fn) {
        return Array.prototype.find.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if any of the provided iterate
       * function calls returns true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _someNode: function(nodeList, fn) {
        return Array.prototype.some.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if all of the provided iterate
       * function calls return true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _everyNode: function(nodeList, fn) {
        return Array.prototype.every.call(nodeList, fn, this);
      },
      /**
       * Concat all nodelists passed as arguments.
       *
       * @return ...NodeList
       * @return Array
       */
      _concatNodeLists: function() {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments);
        var nodeLists = args.map(function(list) {
          return slice.call(list);
        });
        return Array.prototype.concat.apply([], nodeLists);
      },
      _getAllNodesWithTag: function(node, tagNames) {
        if (node.querySelectorAll) {
          return node.querySelectorAll(tagNames.join(","));
        }
        return [].concat.apply([], tagNames.map(function(tag) {
          var collection = node.getElementsByTagName(tag);
          return Array.isArray(collection) ? collection : Array.from(collection);
        }));
      },
      /**
       * Removes the class="" attribute from every element in the given
       * subtree, except those that match CLASSES_TO_PRESERVE and
       * the classesToPreserve array from the options object.
       *
       * @param Element
       * @return void
       */
      _cleanClasses: function(node) {
        var classesToPreserve = this._classesToPreserve;
        var className = (node.getAttribute("class") || "").split(/\s+/).filter(function(cls) {
          return classesToPreserve.indexOf(cls) != -1;
        }).join(" ");
        if (className) {
          node.setAttribute("class", className);
        } else {
          node.removeAttribute("class");
        }
        for (node = node.firstElementChild; node; node = node.nextElementSibling) {
          this._cleanClasses(node);
        }
      },
      /**
       * Converts each <a> and <img> uri in the given element to an absolute URI,
       * ignoring #ref URIs.
       *
       * @param Element
       * @return void
       */
      _fixRelativeUris: function(articleContent) {
        var baseURI = this._doc.baseURI;
        var documentURI = this._doc.documentURI;
        function toAbsoluteURI(uri) {
          if (baseURI == documentURI && uri.charAt(0) == "#") {
            return uri;
          }
          try {
            return new URL(uri, baseURI).href;
          } catch (ex) {
          }
          return uri;
        }
        var links = this._getAllNodesWithTag(articleContent, ["a"]);
        this._forEachNode(links, function(link) {
          var href = link.getAttribute("href");
          if (href) {
            if (href.indexOf("javascript:") === 0) {
              if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                var text = this._doc.createTextNode(link.textContent);
                link.parentNode.replaceChild(text, link);
              } else {
                var container = this._doc.createElement("span");
                while (link.firstChild) {
                  container.appendChild(link.firstChild);
                }
                link.parentNode.replaceChild(container, link);
              }
            } else {
              link.setAttribute("href", toAbsoluteURI(href));
            }
          }
        });
        var medias = this._getAllNodesWithTag(articleContent, ["img", "picture", "figure", "video", "audio", "source"]);
        this._forEachNode(medias, function(media) {
          var src = media.getAttribute("src");
          var poster = media.getAttribute("poster");
          var srcset = media.getAttribute("srcset");
          if (src) {
            media.setAttribute("src", toAbsoluteURI(src));
          }
          if (poster) {
            media.setAttribute("poster", toAbsoluteURI(poster));
          }
          if (srcset) {
            var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {
              return toAbsoluteURI(p1) + (p2 || "") + p3;
            });
            media.setAttribute("srcset", newSrcset);
          }
        });
      },
      _simplifyNestedElements: function(articleContent) {
        var node = articleContent;
        while (node) {
          if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
            if (this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
              var child = node.children[0];
              for (var i2 = 0; i2 < node.attributes.length; i2++) {
                child.setAttribute(node.attributes[i2].name, node.attributes[i2].value);
              }
              node.parentNode.replaceChild(child, node);
              node = child;
              continue;
            }
          }
          node = this._getNextNode(node);
        }
      },
      /**
       * Get the article title as an H1.
       *
       * @return string
       **/
      _getArticleTitle: function() {
        var doc = this._doc;
        var curTitle = "";
        var origTitle = "";
        try {
          curTitle = origTitle = doc.title.trim();
          if (typeof curTitle !== "string") curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
        } catch (e) {
        }
        var titleHadHierarchicalSeparators = false;
        function wordCount(str) {
          return str.split(/\s+/).length;
        }
        if (/ [\|\-\\\/>\u00bb] /.test(curTitle)) {
          titleHadHierarchicalSeparators = / [\\\/>\u00bb] /.test(curTitle);
          curTitle = origTitle.replace(/(.*)[\|\-\\\/>\u00bb] .*/gi, "$1");
          if (wordCount(curTitle) < 3) curTitle = origTitle.replace(/[^\|\-\\\/>\u00bb]*[\|\-\\\/>\u00bb](.*)/gi, "$1");
        } else if (curTitle.indexOf(": ") !== -1) {
          var headings = this._concatNodeLists(doc.getElementsByTagName("h1"), doc.getElementsByTagName("h2"));
          var trimmedTitle = curTitle.trim();
          var match = this._someNode(headings, function(heading) {
            return heading.textContent.trim() === trimmedTitle;
          });
          if (!match) {
            curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
            if (wordCount(curTitle) < 3) {
              curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
            } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
              curTitle = origTitle;
            }
          }
        } else if (curTitle.length > 150 || curTitle.length < 15) {
          var hOnes = doc.getElementsByTagName("h1");
          if (hOnes.length === 1) curTitle = this._getInnerText(hOnes[0]);
        }
        curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
        var curTitleWordCount = wordCount(curTitle);
        if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>\u00bb]+/g, "")) - 1)) {
          curTitle = origTitle;
        }
        return curTitle;
      },
      /**
       * Prepare the HTML document for readability to scrape it.
       * This includes things like stripping javascript, CSS, and handling terrible markup.
       *
       * @return void
       **/
      _prepDocument: function() {
        var doc = this._doc;
        this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
        if (doc.body) {
          this._replaceBrs(doc.body);
        }
        this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
      },
      /**
       * Finds the next node, starting from the given node, and ignoring
       * whitespace in between. If the given node is an element, the same node is
       * returned.
       */
      _nextNode: function(node) {
        var next2 = node;
        while (next2 && next2.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next2.textContent)) {
          next2 = next2.nextSibling;
        }
        return next2;
      },
      /**
       * Replaces 2 or more successive <br> elements with a single <p>.
       * Whitespace between <br> elements are ignored. For example:
       *   <div>foo<br>bar<br> <br><br>abc</div>
       * will become:
       *   <div>foo<br>bar<p>abc</p></div>
       */
      _replaceBrs: function(elem) {
        this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
          var next2 = br.nextSibling;
          var replaced = false;
          while ((next2 = this._nextNode(next2)) && next2.tagName == "BR") {
            replaced = true;
            var brSibling = next2.nextSibling;
            next2.parentNode.removeChild(next2);
            next2 = brSibling;
          }
          if (replaced) {
            var p = this._doc.createElement("p");
            br.parentNode.replaceChild(p, br);
            next2 = p.nextSibling;
            while (next2) {
              if (next2.tagName == "BR") {
                var nextElem = this._nextNode(next2.nextSibling);
                if (nextElem && nextElem.tagName == "BR") break;
              }
              if (!this._isPhrasingContent(next2)) break;
              var sibling = next2.nextSibling;
              p.appendChild(next2);
              next2 = sibling;
            }
            while (p.lastChild && this._isWhitespace(p.lastChild)) {
              p.removeChild(p.lastChild);
            }
            if (p.parentNode.tagName === "P") this._setNodeTag(p.parentNode, "DIV");
          }
        });
      },
      _setNodeTag: function(node, tag) {
        this.log("_setNodeTag", node, tag);
        if (this._docJSDOMParser) {
          node.localName = tag.toLowerCase();
          node.tagName = tag.toUpperCase();
          return node;
        }
        var replacement = node.ownerDocument.createElement(tag);
        while (node.firstChild) {
          replacement.appendChild(node.firstChild);
        }
        node.parentNode.replaceChild(replacement, node);
        if (node.readability) replacement.readability = node.readability;
        for (var i2 = 0; i2 < node.attributes.length; i2++) {
          try {
            replacement.setAttribute(node.attributes[i2].name, node.attributes[i2].value);
          } catch (ex) {
          }
        }
        return replacement;
      },
      /**
       * Prepare the article node for display. Clean out any inline styles,
       * iframes, forms, strip extraneous <p> tags, etc.
       *
       * @param Element
       * @return void
       **/
      _prepArticle: function(articleContent) {
        this._cleanStyles(articleContent);
        this._markDataTables(articleContent);
        this._fixLazyImages(articleContent);
        this._cleanConditionally(articleContent, "form");
        this._cleanConditionally(articleContent, "fieldset");
        this._clean(articleContent, "object");
        this._clean(articleContent, "embed");
        this._clean(articleContent, "footer");
        this._clean(articleContent, "link");
        this._clean(articleContent, "aside");
        var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
        this._forEachNode(articleContent.children, function(topCandidate) {
          this._cleanMatchedNodes(topCandidate, function(node, matchString) {
            return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
          });
        });
        this._clean(articleContent, "iframe");
        this._clean(articleContent, "input");
        this._clean(articleContent, "textarea");
        this._clean(articleContent, "select");
        this._clean(articleContent, "button");
        this._cleanHeaders(articleContent);
        this._cleanConditionally(articleContent, "table");
        this._cleanConditionally(articleContent, "ul");
        this._cleanConditionally(articleContent, "div");
        this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
        this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
          var imgCount = paragraph.getElementsByTagName("img").length;
          var embedCount = paragraph.getElementsByTagName("embed").length;
          var objectCount = paragraph.getElementsByTagName("object").length;
          var iframeCount = paragraph.getElementsByTagName("iframe").length;
          var totalCount = imgCount + embedCount + objectCount + iframeCount;
          return totalCount === 0 && !this._getInnerText(paragraph, false);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br) {
          var next2 = this._nextNode(br.nextSibling);
          if (next2 && next2.tagName == "P") br.parentNode.removeChild(br);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
          var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
          if (this._hasSingleTagInsideElement(tbody, "TR")) {
            var row = tbody.firstElementChild;
            if (this._hasSingleTagInsideElement(row, "TD")) {
              var cell2 = row.firstElementChild;
              cell2 = this._setNodeTag(cell2, this._everyNode(cell2.childNodes, this._isPhrasingContent) ? "P" : "DIV");
              table.parentNode.replaceChild(cell2, table);
            }
          }
        });
      },
      /**
       * Initialize a node with the readability object. Also checks the
       * className/id for special names to add to its score.
       *
       * @param Element
       * @return void
      **/
      _initializeNode: function(node) {
        node.readability = {
          "contentScore": 0
        };
        switch (node.tagName) {
          case "DIV":
            node.readability.contentScore += 5;
            break;
          case "PRE":
          case "TD":
          case "BLOCKQUOTE":
            node.readability.contentScore += 3;
            break;
          case "ADDRESS":
          case "OL":
          case "UL":
          case "DL":
          case "DD":
          case "DT":
          case "LI":
          case "FORM":
            node.readability.contentScore -= 3;
            break;
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
          case "TH":
            node.readability.contentScore -= 5;
            break;
        }
        node.readability.contentScore += this._getClassWeight(node);
      },
      _removeAndGetNext: function(node) {
        var nextNode = this._getNextNode(node, true);
        node.parentNode.removeChild(node);
        return nextNode;
      },
      /**
       * Traverse the DOM from node to node, starting at the node passed in.
       * Pass true for the second parameter to indicate this node itself
       * (and its kids) are going away, and we want the next node over.
       *
       * Calling this in a loop will traverse the DOM depth-first.
       */
      _getNextNode: function(node, ignoreSelfAndKids) {
        if (!ignoreSelfAndKids && node.firstElementChild) {
          return node.firstElementChild;
        }
        if (node.nextElementSibling) {
          return node.nextElementSibling;
        }
        do {
          node = node.parentNode;
        } while (node && !node.nextElementSibling);
        return node && node.nextElementSibling;
      },
      // compares second text to first one
      // 1 = same text, 0 = completely different text
      // works the way that it splits both texts into words and then finds words that are unique in second text
      // the result is given by the lower length of unique parts
      _textSimilarity: function(textA, textB) {
        var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        if (!tokensA.length || !tokensB.length) {
          return 0;
        }
        var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
        var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
        return 1 - distanceB;
      },
      _checkByline: function(node, matchString) {
        if (this._articleByline) {
          return false;
        }
        if (node.getAttribute !== void 0) {
          var rel = node.getAttribute("rel");
          var itemprop = node.getAttribute("itemprop");
        }
        if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
          this._articleByline = node.textContent.trim();
          return true;
        }
        return false;
      },
      _getNodeAncestors: function(node, maxDepth) {
        maxDepth = maxDepth || 0;
        var i2 = 0, ancestors = [];
        while (node.parentNode) {
          ancestors.push(node.parentNode);
          if (maxDepth && ++i2 === maxDepth) break;
          node = node.parentNode;
        }
        return ancestors;
      },
      /***
       * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
       *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
       *
       * @param page a document to run upon. Needs to be a full document, complete with body.
       * @return Element
      **/
      _grabArticle: function(page) {
        this.log("**** grabArticle ****");
        var doc = this._doc;
        var isPaging = page !== null;
        page = page ? page : this._doc.body;
        if (!page) {
          this.log("No body found in document. Abort.");
          return null;
        }
        var pageCacheHtml = page.innerHTML;
        while (true) {
          this.log("Starting grabArticle loop");
          var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
          var elementsToScore = [];
          var node = this._doc.documentElement;
          let shouldRemoveTitleHeader = true;
          while (node) {
            if (node.tagName === "HTML") {
              this._articleLang = node.getAttribute("lang");
            }
            var matchString = node.className + " " + node.id;
            if (!this._isProbablyVisible(node)) {
              this.log("Removing hidden node - " + matchString);
              node = this._removeAndGetNext(node);
              continue;
            }
            if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this._checkByline(node, matchString)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
              this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
              shouldRemoveTitleHeader = false;
              node = this._removeAndGetNext(node);
              continue;
            }
            if (stripUnlikelyCandidates) {
              if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                this.log("Removing unlikely candidate - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
            }
            if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
              elementsToScore.push(node);
            }
            if (node.tagName === "DIV") {
              var p = null;
              var childNode = node.firstChild;
              while (childNode) {
                var nextSibling = childNode.nextSibling;
                if (this._isPhrasingContent(childNode)) {
                  if (p !== null) {
                    p.appendChild(childNode);
                  } else if (!this._isWhitespace(childNode)) {
                    p = doc.createElement("p");
                    node.replaceChild(p, childNode);
                    p.appendChild(childNode);
                  }
                } else if (p !== null) {
                  while (p.lastChild && this._isWhitespace(p.lastChild)) {
                    p.removeChild(p.lastChild);
                  }
                  p = null;
                }
                childNode = nextSibling;
              }
              if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                var newNode = node.children[0];
                node.parentNode.replaceChild(newNode, node);
                node = newNode;
                elementsToScore.push(node);
              } else if (!this._hasChildBlockElement(node)) {
                node = this._setNodeTag(node, "P");
                elementsToScore.push(node);
              }
            }
            node = this._getNextNode(node);
          }
          var candidates = [];
          this._forEachNode(elementsToScore, function(elementToScore) {
            if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined") return;
            var innerText = this._getInnerText(elementToScore);
            if (innerText.length < 25) return;
            var ancestors2 = this._getNodeAncestors(elementToScore, 5);
            if (ancestors2.length === 0) return;
            var contentScore = 0;
            contentScore += 1;
            contentScore += innerText.split(this.REGEXPS.commas).length;
            contentScore += Math.min(Math.floor(innerText.length / 100), 3);
            this._forEachNode(ancestors2, function(ancestor, level) {
              if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined") return;
              if (typeof ancestor.readability === "undefined") {
                this._initializeNode(ancestor);
                candidates.push(ancestor);
              }
              if (level === 0) var scoreDivider = 1;
              else if (level === 1) scoreDivider = 2;
              else scoreDivider = level * 3;
              ancestor.readability.contentScore += contentScore / scoreDivider;
            });
          });
          var topCandidates = [];
          for (var c = 0, cl = candidates.length; c < cl; c += 1) {
            var candidate = candidates[c];
            var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
            candidate.readability.contentScore = candidateScore;
            this.log("Candidate:", candidate, "with score " + candidateScore);
            for (var t = 0; t < this._nbTopCandidates; t++) {
              var aTopCandidate = topCandidates[t];
              if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                topCandidates.splice(t, 0, candidate);
                if (topCandidates.length > this._nbTopCandidates) topCandidates.pop();
                break;
              }
            }
          }
          var topCandidate = topCandidates[0] || null;
          var neededToCreateTopCandidate = false;
          var parentOfTopCandidate;
          if (topCandidate === null || topCandidate.tagName === "BODY") {
            topCandidate = doc.createElement("DIV");
            neededToCreateTopCandidate = true;
            while (page.firstChild) {
              this.log("Moving child out:", page.firstChild);
              topCandidate.appendChild(page.firstChild);
            }
            page.appendChild(topCandidate);
            this._initializeNode(topCandidate);
          } else if (topCandidate) {
            var alternativeCandidateAncestors = [];
            for (var i2 = 1; i2 < topCandidates.length; i2++) {
              if (topCandidates[i2].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i2]));
              }
            }
            var MINIMUM_TOPCANDIDATES = 3;
            if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName !== "BODY") {
                var listsContainingThisAncestor = 0;
                for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                  listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
                }
                if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
            parentOfTopCandidate = topCandidate.parentNode;
            var lastScore = topCandidate.readability.contentScore;
            var scoreThreshold = lastScore / 3;
            while (parentOfTopCandidate.tagName !== "BODY") {
              if (!parentOfTopCandidate.readability) {
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
                continue;
              }
              var parentScore = parentOfTopCandidate.readability.contentScore;
              if (parentScore < scoreThreshold) break;
              if (parentScore > lastScore) {
                topCandidate = parentOfTopCandidate;
                break;
              }
              lastScore = parentOfTopCandidate.readability.contentScore;
              parentOfTopCandidate = parentOfTopCandidate.parentNode;
            }
            parentOfTopCandidate = topCandidate.parentNode;
            while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
              topCandidate = parentOfTopCandidate;
              parentOfTopCandidate = topCandidate.parentNode;
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
          }
          var articleContent = doc.createElement("DIV");
          if (isPaging) articleContent.id = "readability-content";
          var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
          parentOfTopCandidate = topCandidate.parentNode;
          var siblings = parentOfTopCandidate.children;
          for (var s = 0, sl = siblings.length; s < sl; s++) {
            var sibling = siblings[s];
            var append = false;
            this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
            this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
            if (sibling === topCandidate) {
              append = true;
            } else {
              var contentBonus = 0;
              if (sibling.className === topCandidate.className && topCandidate.className !== "") contentBonus += topCandidate.readability.contentScore * 0.2;
              if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                append = true;
              } else if (sibling.nodeName === "P") {
                var linkDensity = this._getLinkDensity(sibling);
                var nodeContent = this._getInnerText(sibling);
                var nodeLength = nodeContent.length;
                if (nodeLength > 80 && linkDensity < 0.25) {
                  append = true;
                } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                  append = true;
                }
              }
            }
            if (append) {
              this.log("Appending node:", sibling);
              if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
                this.log("Altering sibling:", sibling, "to div.");
                sibling = this._setNodeTag(sibling, "DIV");
              }
              articleContent.appendChild(sibling);
              siblings = parentOfTopCandidate.children;
              s -= 1;
              sl -= 1;
            }
          }
          if (this._debug) this.log("Article content pre-prep: " + articleContent.innerHTML);
          this._prepArticle(articleContent);
          if (this._debug) this.log("Article content post-prep: " + articleContent.innerHTML);
          if (neededToCreateTopCandidate) {
            topCandidate.id = "readability-page-1";
            topCandidate.className = "page";
          } else {
            var div = doc.createElement("DIV");
            div.id = "readability-page-1";
            div.className = "page";
            while (articleContent.firstChild) {
              div.appendChild(articleContent.firstChild);
            }
            articleContent.appendChild(div);
          }
          if (this._debug) this.log("Article content after paging: " + articleContent.innerHTML);
          var parseSuccessful = true;
          var textLength = this._getInnerText(articleContent, true).length;
          if (textLength < this._charThreshold) {
            parseSuccessful = false;
            page.innerHTML = pageCacheHtml;
            if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
              this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
              this._attempts.push({
                articleContent,
                textLength
              });
            } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
              this._removeFlag(this.FLAG_WEIGHT_CLASSES);
              this._attempts.push({
                articleContent,
                textLength
              });
            } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
              this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
              this._attempts.push({
                articleContent,
                textLength
              });
            } else {
              this._attempts.push({
                articleContent,
                textLength
              });
              this._attempts.sort(function(a, b) {
                return b.textLength - a.textLength;
              });
              if (!this._attempts[0].textLength) {
                return null;
              }
              articleContent = this._attempts[0].articleContent;
              parseSuccessful = true;
            }
          }
          if (parseSuccessful) {
            var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
            this._someNode(ancestors, function(ancestor) {
              if (!ancestor.tagName) return false;
              var articleDir = ancestor.getAttribute("dir");
              if (articleDir) {
                this._articleDir = articleDir;
                return true;
              }
              return false;
            });
            return articleContent;
          }
        }
      },
      /**
       * Check whether the input string could be a byline.
       * This verifies that the input is a string, and that the length
       * is less than 100 chars.
       *
       * @param possibleByline {string} - a string to check whether its a byline.
       * @return Boolean - whether the input string is a byline.
       */
      _isValidByline: function(byline) {
        if (typeof byline == "string" || byline instanceof String) {
          byline = byline.trim();
          return byline.length > 0 && byline.length < 100;
        }
        return false;
      },
      /**
       * Converts some of the common HTML entities in string to their corresponding characters.
       *
       * @param str {string} - a string to unescape.
       * @return string without HTML entity.
       */
      _unescapeHtmlEntities: function(str) {
        if (!str) {
          return str;
        }
        var htmlEscapeMap = this.HTML_ESCAPE_MAP;
        return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
          return htmlEscapeMap[tag];
        }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {
          var num = parseInt(hex || numStr, hex ? 16 : 10);
          return String.fromCharCode(num);
        });
      },
      /**
       * Try to extract metadata from JSON-LD object.
       * For now, only Schema.org objects of type Article or its subtypes are supported.
       * @return Object with any metadata that could be extracted (possibly none)
       */
      _getJSONLD: function(doc) {
        var scripts = this._getAllNodesWithTag(doc, ["script"]);
        var metadata;
        this._forEachNode(scripts, function(jsonLdElement) {
          if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
            try {
              var content = jsonLdElement.textContent.replace(/^\s*<!\[CDATA\[|\]\]>\s*$/g, "");
              var parsed = JSON.parse(content);
              if (!parsed["@context"] || !parsed["@context"].match(/^https?\:\/\/schema\.org$/)) {
                return;
              }
              if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                parsed = parsed["@graph"].find(function(it) {
                  return (it["@type"] || "").match(this.REGEXPS.jsonLdArticleTypes);
                });
              }
              if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                return;
              }
              metadata = {};
              if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
                var title = this._getArticleTitle();
                var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
                var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
                if (headlineMatches && !nameMatches) {
                  metadata.title = parsed.headline;
                } else {
                  metadata.title = parsed.name;
                }
              } else if (typeof parsed.name === "string") {
                metadata.title = parsed.name.trim();
              } else if (typeof parsed.headline === "string") {
                metadata.title = parsed.headline.trim();
              }
              if (parsed.author) {
                if (typeof parsed.author.name === "string") {
                  metadata.byline = parsed.author.name.trim();
                } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                  metadata.byline = parsed.author.filter(function(author) {
                    return author && typeof author.name === "string";
                  }).map(function(author) {
                    return author.name.trim();
                  }).join(", ");
                }
              }
              if (typeof parsed.description === "string") {
                metadata.excerpt = parsed.description.trim();
              }
              if (parsed.publisher && typeof parsed.publisher.name === "string") {
                metadata.siteName = parsed.publisher.name.trim();
              }
              if (typeof parsed.datePublished === "string") {
                metadata.datePublished = parsed.datePublished.trim();
              }
              return;
            } catch (err) {
              this.log(err.message);
            }
          }
        });
        return metadata ? metadata : {};
      },
      /**
       * Attempts to get excerpt and byline metadata for the article.
       *
       * @param {Object} jsonld \u2014 object containing any metadata that
       * could be extracted from JSON-LD object.
       *
       * @return Object with optional "excerpt" and "byline" properties
       */
      _getArticleMetadata: function(jsonld) {
        var metadata = {};
        var values = {};
        var metaElements = this._doc.getElementsByTagName("meta");
        var propertyPattern = /\s*(article|dc|dcterm|og|twitter)\s*:\s*(author|creator|description|published_time|title|site_name)\s*/gi;
        var namePattern = /^\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\s*[\.:]\s*)?(author|creator|description|title|site_name)\s*$/i;
        this._forEachNode(metaElements, function(element) {
          var elementName = element.getAttribute("name");
          var elementProperty = element.getAttribute("property");
          var content = element.getAttribute("content");
          if (!content) {
            return;
          }
          var matches = null;
          var name = null;
          if (elementProperty) {
            matches = elementProperty.match(propertyPattern);
            if (matches) {
              name = matches[0].toLowerCase().replace(/\s/g, "");
              values[name] = content.trim();
            }
          }
          if (!matches && elementName && namePattern.test(elementName)) {
            name = elementName;
            if (content) {
              name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
              values[name] = content.trim();
            }
          }
        });
        metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
        if (!metadata.title) {
          metadata.title = this._getArticleTitle();
        }
        metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
        metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
        metadata.siteName = jsonld.siteName || values["og:site_name"];
        metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || null;
        metadata.title = this._unescapeHtmlEntities(metadata.title);
        metadata.byline = this._unescapeHtmlEntities(metadata.byline);
        metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
        metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
        metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
        return metadata;
      },
      /**
       * Check if node is image, or if node contains exactly only one image
       * whether as a direct child or as its descendants.
       *
       * @param Element
      **/
      _isSingleImage: function(node) {
        if (node.tagName === "IMG") {
          return true;
        }
        if (node.children.length !== 1 || node.textContent.trim() !== "") {
          return false;
        }
        return this._isSingleImage(node.children[0]);
      },
      /**
       * Find all <noscript> that are located after <img> nodes, and which contain only one
       * <img> element. Replace the first image with the image from inside the <noscript> tag,
       * and remove the <noscript> tag. This improves the quality of the images we use on
       * some sites (e.g. Medium).
       *
       * @param Element
      **/
      _unwrapNoscriptImages: function(doc) {
        var imgs = Array.from(doc.getElementsByTagName("img"));
        this._forEachNode(imgs, function(img) {
          for (var i2 = 0; i2 < img.attributes.length; i2++) {
            var attr = img.attributes[i2];
            switch (attr.name) {
              case "src":
              case "srcset":
              case "data-src":
              case "data-srcset":
                return;
            }
            if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
              return;
            }
          }
          img.parentNode.removeChild(img);
        });
        var noscripts = Array.from(doc.getElementsByTagName("noscript"));
        this._forEachNode(noscripts, function(noscript) {
          var tmp = doc.createElement("div");
          tmp.innerHTML = noscript.innerHTML;
          if (!this._isSingleImage(tmp)) {
            return;
          }
          var prevElement = noscript.previousElementSibling;
          if (prevElement && this._isSingleImage(prevElement)) {
            var prevImg = prevElement;
            if (prevImg.tagName !== "IMG") {
              prevImg = prevElement.getElementsByTagName("img")[0];
            }
            var newImg = tmp.getElementsByTagName("img")[0];
            for (var i2 = 0; i2 < prevImg.attributes.length; i2++) {
              var attr = prevImg.attributes[i2];
              if (attr.value === "") {
                continue;
              }
              if (attr.name === "src" || attr.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                if (newImg.getAttribute(attr.name) === attr.value) {
                  continue;
                }
                var attrName = attr.name;
                if (newImg.hasAttribute(attrName)) {
                  attrName = "data-old-" + attrName;
                }
                newImg.setAttribute(attrName, attr.value);
              }
            }
            noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
          }
        });
      },
      /**
       * Removes script tags from the document.
       *
       * @param Element
      **/
      _removeScripts: function(doc) {
        this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
      },
      /**
       * Check if this node has only whitespace and a single element with given tag
       * Returns false if the DIV node contains non-empty text nodes
       * or if it contains no element with given tag or more than 1 element.
       *
       * @param Element
       * @param string tag of child element
      **/
      _hasSingleTagInsideElement: function(element, tag) {
        if (element.children.length != 1 || element.children[0].tagName !== tag) {
          return false;
        }
        return !this._someNode(element.childNodes, function(node) {
          return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
        });
      },
      _isElementWithoutContent: function(node) {
        return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
      },
      /**
       * Determine whether element has any children block level elements.
       *
       * @param Element
       */
      _hasChildBlockElement: function(element) {
        return this._someNode(element.childNodes, function(node) {
          return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
        });
      },
      /***
       * Determine if a node qualifies as phrasing content.
       * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
      **/
      _isPhrasingContent: function(node) {
        return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
      },
      _isWhitespace: function(node) {
        return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
      },
      /**
       * Get the inner text of a node - cross browser compatibly.
       * This also strips out any excess whitespace to be found.
       *
       * @param Element
       * @param Boolean normalizeSpaces (default: true)
       * @return string
      **/
      _getInnerText: function(e, normalizeSpaces) {
        normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
        var textContent = e.textContent.trim();
        if (normalizeSpaces) {
          return textContent.replace(this.REGEXPS.normalize, " ");
        }
        return textContent;
      },
      /**
       * Get the number of times a string s appears in the node e.
       *
       * @param Element
       * @param string - what to split on. Default is ","
       * @return number (integer)
      **/
      _getCharCount: function(e, s) {
        s = s || ",";
        return this._getInnerText(e).split(s).length - 1;
      },
      /**
       * Remove the style attribute on every e and under.
       * TODO: Test if getElementsByTagName(*) is faster.
       *
       * @param Element
       * @return void
      **/
      _cleanStyles: function(e) {
        if (!e || e.tagName.toLowerCase() === "svg") return;
        for (var i2 = 0; i2 < this.PRESENTATIONAL_ATTRIBUTES.length; i2++) {
          e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i2]);
        }
        if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
          e.removeAttribute("width");
          e.removeAttribute("height");
        }
        var cur = e.firstElementChild;
        while (cur !== null) {
          this._cleanStyles(cur);
          cur = cur.nextElementSibling;
        }
      },
      /**
       * Get the density of links as a percentage of the content
       * This is the amount of text that is inside a link divided by the total text in the node.
       *
       * @param Element
       * @return number (float)
      **/
      _getLinkDensity: function(element) {
        var textLength = this._getInnerText(element).length;
        if (textLength === 0) return 0;
        var linkLength = 0;
        this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
          var href = linkNode.getAttribute("href");
          var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
          linkLength += this._getInnerText(linkNode).length * coefficient;
        });
        return linkLength / textLength;
      },
      /**
       * Get an elements class/id weight. Uses regular expressions to tell if this
       * element looks good or bad.
       *
       * @param Element
       * @return number (Integer)
      **/
      _getClassWeight: function(e) {
        if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) return 0;
        var weight = 0;
        if (typeof e.className === "string" && e.className !== "") {
          if (this.REGEXPS.negative.test(e.className)) weight -= 25;
          if (this.REGEXPS.positive.test(e.className)) weight += 25;
        }
        if (typeof e.id === "string" && e.id !== "") {
          if (this.REGEXPS.negative.test(e.id)) weight -= 25;
          if (this.REGEXPS.positive.test(e.id)) weight += 25;
        }
        return weight;
      },
      /**
       * Clean a node of all elements of type "tag".
       * (Unless it's a youtube/vimeo video. People love movies.)
       *
       * @param Element
       * @param string tag to clean
       * @return void
       **/
      _clean: function(e, tag) {
        var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
        this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {
          if (isEmbed) {
            for (var i2 = 0; i2 < element.attributes.length; i2++) {
              if (this._allowedVideoRegex.test(element.attributes[i2].value)) {
                return false;
              }
            }
            if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
              return false;
            }
          }
          return true;
        });
      },
      /**
       * Check if a given node has one of its ancestor tag name matching the
       * provided one.
       * @param  HTMLElement node
       * @param  String      tagName
       * @param  Number      maxDepth
       * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
       * @return Boolean
       */
      _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {
        maxDepth = maxDepth || 3;
        tagName = tagName.toUpperCase();
        var depth = 0;
        while (node.parentNode) {
          if (maxDepth > 0 && depth > maxDepth) return false;
          if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode))) return true;
          node = node.parentNode;
          depth++;
        }
        return false;
      },
      /**
       * Return an object indicating how many rows and columns this table has.
       */
      _getRowAndColumnCount: function(table) {
        var rows = 0;
        var columns = 0;
        var trs = table.getElementsByTagName("tr");
        for (var i2 = 0; i2 < trs.length; i2++) {
          var rowspan = trs[i2].getAttribute("rowspan") || 0;
          if (rowspan) {
            rowspan = parseInt(rowspan, 10);
          }
          rows += rowspan || 1;
          var columnsInThisRow = 0;
          var cells = trs[i2].getElementsByTagName("td");
          for (var j = 0; j < cells.length; j++) {
            var colspan = cells[j].getAttribute("colspan") || 0;
            if (colspan) {
              colspan = parseInt(colspan, 10);
            }
            columnsInThisRow += colspan || 1;
          }
          columns = Math.max(columns, columnsInThisRow);
        }
        return {
          rows,
          columns
        };
      },
      /**
       * Look for 'data' (as opposed to 'layout') tables, for which we use
       * similar checks as
       * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
       */
      _markDataTables: function(root2) {
        var tables2 = root2.getElementsByTagName("table");
        for (var i2 = 0; i2 < tables2.length; i2++) {
          var table = tables2[i2];
          var role = table.getAttribute("role");
          if (role == "presentation") {
            table._readabilityDataTable = false;
            continue;
          }
          var datatable = table.getAttribute("datatable");
          if (datatable == "0") {
            table._readabilityDataTable = false;
            continue;
          }
          var summary = table.getAttribute("summary");
          if (summary) {
            table._readabilityDataTable = true;
            continue;
          }
          var caption = table.getElementsByTagName("caption")[0];
          if (caption && caption.childNodes.length > 0) {
            table._readabilityDataTable = true;
            continue;
          }
          var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
          var descendantExists = function(tag) {
            return !!table.getElementsByTagName(tag)[0];
          };
          if (dataTableDescendants.some(descendantExists)) {
            this.log("Data table because found data-y descendant");
            table._readabilityDataTable = true;
            continue;
          }
          if (table.getElementsByTagName("table")[0]) {
            table._readabilityDataTable = false;
            continue;
          }
          var sizeInfo = this._getRowAndColumnCount(table);
          if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
            table._readabilityDataTable = true;
            continue;
          }
          table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
        }
      },
      /* convert images and figures that have properties like data-src into images that can be loaded without JS */
      _fixLazyImages: function(root2) {
        this._forEachNode(this._getAllNodesWithTag(root2, ["img", "picture", "figure"]), function(elem) {
          if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
            var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
            if (parts[1] === "image/svg+xml") {
              return;
            }
            var srcCouldBeRemoved = false;
            for (var i2 = 0; i2 < elem.attributes.length; i2++) {
              var attr = elem.attributes[i2];
              if (attr.name === "src") {
                continue;
              }
              if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                srcCouldBeRemoved = true;
                break;
              }
            }
            if (srcCouldBeRemoved) {
              var b64starts = elem.src.search(/base64\s*/i) + 7;
              var b64length = elem.src.length - b64starts;
              if (b64length < 133) {
                elem.removeAttribute("src");
              }
            }
          }
          if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
            return;
          }
          for (var j = 0; j < elem.attributes.length; j++) {
            attr = elem.attributes[j];
            if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
              continue;
            }
            var copyTo = null;
            if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr.value)) {
              copyTo = "srcset";
            } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr.value)) {
              copyTo = "src";
            }
            if (copyTo) {
              if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                elem.setAttribute(copyTo, attr.value);
              } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                var img = this._doc.createElement("img");
                img.setAttribute(copyTo, attr.value);
                elem.appendChild(img);
              }
            }
          }
        });
      },
      _getTextDensity: function(e, tags) {
        var textLength = this._getInnerText(e, true).length;
        if (textLength === 0) {
          return 0;
        }
        var childrenLength = 0;
        var children = this._getAllNodesWithTag(e, tags);
        this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);
        return childrenLength / textLength;
      },
      /**
       * Clean an element of all tags of type "tag" if they look fishy.
       * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
       *
       * @return void
       **/
      _cleanConditionally: function(e, tag) {
        if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) return;
        this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
          var isDataTable = function(t) {
            return t._readabilityDataTable;
          };
          var isList = tag === "ul" || tag === "ol";
          if (!isList) {
            var listLength = 0;
            var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
            this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
            isList = listLength / this._getInnerText(node).length > 0.9;
          }
          if (tag === "table" && isDataTable(node)) {
            return false;
          }
          if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
            return false;
          }
          if (this._hasAncestorTag(node, "code")) {
            return false;
          }
          var weight = this._getClassWeight(node);
          this.log("Cleaning Conditionally", node);
          var contentScore = 0;
          if (weight + contentScore < 0) {
            return true;
          }
          if (this._getCharCount(node, ",") < 10) {
            var p = node.getElementsByTagName("p").length;
            var img = node.getElementsByTagName("img").length;
            var li = node.getElementsByTagName("li").length - 100;
            var input = node.getElementsByTagName("input").length;
            var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
            var embedCount = 0;
            var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
            for (var i2 = 0; i2 < embeds.length; i2++) {
              for (var j = 0; j < embeds[i2].attributes.length; j++) {
                if (this._allowedVideoRegex.test(embeds[i2].attributes[j].value)) {
                  return false;
                }
              }
              if (embeds[i2].tagName === "object" && this._allowedVideoRegex.test(embeds[i2].innerHTML)) {
                return false;
              }
              embedCount++;
            }
            var linkDensity = this._getLinkDensity(node);
            var contentLength = this._getInnerText(node).length;
            var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || embedCount === 1 && contentLength < 75 || embedCount > 1;
            if (isList && haveToRemove) {
              for (var x = 0; x < node.children.length; x++) {
                let child = node.children[x];
                if (child.children.length > 1) {
                  return haveToRemove;
                }
              }
              let li_count = node.getElementsByTagName("li").length;
              if (img == li_count) {
                return false;
              }
            }
            return haveToRemove;
          }
          return false;
        });
      },
      /**
       * Clean out elements that match the specified conditions
       *
       * @param Element
       * @param Function determines whether a node should be removed
       * @return void
       **/
      _cleanMatchedNodes: function(e, filter) {
        var endOfSearchMarkerNode = this._getNextNode(e, true);
        var next2 = this._getNextNode(e);
        while (next2 && next2 != endOfSearchMarkerNode) {
          if (filter.call(this, next2, next2.className + " " + next2.id)) {
            next2 = this._removeAndGetNext(next2);
          } else {
            next2 = this._getNextNode(next2);
          }
        }
      },
      /**
       * Clean out spurious headers from an Element.
       *
       * @param Element
       * @return void
      **/
      _cleanHeaders: function(e) {
        let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
        this._removeNodes(headingNodes, function(node) {
          let shouldRemove = this._getClassWeight(node) < 0;
          if (shouldRemove) {
            this.log("Removing header with low class weight:", node);
          }
          return shouldRemove;
        });
      },
      /**
       * Check if this node is an H1 or H2 element whose content is mostly
       * the same as the article title.
       *
       * @param Element  the node to check.
       * @return boolean indicating whether this is a title-like header.
       */
      _headerDuplicatesTitle: function(node) {
        if (node.tagName != "H1" && node.tagName != "H2") {
          return false;
        }
        var heading = this._getInnerText(node, false);
        this.log("Evaluating similarity of header:", heading, this._articleTitle);
        return this._textSimilarity(this._articleTitle, heading) > 0.75;
      },
      _flagIsActive: function(flag) {
        return (this._flags & flag) > 0;
      },
      _removeFlag: function(flag) {
        this._flags = this._flags & ~flag;
      },
      _isProbablyVisible: function(node) {
        return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
      },
      /**
       * Runs readability.
       *
       * Workflow:
       *  1. Prep the document by removing script tags, css, etc.
       *  2. Build readability's DOM tree.
       *  3. Grab the article content from the current dom tree.
       *  4. Replace the current DOM tree with the new one.
       *  5. Read peacefully.
       *
       * @return void
       **/
      parse: function() {
        if (this._maxElemsToParse > 0) {
          var numTags = this._doc.getElementsByTagName("*").length;
          if (numTags > this._maxElemsToParse) {
            throw new Error("Aborting parsing document; " + numTags + " elements found");
          }
        }
        this._unwrapNoscriptImages(this._doc);
        var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
        this._removeScripts(this._doc);
        this._prepDocument();
        var metadata = this._getArticleMetadata(jsonLd);
        this._articleTitle = metadata.title;
        var articleContent = this._grabArticle();
        if (!articleContent) return null;
        this.log("Grabbed: " + articleContent.innerHTML);
        this._postProcessContent(articleContent);
        if (!metadata.excerpt) {
          var paragraphs = articleContent.getElementsByTagName("p");
          if (paragraphs.length > 0) {
            metadata.excerpt = paragraphs[0].textContent.trim();
          }
        }
        var textContent = articleContent.textContent;
        return {
          title: this._articleTitle,
          byline: metadata.byline || this._articleByline,
          dir: this._articleDir,
          lang: this._articleLang,
          content: this._serializer(articleContent),
          textContent,
          length: textContent.length,
          excerpt: metadata.excerpt,
          siteName: metadata.siteName || this._articleSiteName,
          publishedTime: metadata.publishedTime
        };
      }
    };
    {
      module.exports = Readability2;
    }
  })(Readability);
  var ReadabilityReaderable = { exports: {} };
  (function(module) {
    var REGEXPS = {
      // NOTE: These two regular expressions are duplicated in
      // Readability.js. Please keep both copies in sync.
      unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
      okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
    };
    function isNodeVisible(node) {
      return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
    }
    function isProbablyReaderable(doc, options = {}) {
      if (typeof options == "function") {
        options = {
          visibilityChecker: options
        };
      }
      var defaultOptions = {
        minScore: 20,
        minContentLength: 140,
        visibilityChecker: isNodeVisible
      };
      options = Object.assign(defaultOptions, options);
      var nodes = doc.querySelectorAll("p, pre, article");
      var brNodes = doc.querySelectorAll("div > br");
      if (brNodes.length) {
        var set = new Set(nodes);
        [].forEach.call(brNodes, function(node) {
          set.add(node.parentNode);
        });
        nodes = Array.from(set);
      }
      var score = 0;
      return [].some.call(nodes, function(node) {
        if (!options.visibilityChecker(node)) {
          return false;
        }
        var matchString = node.className + " " + node.id;
        if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
          return false;
        }
        if (node.matches("li p")) {
          return false;
        }
        var textContentLength = node.textContent.trim().length;
        if (textContentLength < options.minContentLength) {
          return false;
        }
        score += Math.sqrt(textContentLength - options.minContentLength);
        if (score > options.minScore) {
          return true;
        }
        return false;
      });
    }
    {
      module.exports = isProbablyReaderable;
    }
  })(ReadabilityReaderable);
  var indexOf = Array.prototype.indexOf;
  var every = Array.prototype.every;
  var rules$1 = {};
  rules$1.tableCell = {
    filter: ["th", "td"],
    replacement: function(content, node) {
      return cell(content, node);
    }
  };
  rules$1.tableRow = {
    filter: "tr",
    replacement: function(content, node) {
      var borderCells = "";
      var alignMap = {
        left: ":--",
        right: "--:",
        center: ":-:"
      };
      if (isHeadingRow(node)) {
        for (var i2 = 0; i2 < node.childNodes.length; i2++) {
          var border = "---";
          var align = (node.childNodes[i2].getAttribute("align") || "").toLowerCase();
          if (align) border = alignMap[align] || border;
          borderCells += cell(border, node.childNodes[i2]);
        }
      }
      return "\n" + content + (borderCells ? "\n" + borderCells : "");
    }
  };
  rules$1.table = {
    // Only convert tables with a heading row.
    // Tables with no heading row are kept using `keep` (see below).
    filter: function(node) {
      return node.nodeName === "TABLE" && isHeadingRow(node.rows[0]);
    },
    replacement: function(content) {
      content = content.replace("\n\n", "\n");
      return "\n\n" + content + "\n\n";
    }
  };
  rules$1.tableSection = {
    filter: ["thead", "tbody", "tfoot"],
    replacement: function(content) {
      return content;
    }
  };
  function isHeadingRow(tr) {
    var parentNode = tr.parentNode;
    return parentNode.nodeName === "THEAD" || parentNode.firstChild === tr && (parentNode.nodeName === "TABLE" || isFirstTbody(parentNode)) && every.call(tr.childNodes, function(n) {
      return n.nodeName === "TH";
    });
  }
  function isFirstTbody(element) {
    var previousSibling = element.previousSibling;
    return element.nodeName === "TBODY" && (!previousSibling || previousSibling.nodeName === "THEAD" && /^\s*$/i.test(previousSibling.textContent));
  }
  function cell(content, node) {
    var index = indexOf.call(node.parentNode.childNodes, node);
    var prefix = " ";
    if (index === 0) prefix = "| ";
    return prefix + content + " |";
  }
  function tables(turndownService) {
    turndownService.keep(function(node) {
      return node.nodeName === "TABLE" && !isHeadingRow(node.rows[0]);
    });
    for (var key in rules$1) turndownService.addRule(key, rules$1[key]);
  }
  function extend(destination) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (source.hasOwnProperty(key)) destination[key] = source[key];
      }
    }
    return destination;
  }
  function repeat(character, count) {
    return Array(count + 1).join(character);
  }
  function trimLeadingNewlines(string) {
    return string.replace(/^\n*/, "");
  }
  function trimTrailingNewlines(string) {
    var indexEnd = string.length;
    while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
    return string.substring(0, indexEnd);
  }
  var blockElements = ["ADDRESS", "ARTICLE", "ASIDE", "AUDIO", "BLOCKQUOTE", "BODY", "CANVAS", "CENTER", "DD", "DIR", "DIV", "DL", "DT", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "FRAMESET", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "HTML", "ISINDEX", "LI", "MAIN", "MENU", "NAV", "NOFRAMES", "NOSCRIPT", "OL", "OUTPUT", "P", "PRE", "SECTION", "TABLE", "TBODY", "TD", "TFOOT", "TH", "THEAD", "TR", "UL"];
  function isBlock(node) {
    return is(node, blockElements);
  }
  var voidElements = ["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"];
  function isVoid(node) {
    return is(node, voidElements);
  }
  function hasVoid(node) {
    return has(node, voidElements);
  }
  var meaningfulWhenBlankElements = ["A", "TABLE", "THEAD", "TBODY", "TFOOT", "TH", "TD", "IFRAME", "SCRIPT", "AUDIO", "VIDEO"];
  function isMeaningfulWhenBlank(node) {
    return is(node, meaningfulWhenBlankElements);
  }
  function hasMeaningfulWhenBlank(node) {
    return has(node, meaningfulWhenBlankElements);
  }
  function is(node, tagNames) {
    return tagNames.indexOf(node.nodeName) >= 0;
  }
  function has(node, tagNames) {
    return node.getElementsByTagName && tagNames.some(function(tagName) {
      return node.getElementsByTagName(tagName).length;
    });
  }
  var rules = {};
  rules.paragraph = {
    filter: "p",
    replacement: function(content) {
      return "\n\n" + content + "\n\n";
    }
  };
  rules.lineBreak = {
    filter: "br",
    replacement: function(content, node, options) {
      return options.br + "\n";
    }
  };
  rules.heading = {
    filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
    replacement: function(content, node, options) {
      var hLevel = Number(node.nodeName.charAt(1));
      if (options.headingStyle === "setext" && hLevel < 3) {
        var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
        return "\n\n" + content + "\n" + underline + "\n\n";
      } else {
        return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
      }
    }
  };
  rules.blockquote = {
    filter: "blockquote",
    replacement: function(content) {
      content = content.replace(/^\n+|\n+$/g, "");
      content = content.replace(/^/gm, "> ");
      return "\n\n" + content + "\n\n";
    }
  };
  rules.list = {
    filter: ["ul", "ol"],
    replacement: function(content, node) {
      var parent = node.parentNode;
      if (parent.nodeName === "LI" && parent.lastElementChild === node) {
        return "\n" + content;
      } else {
        return "\n\n" + content + "\n\n";
      }
    }
  };
  rules.listItem = {
    filter: "li",
    replacement: function(content, node, options) {
      content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
      var prefix = options.bulletListMarker + "   ";
      var parent = node.parentNode;
      if (parent.nodeName === "OL") {
        var start = parent.getAttribute("start");
        var index = Array.prototype.indexOf.call(parent.children, node);
        prefix = (start ? Number(start) + index : index + 1) + ".  ";
      }
      return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
    }
  };
  rules.indentedCodeBlock = {
    filter: function(node, options) {
      return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
    },
    replacement: function(content, node, options) {
      return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
    }
  };
  rules.fencedCodeBlock = {
    filter: function(node, options) {
      return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
    },
    replacement: function(content, node, options) {
      var className = node.firstChild.getAttribute("class") || "";
      var language = (className.match(/language-(\S+)/) || [null, ""])[1];
      var code = node.firstChild.textContent;
      var fenceChar = options.fence.charAt(0);
      var fenceSize = 3;
      var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
      var match;
      while (match = fenceInCodeRegex.exec(code)) {
        if (match[0].length >= fenceSize) {
          fenceSize = match[0].length + 1;
        }
      }
      var fence = repeat(fenceChar, fenceSize);
      return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
    }
  };
  rules.horizontalRule = {
    filter: "hr",
    replacement: function(content, node, options) {
      return "\n\n" + options.hr + "\n\n";
    }
  };
  rules.inlineLink = {
    filter: function(node, options) {
      return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
    },
    replacement: function(content, node) {
      var href = node.getAttribute("href");
      if (href) href = href.replace(/([()])/g, "\\$1");
      var title = cleanAttribute(node.getAttribute("title"));
      if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
      return "[" + content + "](" + href + title + ")";
    }
  };
  rules.referenceLink = {
    filter: function(node, options) {
      return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
    },
    replacement: function(content, node, options) {
      var href = node.getAttribute("href");
      var title = cleanAttribute(node.getAttribute("title"));
      if (title) title = ' "' + title + '"';
      var replacement;
      var reference;
      switch (options.linkReferenceStyle) {
        case "collapsed":
          replacement = "[" + content + "][]";
          reference = "[" + content + "]: " + href + title;
          break;
        case "shortcut":
          replacement = "[" + content + "]";
          reference = "[" + content + "]: " + href + title;
          break;
        default:
          var id = this.references.length + 1;
          replacement = "[" + content + "][" + id + "]";
          reference = "[" + id + "]: " + href + title;
      }
      this.references.push(reference);
      return replacement;
    },
    references: [],
    append: function(options) {
      var references = "";
      if (this.references.length) {
        references = "\n\n" + this.references.join("\n") + "\n\n";
        this.references = [];
      }
      return references;
    }
  };
  rules.emphasis = {
    filter: ["em", "i"],
    replacement: function(content, node, options) {
      if (!content.trim()) return "";
      return options.emDelimiter + content + options.emDelimiter;
    }
  };
  rules.strong = {
    filter: ["strong", "b"],
    replacement: function(content, node, options) {
      if (!content.trim()) return "";
      return options.strongDelimiter + content + options.strongDelimiter;
    }
  };
  rules.code = {
    filter: function(node) {
      var hasSiblings = node.previousSibling || node.nextSibling;
      var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
      return node.nodeName === "CODE" && !isCodeBlock;
    },
    replacement: function(content) {
      if (!content) return "";
      content = content.replace(/\r?\n|\r/g, " ");
      var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
      var delimiter = "`";
      var matches = content.match(/`+/gm) || [];
      while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + "`";
      return delimiter + extraSpace + content + extraSpace + delimiter;
    }
  };
  rules.image = {
    filter: "img",
    replacement: function(content, node) {
      var alt = cleanAttribute(node.getAttribute("alt"));
      var src = node.getAttribute("src") || "";
      var title = cleanAttribute(node.getAttribute("title"));
      var titlePart = title ? ' "' + title + '"' : "";
      return src ? "![" + alt + "](" + src + titlePart + ")" : "";
    }
  };
  function cleanAttribute(attribute) {
    return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
  }
  function Rules(options) {
    this.options = options;
    this._keep = [];
    this._remove = [];
    this.blankRule = {
      replacement: options.blankReplacement
    };
    this.keepReplacement = options.keepReplacement;
    this.defaultRule = {
      replacement: options.defaultReplacement
    };
    this.array = [];
    for (var key in options.rules) this.array.push(options.rules[key]);
  }
  Rules.prototype = {
    add: function(key, rule) {
      this.array.unshift(rule);
    },
    keep: function(filter) {
      this._keep.unshift({
        filter,
        replacement: this.keepReplacement
      });
    },
    remove: function(filter) {
      this._remove.unshift({
        filter,
        replacement: function() {
          return "";
        }
      });
    },
    forNode: function(node) {
      if (node.isBlank) return this.blankRule;
      var rule;
      if (rule = findRule(this.array, node, this.options)) return rule;
      if (rule = findRule(this._keep, node, this.options)) return rule;
      if (rule = findRule(this._remove, node, this.options)) return rule;
      return this.defaultRule;
    },
    forEach: function(fn) {
      for (var i2 = 0; i2 < this.array.length; i2++) fn(this.array[i2], i2);
    }
  };
  function findRule(rules2, node, options) {
    for (var i2 = 0; i2 < rules2.length; i2++) {
      var rule = rules2[i2];
      if (filterValue(rule, node, options)) return rule;
    }
    return void 0;
  }
  function filterValue(rule, node, options) {
    var filter = rule.filter;
    if (typeof filter === "string") {
      if (filter === node.nodeName.toLowerCase()) return true;
    } else if (Array.isArray(filter)) {
      if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
    } else if (typeof filter === "function") {
      if (filter.call(rule, node, options)) return true;
    } else {
      throw new TypeError("`filter` needs to be a string, array, or function");
    }
  }
  function collapseWhitespace(options) {
    var element = options.element;
    var isBlock2 = options.isBlock;
    var isVoid2 = options.isVoid;
    var isPre = options.isPre || function(node2) {
      return node2.nodeName === "PRE";
    };
    if (!element.firstChild || isPre(element)) return;
    var prevText = null;
    var keepLeadingWs = false;
    var prev = null;
    var node = next(prev, element, isPre);
    while (node !== element) {
      if (node.nodeType === 3 || node.nodeType === 4) {
        var text = node.data.replace(/[ \r\n\t]+/g, " ");
        if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
          text = text.substr(1);
        }
        if (!text) {
          node = remove(node);
          continue;
        }
        node.data = text;
        prevText = node;
      } else if (node.nodeType === 1) {
        if (isBlock2(node) || node.nodeName === "BR") {
          if (prevText) {
            prevText.data = prevText.data.replace(/ $/, "");
          }
          prevText = null;
          keepLeadingWs = false;
        } else if (isVoid2(node) || isPre(node)) {
          prevText = null;
          keepLeadingWs = true;
        } else if (prevText) {
          keepLeadingWs = false;
        }
      } else {
        node = remove(node);
        continue;
      }
      var nextNode = next(prev, node, isPre);
      prev = node;
      node = nextNode;
    }
    if (prevText) {
      prevText.data = prevText.data.replace(/ $/, "");
      if (!prevText.data) {
        remove(prevText);
      }
    }
  }
  function remove(node) {
    var next2 = node.nextSibling || node.parentNode;
    node.parentNode.removeChild(node);
    return next2;
  }
  function next(prev, current, isPre) {
    if (prev && prev.parentNode === current || isPre(current)) {
      return current.nextSibling || current.parentNode;
    }
    return current.firstChild || current.nextSibling || current.parentNode;
  }
  var root = typeof window !== "undefined" ? window : {};
  function canParseHTMLNatively() {
    var Parser = root.DOMParser;
    var canParse = false;
    try {
      if (new Parser().parseFromString("", "text/html")) {
        canParse = true;
      }
    } catch (e) {
    }
    return canParse;
  }
  function createHTMLParser() {
    var Parser = function() {
    };
    {
      if (shouldUseActiveX()) {
        Parser.prototype.parseFromString = function(string) {
          var doc = new window.ActiveXObject("htmlfile");
          doc.designMode = "on";
          doc.open();
          doc.write(string);
          doc.close();
          return doc;
        };
      } else {
        Parser.prototype.parseFromString = function(string) {
          var doc = document.implementation.createHTMLDocument("");
          doc.open();
          doc.write(string);
          doc.close();
          return doc;
        };
      }
    }
    return Parser;
  }
  function shouldUseActiveX() {
    var useActiveX = false;
    try {
      document.implementation.createHTMLDocument("").open();
    } catch (e) {
      if (root.ActiveXObject) useActiveX = true;
    }
    return useActiveX;
  }
  var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
  function RootNode(input, options) {
    var root2;
    if (typeof input === "string") {
      var doc = htmlParser().parseFromString(
        // DOM parsers arrange elements in the <head> and <body>.
        // Wrapping in a custom element ensures elements are reliably arranged in
        // a single element.
        '<x-turndown id="turndown-root">' + input + "</x-turndown>",
        "text/html"
      );
      root2 = doc.getElementById("turndown-root");
    } else {
      root2 = input.cloneNode(true);
    }
    collapseWhitespace({
      element: root2,
      isBlock,
      isVoid,
      isPre: options.preformattedCode ? isPreOrCode : null
    });
    return root2;
  }
  var _htmlParser;
  function htmlParser() {
    _htmlParser = _htmlParser || new HTMLParser();
    return _htmlParser;
  }
  function isPreOrCode(node) {
    return node.nodeName === "PRE" || node.nodeName === "CODE";
  }
  function Node(node, options) {
    node.isBlock = isBlock(node);
    node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
    node.isBlank = isBlank(node);
    node.flankingWhitespace = flankingWhitespace(node, options);
    return node;
  }
  function isBlank(node) {
    return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
  }
  function flankingWhitespace(node, options) {
    if (node.isBlock || options.preformattedCode && node.isCode) {
      return {
        leading: "",
        trailing: ""
      };
    }
    var edges = edgeWhitespace(node.textContent);
    if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
      edges.leading = edges.leadingNonAscii;
    }
    if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
      edges.trailing = edges.trailingNonAscii;
    }
    return {
      leading: edges.leading,
      trailing: edges.trailing
    };
  }
  function edgeWhitespace(string) {
    var m2 = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
    return {
      leading: m2[1],
      // whole string for whitespace-only strings
      leadingAscii: m2[2],
      leadingNonAscii: m2[3],
      trailing: m2[4],
      // empty for whitespace-only strings
      trailingNonAscii: m2[5],
      trailingAscii: m2[6]
    };
  }
  function isFlankedByWhitespace(side, node, options) {
    var sibling;
    var regExp;
    var isFlanked;
    if (side === "left") {
      sibling = node.previousSibling;
      regExp = / $/;
    } else {
      sibling = node.nextSibling;
      regExp = /^ /;
    }
    if (sibling) {
      if (sibling.nodeType === 3) {
        isFlanked = regExp.test(sibling.nodeValue);
      } else if (options.preformattedCode && sibling.nodeName === "CODE") {
        isFlanked = false;
      } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
        isFlanked = regExp.test(sibling.textContent);
      }
    }
    return isFlanked;
  }
  var reduce = Array.prototype.reduce;
  var escapes = [[/\\/g, "\\\\"], [/\*/g, "\\*"], [/^-/g, "\\-"], [/^\+ /g, "\\+ "], [/^(=+)/g, "\\$1"], [/^(#{1,6}) /g, "\\$1 "], [/`/g, "\\`"], [/^~~~/g, "\\~~~"], [/\[/g, "\\["], [/\]/g, "\\]"], [/^>/g, "\\>"], [/_/g, "\\_"], [/^(\d+)\. /g, "$1\\. "]];
  function TurndownService(options) {
    if (!(this instanceof TurndownService)) return new TurndownService(options);
    var defaults = {
      rules,
      headingStyle: "setext",
      hr: "* * *",
      bulletListMarker: "*",
      codeBlockStyle: "indented",
      fence: "```",
      emDelimiter: "_",
      strongDelimiter: "**",
      linkStyle: "inlined",
      linkReferenceStyle: "full",
      br: "  ",
      preformattedCode: false,
      blankReplacement: function(content, node) {
        return node.isBlock ? "\n\n" : "";
      },
      keepReplacement: function(content, node) {
        return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
      },
      defaultReplacement: function(content, node) {
        return node.isBlock ? "\n\n" + content + "\n\n" : content;
      }
    };
    this.options = extend({}, defaults, options);
    this.rules = new Rules(this.options);
  }
  TurndownService.prototype = {
    /**
     * The entry point for converting a string or DOM node to Markdown
     * @public
     * @param {String|HTMLElement} input The string or DOM node to convert
     * @returns A Markdown representation of the input
     * @type String
     */
    turndown: function(input) {
      if (!canConvert(input)) {
        throw new TypeError(input + " is not a string, or an element/document/fragment node.");
      }
      if (input === "") return "";
      var output = process$1.call(this, new RootNode(input, this.options));
      return postProcess.call(this, output);
    },
    /**
     * Add one or more plugins
     * @public
     * @param {Function|Array} plugin The plugin or array of plugins to add
     * @returns The Turndown instance for chaining
     * @type Object
     */
    use: function(plugin) {
      if (Array.isArray(plugin)) {
        for (var i2 = 0; i2 < plugin.length; i2++) this.use(plugin[i2]);
      } else if (typeof plugin === "function") {
        plugin(this);
      } else {
        throw new TypeError("plugin must be a Function or an Array of Functions");
      }
      return this;
    },
    /**
     * Adds a rule
     * @public
     * @param {String} key The unique key of the rule
     * @param {Object} rule The rule
     * @returns The Turndown instance for chaining
     * @type Object
     */
    addRule: function(key, rule) {
      this.rules.add(key, rule);
      return this;
    },
    /**
     * Keep a node (as HTML) that matches the filter
     * @public
     * @param {String|Array|Function} filter The unique key of the rule
     * @returns The Turndown instance for chaining
     * @type Object
     */
    keep: function(filter) {
      this.rules.keep(filter);
      return this;
    },
    /**
     * Remove a node that matches the filter
     * @public
     * @param {String|Array|Function} filter The unique key of the rule
     * @returns The Turndown instance for chaining
     * @type Object
     */
    remove: function(filter) {
      this.rules.remove(filter);
      return this;
    },
    /**
     * Escapes Markdown syntax
     * @public
     * @param {String} string The string to escape
     * @returns A string with Markdown syntax escaped
     * @type String
     */
    escape: function(string) {
      return escapes.reduce(function(accumulator, escape) {
        return accumulator.replace(escape[0], escape[1]);
      }, string);
    }
  };
  function process$1(parentNode) {
    var self2 = this;
    return reduce.call(parentNode.childNodes, function(output, node) {
      node = new Node(node, self2.options);
      var replacement = "";
      if (node.nodeType === 3) {
        replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
      } else if (node.nodeType === 1) {
        replacement = replacementForNode.call(self2, node);
      }
      return join(output, replacement);
    }, "");
  }
  function postProcess(output) {
    var self2 = this;
    this.rules.forEach(function(rule) {
      if (typeof rule.append === "function") {
        output = join(output, rule.append(self2.options));
      }
    });
    return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
  }
  function replacementForNode(node) {
    var rule = this.rules.forNode(node);
    var content = process$1.call(this, node);
    var whitespace = node.flankingWhitespace;
    if (whitespace.leading || whitespace.trailing) content = content.trim();
    return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
  }
  function join(output, replacement) {
    var s1 = trimTrailingNewlines(output);
    var s2 = trimLeadingNewlines(replacement);
    var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
    var separator = "\n\n".substring(0, nls);
    return s1 + separator + s2;
  }
  function canConvert(input) {
    return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
  }
  function tidyMarkdown(markdown) {
    let normalizedMarkdown = markdown.replace(/\[\s*([^\]\n]+?)\s*\]\s*\(\s*([^)]+)\s*\)/g, (_match, text, url) => {
      const cleanText = text.replace(/\s+/g, " ").trim();
      const cleanUrl = url.replace(/\s+/g, "").trim();
      return `[${cleanText}](${cleanUrl})`;
    });
    normalizedMarkdown = normalizedMarkdown.replace(/\[\s*([^\]\n!]*?)\s*\n*(?:!\[([^\]]*)\]\((.*?)\))?\s*\n*\]\s*\(\s*([^)]+)\s*\)/g, (_match, text, alt, imgUrl, linkUrl) => {
      const cleanText = text.replace(/\s+/g, " ").trim();
      const cleanAlt = alt ? alt.replace(/\s+/g, " ").trim() : "";
      const cleanImgUrl = imgUrl ? imgUrl.replace(/\s+/g, "").trim() : "";
      const cleanLinkUrl = linkUrl.replace(/\s+/g, "").trim();
      if (cleanImgUrl) {
        return `[${cleanText} ![${cleanAlt}](${cleanImgUrl})](${cleanLinkUrl})`;
      }
      return `[${cleanText}](${cleanLinkUrl})`;
    });
    normalizedMarkdown = normalizedMarkdown.replace(/\[\s*([^\]]+)\]\s*\(\s*([^)]+)\)/g, (_match, text, url) => {
      const cleanText = text.replace(/\s+/g, " ").trim();
      const cleanUrl = url.replace(/\s+/g, "").trim();
      return `[${cleanText}](${cleanUrl})`;
    });
    normalizedMarkdown = normalizedMarkdown.replace(/^[ \t]+/gm, "");
    normalizedMarkdown = normalizedMarkdown.replace(/\n{3,}/g, "\n\n");
    return normalizedMarkdown.trim();
  }
  const getTurndown = (mode) => {
    const turnDownService = new TurndownService({
      headingStyle: "atx",
      bulletListMarker: "-",
      codeBlockStyle: "fenced"
    });
    if (mode === "render") {
      turnDownService.addRule("remove-irrelevant", {
        filter: ["meta", "style", "script", "noscript", "link", "textarea"],
        replacement: () => ""
      });
    } else if (mode === "ingest") {
      turnDownService.addRule("remove-irrelevant", {
        filter: ["meta", "style", "script", "noscript", "link", "textarea", "img"],
        replacement: () => ""
      });
      turnDownService.addRule("unlink", {
        filter: ["a"],
        replacement: (_content, node) => node.textContent
      });
    }
    return turnDownService;
  };
  const convertHTMLToMarkdown = (mode, html) => {
    const turnDownPlugins = [tables];
    const toBeTurnedToMd = html;
    let turnDownService = getTurndown(mode);
    for (const plugin of turnDownPlugins) {
      turnDownService = turnDownService.use(plugin);
    }
    let contentText = "";
    if (toBeTurnedToMd) {
      try {
        contentText = turnDownService.turndown(toBeTurnedToMd).trim();
      } catch (err) {
        console.error(`Turndown failed to run, retrying without plugins: ${err}`);
        const vanillaTurnDownService = getTurndown("vanilla");
        try {
          contentText = vanillaTurnDownService.turndown(toBeTurnedToMd).trim();
        } catch (err2) {
          console.error(`Turndown failed to run, giving up: ${err2}`);
        }
      }
    }
    if (!contentText || contentText.startsWith("<") && contentText.endsWith(">") && toBeTurnedToMd !== html) {
      try {
        contentText = turnDownService.turndown(html);
      } catch (err) {
        console.warn("Turndown failed to run, retrying without plugins", {
          err
        });
        const vanillaTurnDownService = getTurndown("vanilla");
        try {
          contentText = vanillaTurnDownService.turndown(html);
        } catch (err2) {
          console.warn("Turndown failed to run, giving up", {
            err: err2
          });
        }
      }
    }
    return tidyMarkdown(contentText || "").trim();
  };
  _utils_csui;
  const cleanMarkdown = (markdownContent) => {
    let cleanedMarkdown = markdownContent;
    cleanedMarkdown = cleanedMarkdown.replace(/\n{3,}/g, "\n\n");
    cleanedMarkdown = cleanedMarkdown.replace(/[ \t]+$/gm, "");
    cleanedMarkdown = cleanedMarkdown.replace(/```(\w*)\n\n/g, "```$1\n");
    cleanedMarkdown = cleanedMarkdown.replace(/!\[[^\]]*\]\(data:image\/[^)]+\)/g, "");
    cleanedMarkdown = cleanedMarkdown.replace(/\[[^\]]*\]\(javascript:[^)]*\)/g, "");
    cleanedMarkdown = cleanedMarkdown.replace(/\(javascript:[^)]*\)/g, "");
    cleanedMarkdown = cleanedMarkdown.replace(/\[([^\]]*)\]\(\s*\)/g, "$1");
    cleanedMarkdown = cleanedMarkdown.replace(/!\[([^\]]*)\]\(\s*\)/g, "");
    cleanedMarkdown = cleanedMarkdown.replace(/\*\s+(\S)/g, "*$1");
    cleanedMarkdown = cleanedMarkdown.replace(/(\S)\s+\*/g, "$1*");
    cleanedMarkdown = cleanedMarkdown.replace(/[\u200B\u200C\u200D\uFEFF]/g, "");
    cleanedMarkdown = cleanedMarkdown.replace(/^\s*[\[\]\(\)\*\-\_\#\~\`]+\s*$/gm, "");
    cleanedMarkdown = cleanedMarkdown.replace(/[^\S\n]{2,}/g, " ");
    cleanedMarkdown = cleanedMarkdown.replace(/(\S)\n\n(\S)/g, "$1\n\n$2");
    cleanedMarkdown = cleanedMarkdown.replace(/(\n[*\-+] .+)\n([^*\-+\n])/g, "$1\n\n$2");
    return cleanedMarkdown.trim();
  };
  const preprocessHtmlContent = (htmlContent) => {
    let content = "";
    if (typeof htmlContent === "string") {
      content = htmlContent;
    } else if (htmlContent instanceof Document || htmlContent instanceof HTMLElement || htmlContent instanceof DocumentFragment) {
      const div = document.createElement("div");
      div.appendChild(htmlContent.cloneNode(true));
      content = div.innerHTML;
    }
    content = content.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, "").replace(/<!--[\s\S]*?-->/g, "");
    return content;
  };
  const getMarkdown = (element) => {
    const html = preprocessHtmlContent(element);
    const md = convertHTMLToMarkdown("render", html);
    return cleanMarkdown(md);
  };
  _utils_csui;
  const saveMockedResource = async () => {
    const pageContent = getMarkdown(document == null ? void 0 : document.body);
    const resource = {
      resourceId: "tempResId",
      title: (document == null ? void 0 : document.title) || "",
      data: {
        url: location.href,
        title: (document == null ? void 0 : document.title) || ""
      },
      resourceType: "weblink",
      isPublic: false,
      readOnly: true,
      collabEnabled: false,
      content: pageContent || ""
    };
    sendMessage({
      name: "currentMockResource",
      type: "syncInfo",
      body: {
        currentMockResource: resource
      },
      source: getRuntime()
    }, false);
    return resource;
  };
  _utils_csui;
  const useSyncWeblinkResourceMeta = () => {
    const messageListenerEventRef = reactExports.useRef();
    const makeTempResourceAndSave = async () => {
      await saveMockedResource();
    };
    const onMessageHandler = (event) => {
      const data = event;
      const {
        name
      } = data || {};
      if (name === "reflyStatusCheck" && (data == null ? void 0 : data.type) === "others" && getRuntime() === "extension-csui") {
        makeTempResourceAndSave();
      }
    };
    const initMessageListener = () => {
      onMessage(onMessageHandler, getRuntime()).then((clearEvent) => {
        messageListenerEventRef.current = clearEvent;
      });
      return () => {
        var _a2;
        (_a2 = messageListenerEventRef.current) == null ? void 0 : _a2.call(messageListenerEventRef);
      };
    };
    reactExports.useEffect(() => {
      makeTempResourceAndSave();
    }, []);
    return {
      initMessageListener
    };
  };
  _utils_csui;
  const checkPageUnsupported = (pageUrl) => {
    if (pageUrl) {
      const checkBrowserSettingPage = pageUrl.startsWith("chrome://") || pageUrl.startsWith("edge://") || pageUrl.startsWith("arc://") || pageUrl.startsWith("about:");
      const checkBrowserExtensionStorePage = ["https://browser.google.com/webstore", "https://microsoftedge.microsoft.com/addons", "https://addons.mozilla.org/en-US/firefox", "https://accounts.google.com", "https://github.com/login"].some((url) => pageUrl.startsWith(url));
      return checkBrowserSettingPage || checkBrowserExtensionStorePage;
    }
    return true;
  };
  _utils_csui;
  const App = () => {
    const {
      initMessageListener
    } = useSyncWeblinkResourceMeta();
    const isDomVisibilityRef = reactExports.useRef(document.visibilityState);
    const handleVisibilityChange = () => {
      isDomVisibilityRef.current = document.visibilityState;
    };
    reactExports.useEffect(() => {
      if (isDomVisibilityRef.current === "visible" && !checkPageUnsupported(location.href)) ;
    }, []);
    reactExports.useEffect(() => {
      document.addEventListener("visibilitychange", handleVisibilityChange);
      return () => {
        document.removeEventListener("visibilitychange", handleVisibilityChange);
      };
    });
    reactExports.useEffect(() => {
      setRuntime("extension-csui");
      initMessageListener();
    }, []);
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment, {}, void 0, false, {
      fileName: "/Users/songyuan/Documents/projects/lab/zhipu/AGENT/\u5e73\u53f0\u7c7b/\u81ea\u52a8\u751f\u6210workflow/refly-main/refly/apps/extension/src/entrypoints/utils-csui.content/App.tsx",
      lineNumber: 40,
      columnNumber: 10
    }, void 0);
  };
  _utils_csui;
  class DevLogger {
    // ===================================
    // CONSTRUCTOR & INITIALIZATION
    // ===================================
    constructor() {
      // ===================================
      // PRIVATE PROPERTIES
      // ===================================
      __publicField(this, "isDevelopment");
      // Debug click activation state
      __publicField(this, "debugClickCount", 0);
      __publicField(this, "lastClickTime", 0);
      __publicField(this, "clickTimeout", null);
      this.isDevelopment = this.checkDevelopmentMode();
      this.initializeLogger();
      this.setupStorageListener();
    }
    initializeLogger() {
      if (this.isDevelopment) {
        console.log("\ud83d\udd27 [Refly Logger] Debug mode: ON \u2705");
      }
    }
    setupStorageListener() {
      if (typeof window !== "undefined") {
        window.addEventListener("storage", (e) => {
          if (e.key === "reflydebug") {
            const wasEnabled = this.isDevelopment;
            this.isDevelopment = this.checkDevelopmentMode();
            if (wasEnabled || this.isDevelopment) {
              console.log(`\ud83d\udd27 [Refly Logger] Debug mode: ${this.isDevelopment ? "ON \u2705" : "OFF \u274c"}`);
            }
          }
        });
      }
    }
    // ===================================
    // PUBLIC LOGGING METHODS
    // ===================================
    log(...args) {
      if (this.isDevelopment) {
        console.log(...args);
      }
    }
    debug(...args) {
      if (this.isDevelopment) {
        console.log(...args);
      }
    }
    info(...args) {
      if (this.isDevelopment) {
        console.info(...args);
      }
    }
    warn(...args) {
      if (this.isDevelopment) {
        console.warn(...args);
      }
    }
    error(...args) {
      if (this.isDevelopment) {
        console.error(...args);
      }
    }
    // ===================================
    // PUBLIC DEBUG STATE MANAGEMENT
    // ===================================
    refreshDebugState() {
      this.isDevelopment = this.checkDevelopmentMode();
      return this.isDevelopment;
    }
    test() {
      console.log(`\ud83d\udd27 [Refly Logger] Debug mode: ${this.isDevelopment ? "ON \u2705" : "OFF \u274c"}`);
      return this.isDevelopment;
    }
    // ===================================
    // DEBUG CLICK ACTIVATION (10 CLICKS)
    // ===================================
    handleDebugClick(showMessage) {
      this.updateClickCount();
      this.resetClickCounterAfterDelay();
      if (this.shouldShowHints()) {
        this.showActivationHints(showMessage);
      } else if (this.shouldToggleDebugMode()) {
        this.toggleDebugMode(showMessage);
      }
      return this.debugClickCount;
    }
    updateClickCount() {
      const now2 = Date.now();
      const timeSinceLastClick = now2 - this.lastClickTime;
      if (timeSinceLastClick > 3e3) {
        this.debugClickCount = 1;
      } else {
        this.debugClickCount += 1;
      }
      this.lastClickTime = now2;
    }
    resetClickCounterAfterDelay() {
      if (this.clickTimeout) {
        clearTimeout(this.clickTimeout);
      }
      this.clickTimeout = setTimeout(() => {
        this.debugClickCount = 0;
      }, 5e3);
    }
    shouldShowHints() {
      return this.debugClickCount === 8 || this.debugClickCount === 9;
    }
    shouldToggleDebugMode() {
      return this.debugClickCount >= 10;
    }
    showActivationHints(showMessage) {
      const remainingClicks = 10 - this.debugClickCount;
      showMessage == null ? void 0 : showMessage(`\ud83d\udd27 Debug mode activation: ${remainingClicks} more click${remainingClicks > 1 ? "s" : ""} needed`, "info");
    }
    toggleDebugMode(showMessage) {
      const isCurrentlyEnabled = this.refreshDebugState();
      if (isCurrentlyEnabled) {
        this.deactivateDebugMode(showMessage);
      } else {
        this.activateDebugMode(showMessage);
      }
      this.debugClickCount = 0;
    }
    activateDebugMode(showMessage) {
      try {
        localStorage.setItem("reflydebug", "true");
        this.refreshDebugState();
        showMessage == null ? void 0 : showMessage("\ud83c\udf89 Debug mode activated! Check console for logs.", "success");
      } catch (_e) {
        document.documentElement.setAttribute("data-refly-debug", "true");
        this.refreshDebugState();
        showMessage == null ? void 0 : showMessage("\ud83c\udf89 Debug mode activated (fallback method)! Check console for logs.", "success");
      }
    }
    deactivateDebugMode(showMessage) {
      try {
        localStorage.removeItem("reflydebug");
        document.documentElement.removeAttribute("data-refly-debug");
        this.refreshDebugState();
        showMessage == null ? void 0 : showMessage("\ud83d\udd34 Debug mode deactivated! Console logs disabled.", "success");
      } catch (_e) {
        document.documentElement.removeAttribute("data-refly-debug");
        this.refreshDebugState();
        showMessage == null ? void 0 : showMessage("\ud83d\udd34 Debug mode deactivated (fallback method)! Console logs disabled.", "success");
      }
    }
    // ===================================
    // PRIVATE DEBUG MODE DETECTION
    // ===================================
    checkDevelopmentMode() {
      try {
        return this.checkLocalStorageFlag() || this.checkDocumentAttribute() || this.checkBuildEnvironment() || this.checkProcessEnvironment() || this.checkUrlParameter();
      } catch (_e) {
        return false;
      }
    }
    checkLocalStorageFlag() {
      try {
        if (typeof window !== "undefined" && window.localStorage) {
          return window.localStorage.getItem("reflydebug") === "true";
        }
      } catch (_storageError) {
      }
      return false;
    }
    checkDocumentAttribute() {
      if (typeof document !== "undefined" && document.documentElement) {
        return document.documentElement.getAttribute("data-refly-debug") === "true";
      }
      return false;
    }
    checkBuildEnvironment() {
      return typeof { url: _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("content-scripts/utils-csui.js", document.baseURI).href } !== "undefined" && true;
    }
    checkProcessEnvironment() {
      return typeof process !== "undefined" && true;
    }
    checkUrlParameter() {
      if (typeof window !== "undefined" && window.location) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("refly_debug") === "true";
      }
      return false;
    }
  }
  const logger$1 = new DevLogger();
  _utils_csui;
  const definition = defineContentScript({
    matches: ["<all_urls>"],
    // 2. Set cssInjectionMode
    cssInjectionMode: "ui",
    excludeMatches: ["https://refly.ai/*", "https://api.refly.ai/*", "https://www.refly.ai/*", "http://localhost:5173/*"],
    async main(ctx) {
      setRuntime("extension-csui");
      logger$1.debug("utils-csui ctx", ctx);
      const ui = await createShadowRootUi(ctx, {
        name: "refly-utils-app",
        position: "inline",
        append: "before",
        onMount(container) {
          const root2 = client.createRoot(container);
          root2.render(/* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(App, {}, void 0, false, {
            fileName: "/Users/songyuan/Documents/projects/lab/zhipu/AGENT/\u5e73\u53f0\u7c7b/\u81ea\u52a8\u751f\u6210workflow/refly-main/refly/apps/extension/src/entrypoints/utils-csui.content/index.tsx",
            lineNumber: 31,
            columnNumber: 21
          }, this));
          return root2;
        },
        onRemove: (root2) => {
          root2 == null ? void 0 : root2.unmount();
        }
      });
      ui.mount();
    }
  });
  _utils_csui;
  function print(method, ...args) {
    if (typeof args[0] === "string") {
      const message = args.shift();
      method(`[wxt] ${message}`, ...args);
    } else {
      method("[wxt]", ...args);
    }
  }
  var logger = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  var result = (async () => {
    try {
      const {
        main,
        ...options
      } = definition;
      const ctx = new ContentScriptContext("utils-csui", options);
      return await main(ctx);
    } catch (err) {
      logger.error(`The content script "${"utils-csui"}" crashed on startup!`, err);
      throw err;
    }
  })();
  var content_script_isolated_world_entrypoint_default = result;
  const browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    browser: browser$1
  }, Symbol.toStringTag, { value: "Module" }));
  return content_script_isolated_world_entrypoint_default;
}();
_utils_csui;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMtY3N1aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvd3h0L2Rpc3Qvc2FuZGJveC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zY2hlZHVsZXJAMC4yMy4yL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zY2hlZHVsZXJAMC4yMy4yL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9jbGllbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy91dGlscy9zcmMvZW52LnRzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbEAwLjEwLjAvbm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy93eHQvZGlzdC9jaHVuay1GTlRFMkwyNy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1wb3RlbnRpYWwtY3VzdG9tLWVsZW1lbnQtbmFtZUAxLjAuMS9ub2RlX21vZHVsZXMvaXMtcG90ZW50aWFsLWN1c3RvbS1lbGVtZW50LW5hbWUvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYmV4dC1jb3JlK2lzb2xhdGVkLWVsZW1lbnRAMS4xLjIvbm9kZV9tb2R1bGVzL0B3ZWJleHQtY29yZS9pc29sYXRlZC1lbGVtZW50L2xpYi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3d4dC9kaXN0L2NsaWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gudGhyb3R0bGVANC4xLjEvbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FpLXdvcmtzcGFjZS1jb21tb24vc3JjL3V0aWxzL2V4dGVuc2lvbi9tZXNzYWdpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vemlsbGErcmVhZGFiaWxpdHlAMC41LjAvbm9kZV9tb2R1bGVzL0Btb3ppbGxhL3JlYWRhYmlsaXR5L1JlYWRhYmlsaXR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb3ppbGxhK3JlYWRhYmlsaXR5QDAuNS4wL25vZGVfbW9kdWxlcy9AbW96aWxsYS9yZWFkYWJpbGl0eS9SZWFkYWJpbGl0eS1yZWFkZXJhYmxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3R1cm5kb3duLXBsdWdpbi1nZm1AMS4wLjIvbm9kZV9tb2R1bGVzL3R1cm5kb3duLXBsdWdpbi1nZm0vbGliL3R1cm5kb3duLXBsdWdpbi1nZm0uZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHVybmRvd25ANy4yLjAvbm9kZV9tb2R1bGVzL3R1cm5kb3duL2xpYi90dXJuZG93bi5icm93c2VyLmVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL21hcmtkb3duLnRzIiwiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL2h0bWwybWQudHMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvc2F2ZS1tb2NrZWQtcmVzb3VyY2UudHMiLCIuLi8uLi8uLi9zcmMvaG9va3MvY29udGVudC1zY3JpcHRzL3VzZS1nZXQtd2VibGluay1yZXNvdXJjZS1tZXRhLnRzIiwiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvYWktd29ya3NwYWNlLWNvbW1vbi9zcmMvdXRpbHMvZXh0ZW5zaW9uL2NoZWNrLnRzIiwiLi4vLi4vLi4vc3JjL2VudHJ5cG9pbnRzL3V0aWxzLWNzdWkuY29udGVudC9BcHAudHN4IiwiLi4vLi4vLi4vc3JjL3V0aWxzL2xvZ2dlci50cyIsIi4uLy4uLy4uL3NyYy9lbnRyeXBvaW50cy91dGlscy1jc3VpLmNvbnRlbnQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4zLjEnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogbnVsbFxufTtcblxudmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0ge1xuICBjdXJyZW50OiBudWxsLFxuICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLlxuICBpc0JhdGNoaW5nTGVnYWN5OiBmYWxzZSxcbiAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6IGZhbHNlXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnZnVuY3Rpb24nICYmIHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpO1xuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIik7XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICB7XG4gICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKGlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgYGlmYCBzdGF0ZW1lbnQgaGVyZSBwcmV2ZW50cyBhdXRvLWRpc2FibGluZyBvZiB0aGUgc2FmZVxuICAgICAgICAgIC8vIGNvZXJjaW9uIEVTTGludCBydWxlLCBzbyB3ZSBtdXN0IG1hbnVhbGx5IGRpc2FibGUgaXQgYmVsb3cuXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgaWYgKG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1hcHBlZENoaWxkLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gIC8vIFRPRE86IFNlY29uZCBhcmd1bWVudCB1c2VkIHRvIGJlIGFuIG9wdGlvbmFsIGBjYWxjdWxhdGVDaGFuZ2VkQml0c2BcbiAgLy8gZnVuY3Rpb24uIFdhcm4gdG8gcmVzZXJ2ZSBmb3IgZnV0dXJlIHVzZT9cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsLFxuICAgIC8vIEFkZCB0aGVzZSB0byB1c2Ugc2FtZSBoaWRkZW4gY2xhc3MgaW4gVk0gYXMgU2VydmVyQ29udGV4dFxuICAgIF9kZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgX2dsb2JhbE5hbWU6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGVpdGhlciBiZWNhdXNlIGl0J3MgbWlzc2luZyBvciB0aHJvd3MuIElmIHNvLCB3ZSB0cmVhdCBpdFxuICAgIC8vIGFzIHN0aWxsIHVuaW5pdGlhbGl6ZWQgYW5kIHRyeSBhZ2FpbiBuZXh0IHRpbWUuIFdoaWNoIGlzIHRoZSBzYW1lIGFzIHdoYXRcbiAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuICAgIC8vIGVuZCB1cCBmaXhpbmcgaXQgaWYgdGhlIHJlc29sdXRpb24gd2FzIGEgY29uY3VycmVuY3kgYnVnLlxuXG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3Q7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG4gICAgICAvLyB0byByZXNvbHZlLiBTZXQgaXQgYXMgcGVuZGluZyBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICB2YXIgbW9kdWxlT2JqZWN0ID0gcGF5bG9hZC5fcmVzdWx0O1xuXG4gICAge1xuICAgICAgaWYgKG1vZHVsZU9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKCEoJ2RlZmF1bHQnIGluIG1vZHVsZU9iamVjdCkpIHtcbiAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiBVbmluaXRpYWxpemVkLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0Lm1lbW8oKHByb3BzKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCF0eXBlLm5hbWUgJiYgIXR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAge1xuICAgIGlmIChkaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuICAgIH1cbiAgfSAvLyBXaWxsIHJlc3VsdCBpbiBhIG51bGwgYWNjZXNzIGVycm9yIGlmIGFjY2Vzc2VkIG91dHNpZGUgcmVuZGVyIHBoYXNlLiBXZVxuICAvLyBpbnRlbnRpb25hbGx5IGRvbid0IHRocm93IG91ciBvd24gZXJyb3IgYmVjYXVzZSB0aGlzIGlzIGluIGEgaG90IHBhdGguXG4gIC8vIEFsc28gaGVscHMgZW5zdXJlIHRoaXMgaXMgaW5saW5lZC5cblxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVRyYW5zaXRpb24oKTtcbn1cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG59XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNjb3BlLCBvcHRpb25zKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2NvcGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gZmFsc2U7XG52YXIgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbDtcbmZ1bmN0aW9uIGVucXVldWVUYXNrKHRhc2spIHtcbiAgaWYgKGVucXVldWVUYXNrSW1wbCA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICAvLyByZWFkIHJlcXVpcmUgb2ZmIHRoZSBtb2R1bGUgb2JqZWN0IHRvIGdldCBhcm91bmQgdGhlIGJ1bmRsZXJzLlxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGRldGVjdCBhIHJlcXVpcmUgYW5kIGJ1bmRsZSBhIE5vZGUgcG9seWZpbGwuXG4gICAgICB2YXIgcmVxdWlyZVN0cmluZyA9ICgncmVxdWlyZScgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgIHZhciBub2RlUmVxdWlyZSA9IG1vZHVsZSAmJiBtb2R1bGVbcmVxdWlyZVN0cmluZ107IC8vIGFzc3VtaW5nIHdlJ3JlIGluIG5vZGUsIGxldCdzIHRyeSB0byBnZXQgbm9kZSdzXG4gICAgICAvLyB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZSwgYnlwYXNzaW5nIGZha2UgdGltZXJzIGlmIGFueS5cblxuICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgLy8gd2UncmUgaW4gYSBicm93c2VyXG4gICAgICAvLyB3ZSBjYW4ndCB1c2UgcmVndWxhciB0aW1lcnMgYmVjYXVzZSB0aGV5IG1heSBzdGlsbCBiZSBmYWtlZFxuICAgICAgLy8gc28gd2UgdHJ5IE1lc3NhZ2VDaGFubmVsK3Bvc3RNZXNzYWdlIGluc3RlYWRcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBlcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgJyArICdzbyBlbnF1ZXVpbmcgdGFza3MgdmlhIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pIHdpbGwgZmFpbC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzICcgKyAnaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh1bmRlZmluZWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5xdWV1ZVRhc2tJbXBsKHRhc2spO1xufVxuXG52YXIgYWN0U2NvcGVEZXB0aCA9IDA7XG52YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdChjYWxsYmFjaykge1xuICB7XG4gICAgLy8gYGFjdGAgY2FsbHMgY2FuIGJlIG5lc3RlZCwgc28gd2UgdHJhY2sgdGhlIGRlcHRoLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgLy8gbnVtYmVyIG9mIGBhY3RgIHNjb3BlcyBvbiB0aGUgc3RhY2suXG4gICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICBhY3RTY29wZURlcHRoKys7XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBJbml0aWFsaXplIHRoZSBxdWV1ZS4gVGhlIHJlY29uY2lsZXJcbiAgICAgIC8vIHdpbGwgZGV0ZWN0IHRoZSBxdWV1ZSBhbmQgdXNlIGl0IGluc3RlYWQgb2YgU2NoZWR1bGVyLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgIH1cblxuICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgICAvLyBzZXQgdG8gYHRydWVgIHdoaWxlIHRoZSBnaXZlbiBjYWxsYmFjayBpcyBleGVjdXRlZCwgbm90IGZvciB1cGRhdGVzXG4gICAgICAvLyB0cmlnZ2VyZWQgZHVyaW5nIGFuIGFzeW5jIGV2ZW50LCBiZWNhdXNlIHRoaXMgaXMgaG93IHRoZSBsZWdhY3lcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7IC8vIFJlcGxpY2F0ZSBiZWhhdmlvciBvZiBvcmlnaW5hbCBgYWN0YCBpbXBsZW1lbnRhdGlvbiBpbiBsZWdhY3kgbW9kZSxcbiAgICAgIC8vIHdoaWNoIGZsdXNoZWQgdXBkYXRlcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgc2NvcGUgZnVuY3Rpb24gZXhpdHMsIGV2ZW5cbiAgICAgIC8vIGlmIGl0J3MgYW4gYXN5bmMgZnVuY3Rpb24uXG5cbiAgICAgIGlmICghcHJldklzQmF0Y2hpbmdMZWdhY3kgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcblxuICAgICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIChpLmUuIHJldHVybmVkIGEgcHJvbWlzZSkuIFdhaXRcbiAgICAgIC8vIGZvciBpdCB0byByZXNvbHZlIGJlZm9yZSBleGl0aW5nIHRoZSBjdXJyZW50IHNjb3BlLlxuXG4gICAgICB2YXIgd2FzQXdhaXRlZCA9IGZhbHNlO1xuICAgICAgdmFyIHRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgd2FzQXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgdGhlbmFibGVSZXN1bHQudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcblxuICAgICAgICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gV2UndmUgZXhpdGVkIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBSZWN1cnNpdmVseSBmbHVzaCB0aGVcbiAgICAgICAgICAgICAgLy8gcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLlxuICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAge1xuICAgICAgICBpZiAoIWRpZFdhcm5Ob0F3YWl0QWN0ICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge30pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF3YXNBd2FpdGVkKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBlcnJvcignWW91IGNhbGxlZCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aXRob3V0IGF3YWl0LiAnICsgJ1RoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCAnICsgJ2ludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciAnICsgJ3Njb3Blcy4gJyArICdZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBub3QgYW4gYXN5bmMgZnVuY3Rpb24uIEV4aXQgdGhlIGN1cnJlbnQgc2NvcGVcbiAgICAgIC8vIGltbWVkaWF0ZWx5LCB3aXRob3V0IGF3YWl0aW5nLlxuXG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgIC8vIEV4aXRpbmcgdGhlIG91dGVybW9zdCBhY3Qgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgdmFyIF9xdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKF9xdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZsdXNoQWN0UXVldWUoX3F1ZXVlKTtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSAvLyBSZXR1cm4gYSB0aGVuYWJsZS4gSWYgdGhlIHVzZXIgYXdhaXRzIGl0LCB3ZSdsbCBmbHVzaCBhZ2FpbiBpblxuICAgICAgICAvLyBjYXNlIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuXG5cbiAgICAgICAgdmFyIF90aGVuYWJsZSA9IHtcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBDb25maXJtIHdlIGhhdmVuJ3QgcmUtZW50ZXJlZCBhbm90aGVyIGBhY3RgIHNjb3BlLCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyB3ZWlyZCBsaWtlIGF3YWl0IHRoZSB0aGVuYWJsZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbHVzaCB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoZW5hYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmVzdGVkIGBhY3RgIHNjb3BlLCB0aGUgcmV0dXJuZWQgdGhlbmFibGVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVzb2x2ZXMuIFRoZSBvdXRlciBzY29wZSB3aWxsIGZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgdmFyIF90aGVuYWJsZTIgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoZW5hYmxlMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpIHtcbiAge1xuICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgIGVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gJyk7XG4gICAgfVxuXG4gICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICB7XG4gICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcblxuICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZC4gRmluaXNoLlxuICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gS2VlcCBmbHVzaGluZyB3b3JrIHVudGlsIHRoZXJlJ3Mgbm9uZSBsZWZ0LlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0ZsdXNoaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQWN0UXVldWUocXVldWUpIHtcbiAge1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgLy8gUHJldmVudCByZS1lbnRyYW5jZS5cbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIH0gd2hpbGUgKGNhbGxiYWNrICE9PSBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIHF1ZXVlID0gcXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5leHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuYWN0ID0gYWN0O1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcbmV4cG9ydHMudW5zdGFibGVfYWN0ID0gYWN0O1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSB1c2VEZWZlcnJlZFZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUlkID0gdXNlSWQ7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLy8gc3JjL3NhbmRib3gvZGVmaW5lLXVubGlzdGVkLXNjcmlwdC50c1xuZnVuY3Rpb24gZGVmaW5lVW5saXN0ZWRTY3JpcHQoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB7IG1haW46IGFyZyB9O1xuICByZXR1cm4gYXJnO1xufVxuXG4vLyBzcmMvc2FuZGJveC9kZWZpbmUtYmFja2dyb3VuZC50c1xuZnVuY3Rpb24gZGVmaW5lQmFja2dyb3VuZChhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHsgbWFpbjogYXJnIH07XG4gIHJldHVybiBhcmc7XG59XG5cbi8vIHNyYy9zYW5kYm94L2RlZmluZS1jb250ZW50LXNjcmlwdC50c1xuZnVuY3Rpb24gZGVmaW5lQ29udGVudFNjcmlwdChkZWZpbml0aW9uKSB7XG4gIHJldHVybiBkZWZpbml0aW9uO1xufVxuXG4vLyBzcmMvc2FuZGJveC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcIkB3ZWJleHQtY29yZS9tYXRjaC1wYXR0ZXJuc1wiO1xuZXhwb3J0IHtcbiAgZGVmaW5lQmFja2dyb3VuZCxcbiAgZGVmaW5lQ29udGVudFNjcmlwdCxcbiAgZGVmaW5lVW5saXN0ZWRTY3JpcHRcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG52YXIgZW5hYmxlUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZnJhbWVZaWVsZE1zID0gNTtcblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG4gIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGhhbGZMZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzOyAvLyBUaW1lcyBvdXQgaW1tZWRpYXRlbHlcblxudmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbnZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG52YXIgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG52YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbnZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxudmFyIGN1cnJlbnRUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbnZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG52YXIgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbnZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbnZhciBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG5cbiAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoc3RhcnRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgIHB1c2godGltZXJRdWV1ZSwgbmV3VGFzayk7XG5cbiAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICBwdXNoKHRhc2tRdWV1ZSwgbmV3VGFzayk7XG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cbiAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rhc2s7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbigpIHtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG52YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbnZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbnZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xudmFyIHN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBvbmx5IGJlZW4gYmxvY2tlZCBmb3IgYSByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWU7XG4gICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBtYWluIHRocmVhZCBoYXMgYmVlbiBibG9ja2VkIGZvciBhIG5vbi1uZWdsaWdpYmxlIGFtb3VudCBvZiB0aW1lLiBXZVxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHtcblxufVxuXG5mdW5jdGlvbiBmb3JjZUZyYW1lUmF0ZShmcHMpIHtcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZnBzID4gMCkge1xuICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICB9XG59XG5cbnZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIGhhcyBiZWVuIGJsb2NrZWQuXG5cbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7IC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgLy9cbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgIC8vIHRlY2huaXF1ZXMgaGFyZGVyLiBJbnN0ZWFkLCBpZiBgc2NoZWR1bGVkSG9zdENhbGxiYWNrYCBlcnJvcnMsIHRoZW5cbiAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgdmFyIGhhc01vcmVXb3JrID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxufTtcblxudmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5pZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSBhbmQgV29ya2VyIGVudmlyb25tZW50cy5cbiAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIG1zKTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG5cbnZhciB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSByZXF1ZXN0UGFpbnQ7XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgc3VwcHJlc3NXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzZXRTdXBwcmVzc1dhcm5pbmcobmV3U3VwcHJlc3NXYXJuaW5nKSB7XG4gIHtcbiAgICBzdXBwcmVzc1dhcm5pbmcgPSBuZXdTdXBwcmVzc1dhcm5pbmc7XG4gIH1cbn0gLy8gSW4gREVWLCBjYWxscyB0byBjb25zb2xlLndhcm4gYW5kIGNvbnNvbGUuZXJyb3IgZ2V0IHJlcGxhY2VkXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xudmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xudmFyIENhY2hlQ29tcG9uZW50ID0gMjQ7XG52YXIgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IDI1O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlQ2xpZW50UmVuZGVyRmFsbGJhY2tPblRleHRNaXNtYXRjaCA9IHRydWU7IC8vIFRPRE86IE5lZWQgdG8gcmV2aWV3IHRoaXMgY29kZSBvbmUgbW9yZSB0aW1lIGJlZm9yZSBsYW5kaW5nXG4vLyB0aGUgcmVhY3QtcmVjb25jaWxlciBwYWNrYWdlLlxuXG52YXIgZW5hYmxlTmV3UmVjb25jaWxlciA9IGZhbHNlOyAvLyBTdXBwb3J0IGxlZ2FjeSBQcmltZXIgc3VwcG9ydCBvbiBpbnRlcm5hbCBGQiB3d3dcblxudmFyIGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gPSBmYWxzZTsgLy8gRkItb25seSB1c2FnZS4gVGhlIG5ldyBBUEkgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MuXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG5cbnZhciBlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaXp6XG4vLyBSZWFjdCBET00gQ2hvcHBpbmcgQmxvY2tcbi8vXG4vLyBTaW1pbGFyIHRvIG1haW4gQ2hvcHBpbmcgQmxvY2sgYnV0IG9ubHkgZmxhZ3MgcmVsYXRlZCB0byBSZWFjdCBET00uIFRoZXNlIGFyZVxuLy8gZ3JvdXBlZCBiZWNhdXNlIHdlIHdpbGwgbGlrZWx5IGJhdGNoIGFsbCBvZiB0aGVtIGludG8gYSBzaW5nbGUgbWFqb3IgcmVsZWFzZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEaXNhYmxlIHN1cHBvcnQgZm9yIGNvbW1lbnQgbm9kZXMgYXMgUmVhY3QgRE9NIGNvbnRhaW5lcnMuIEFscmVhZHkgZGlzYWJsZWRcbi8vIGluIG9wZW4gc291cmNlLCBidXQgd3d3IGNvZGViYXNlIHN0aWxsIHJlbGllcyBvbiBpdC4gTmVlZCB0byByZW1vdmUuXG5cbnZhciBkaXNhYmxlQ29tbWVudHNBc0RPTUNvbnRhaW5lcnMgPSB0cnVlOyAvLyBEaXNhYmxlIGphdmFzY3JpcHQ6IFVSTCBzdHJpbmdzIGluIGhyZWYgZm9yIFhTUyBwcm90ZWN0aW9uLlxuLy8gYW5kIGNsaWVudCByZW5kZXJpbmcsIG1vc3RseSB0byBhbGxvdyBKU1ggYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgY3VzdG9tXG4vLyBlbGVtZW50J3Mgb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZCBvZiBvbmx5IEhUTUwgYXR0cmlidXRlcy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEzNDdcblxudmFyIGVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQgPSBmYWxzZTsgLy8gRGlzYWJsZXMgY2hpbGRyZW4gZm9yIDx0ZXh0YXJlYT4gZWxlbWVudHNcbnZhciB3YXJuQWJvdXRTdHJpbmdSZWZzID0gdHJ1ZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBhbGxOYXRpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cblxuXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSAge30gOyAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgJ0NhcHR1cmUnLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdKSB7XG4gICAgICBlcnJvcignRXZlbnRSZWdpc3RyeTogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIGFsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTtcbiAgfVxufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgYXR0cmlidXRlTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdGb3JtIGZpZWxkIHZhbHVlcyAodmFsdWUsIGNoZWNrZWQsIGRlZmF1bHRWYWx1ZSwgb3IgZGVmYXVsdENoZWNrZWQgcHJvcHMpJyArICcgbXVzdCBiZSBzdHJpbmdzLCBub3QgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcblxuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcblxuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG5cbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcblxuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgdHlwZSwgbXVzdFVzZVByb3BlcnR5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2UsIHNhbml0aXplVVJMLCByZW1vdmVFbXB0eVN0cmluZykge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zYW5pdGl6ZVVSTCA9IHNhbml0aXplVVJMO1xuICB0aGlzLnJlbW92ZUVtcHR5U3RyaW5nID0gcmVtb3ZlRW1wdHlTdHJpbmc7XG59IC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxuXG5cbnZhciBwcm9wZXJ0aWVzID0ge307IC8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuXG52YXIgcmVzZXJ2ZWRQcm9wcyA9IFsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLCAvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXTtcblxucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2hlY2sgcHJvdGVjdHMgbXVsdGlwbGUgdXNlcyBvZiBgZXhwZWN0ZWRgLCB3aGljaCBpcyB3aHkgdGhlXG4gICAgICAvLyByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvbiBydWxlIGlzIGRpc2FibGVkIGluIHNldmVyYWwgc3BvdHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAge1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGV4cGVjdGVkLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBmdWxseSBkaXNhYmxlZCBqYXZhc2NyaXB0OiBVUkxzLCBhbmQgaWZcbiAgICAgICAgLy8gdGhlIGh5ZHJhdGlvbiBpcyBzdWNjZXNzZnVsIG9mIGEgamF2YXNjcmlwdDogVVJMLCB3ZVxuICAgICAgICAvLyBzdGlsbCB3YW50IHRvIHdhcm4gb24gdGhlIGNsaWVudC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgIHNhbml0aXplVVJMKCcnICsgZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuXG5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cblxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cblxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiBhdHRyaWJ1dGUgdHlwZSBpcyBib29sZWFuLCB3ZSBrbm93IGZvciBzdXJlIGl0IHdvbid0IGJlIGFuIGV4ZWN1dGlvbiBzaW5rXG4gICAgICAvLyBhbmQgd2Ugd29uJ3QgcmVxdWlyZSBUcnVzdGVkIFR5cGUgaGVyZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHNhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYWNpbmdfbWFya2VyJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZSQxKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUkMSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICB2YXIgdGFnID0gZmliZXIudGFnLFxuICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdDYWNoZSc7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdEZWh5ZHJhdGVkRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lJDEodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAvLyBIb3N0IGNvbXBvbmVudCB0eXBlIGlzIHRoZSBkaXNwbGF5IG5hbWUgKGUuZy4gXCJkaXZcIiwgXCJWaWV3XCIpXG4gICAgICByZXR1cm4gdHlwZTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gJ1Jvb3QnO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiAnVGV4dCc7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAvLyBOYW1lIGNvbWVzIGZyb20gdGhlIHR5cGUgaW4gdGhpcyBjYXNlOyB3ZSBkb24ndCBoYXZlIGEgdGFnLlxuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKSB7XG4gICAgICAgIC8vIERvbid0IGJlIGxlc3Mgc3BlY2lmaWMgdGhhbiBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG4gICAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnTW9kZSc7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1Njb3BlJztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdUcmFjaW5nTWFya2VyJztcbiAgICAvLyBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGlzIHRhZ3MgY29tZSBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHR5cGU6XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuXG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBmaWJlciA9PT0gbnVsbCA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gIHtcbiAgICBpc1JlbmRlcmluZyA9IHJlbmRlcmluZztcbiAgfVxufVxuXG4vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIFRoZSBjb2VyY2lvbiBzYWZldHkgY2hlY2sgaXMgcGVyZm9ybWVkIGluIGdldFRvU3RyaW5nVmFsdWUoKS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB7XG4gICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKG5vZGVbdmFsdWVGaWVsZF0pO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTsgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0ID0gZGVzY3JpcHRvci5zZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIHNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0pOyAvLyBXZSBjb3VsZCd2ZSBwYXNzZWQgdGhpcyB0aGUgZmlyc3QgdGltZVxuICAvLyBidXQgaXQgdHJpZ2dlcnMgYSBidWcgaW4gSUUxMSBhbmQgRWRnZSAxNC8xNS5cbiAgLy8gQ2FsbGluZyBkZWZpbmVQcm9wZXJ0eSgpIGFnYWluIHNob3VsZCBiZSBlcXVpdmFsZW50LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExNzY4XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG4gIHZhciB0cmFja2VyID0ge1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAge1xuICAgICAgICBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICB2YXIgaG9zdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuICByZXR1cm4gaG9zdFByb3BzO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSksXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCB0byBiZSBjb250cm9sbGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSB1bmRlZmluZWQgdG8gJyArICdhIGRlZmluZWQgdmFsdWUsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIGEgZGVmaW5lZCB0byAnICsgJ3VuZGVmaW5lZCwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJyB8fCAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gY29lcmNlIHRvIG51bWJlciBoZXJlIGlmIHBvc3NpYmxlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCcpIHtcbiAgICAvLyBTdWJtaXQvcmVzZXQgaW5wdXRzIG5lZWQgdGhlIGF0dHJpYnV0ZSByZW1vdmVkIGNvbXBsZXRlbHkgdG8gYXZvaWRcbiAgICAvLyBibGFuay10ZXh0IGJ1dHRvbnMuXG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgY29tZXMgZnJvbSBhIGNhc2NhZGUgb2ZcbiAgICAvLyBwcm9wZXJ0aWVzOlxuICAgIC8vICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAzLiBPdGhlcndpc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNoYW5nZVxuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGl0IG9ubHkgY2hhbmdlcyB3aGVuIGl0IG5lZWRzXG4gICAgLy8gdG8gYmUgcmVtb3ZlZCwgc3VjaCBhcyB0cmFuc2l0aW9uaW5nIGZyb20gYSBjaGVja2JveCBpbnRvIGEgdGV4dCBpbnB1dFxuICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzLCBpc0h5ZHJhdGluZykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIHZhciBpc0J1dHRvbiA9IHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCc7IC8vIEF2b2lkIHNldHRpbmcgdmFsdWUgYXR0cmlidXRlIG9uIHN1Ym1pdC9yZXNldCBpbnB1dHMgYXMgaXQgb3ZlcnJpZGVzIHRoZVxuICAgIC8vIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuIFNlZTogIzEyODcyXG5cbiAgICBpZiAoaXNCdXR0b24gJiYgKHByb3BzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMudmFsdWUgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpOyAvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuICAgIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cblxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzaG91bGQgdXNlXG4gICAgICAgIC8vIHRoZSB3cmFwcGVyU3RhdGUuX2luaXRpYWxWYWx1ZSBwcm9wZXJ0eS4gVGhpcyB1c2VzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDMuIEFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBzeW5jaHJvbml6ZWQgdG8gdGhlIHByb3BlcnR5LFxuICAgICAgLy8gc28gd2UgYXNzaWduIGRlZmF1bHRWYWx1ZSB0byB0aGUgc2FtZSB0aGluZyBhcyB0aGUgdmFsdWUgcHJvcGVydHlcbiAgICAgIC8vIGFzc2lnbm1lbnQgc3RlcCBhYm92ZS5cbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgfSAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG5cblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBib3RoIHRoZSBjaGVja2VkIHByb3BlcnR5IGFuZFxuICAgIC8vIGF0dHJpYnV0ZSBhcmUgYXNzaWduZWQgYXQgdGhlIHNhbWUgdGltZSB1c2luZyBkZWZhdWx0Q2hlY2tlZC4gVGhpcyB1c2VzOlxuICAgIC8vXG4gICAgLy8gICAxLiBUaGUgY2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDIuIFRoZSBkZWZhdWx0Q2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDMuIE90aGVyd2lzZSwgZmFsc2VcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO1xuICB9XG5cbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcblxuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH0gLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybS4gSXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4gICAgLy8gbWlzcyBhbnl0aGluZy5cblxuXG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihuYW1lLCAnbmFtZScpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG5cbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cblxuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtcblxuICAgICAgaWYgKCFvdGhlclByb3BzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlICcgKyAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH0gLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuXG5cbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7IC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59IC8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5cblxuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIGlmICggLy8gRm9jdXNlZCBudW1iZXIgaW5wdXRzIHN5bmNocm9uaXplIG9uIGJsdXIuIFNlZSBDaGFuZ2VFdmVudFBsdWdpbi5qc1xuICB0eXBlICE9PSAnbnVtYmVyJyB8fCBnZXRBY3RpdmVFbGVtZW50KG5vZGUub3duZXJEb2N1bWVudCkgIT09IG5vZGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZENoaWxkID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRJbm5lckhUTUwgPSBmYWxzZTtcbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGNoaWxkcmVuIG11c3QgYmUgc2ltcGxlLlxuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0JyAmJiBwcm9wcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkQ2hpbGQpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRJbm5lckhUTUwpIHtcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZElubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUGFzcyBhIGB2YWx1ZWAgcHJvcCBpZiB5b3Ugc2V0IGRhbmdlcm91c2x5SW5uZXJIVE1MIHNvIFJlYWN0IGtub3dzICcgKyAnd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cblxuXG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG5cbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB0b1N0cmluZyhnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKSkpO1xuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BOYW1lSXNBcnJheSA9IGlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFwcm9wTmFtZUlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBwcm9wTmFtZUlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG4gIH0gLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG5cblxuICB2YXIgaG9zdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7IC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5cbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgJiYgbm9kZS5kZWZhdWx0VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cblxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50OyAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cblxuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09ICcnICYmIHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnOyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuXG4gICAgaWYgKCEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAgICAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAgICAgLy8gdGhlIHRhcmdldCBub2RlXG4gICAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwudmFsdWVPZigpLnRvU3RyaW5nKCkgKyAnPC9zdmc+JztcbiAgICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vLyBMaXN0IGRlcml2ZWQgZnJvbSBHZWNrbyBzb3VyY2UgY29kZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzRlNjM4ZWZjNzEvbGF5b3V0L3N0eWxlL3Rlc3QvcHJvcGVydHlfZGF0YWJhc2UuanNcbnZhciBzaG9ydGhhbmRUb0xvbmdoYW5kID0ge1xuICBhbmltYXRpb246IFsnYW5pbWF0aW9uRGVsYXknLCAnYW5pbWF0aW9uRGlyZWN0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uJywgJ2FuaW1hdGlvbkZpbGxNb2RlJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FuaW1hdGlvbk5hbWUnLCAnYW5pbWF0aW9uUGxheVN0YXRlJywgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIGJhY2tncm91bmQ6IFsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCAnYmFja2dyb3VuZENsaXAnLCAnYmFja2dyb3VuZENvbG9yJywgJ2JhY2tncm91bmRJbWFnZScsICdiYWNrZ3JvdW5kT3JpZ2luJywgJ2JhY2tncm91bmRQb3NpdGlvblgnLCAnYmFja2dyb3VuZFBvc2l0aW9uWScsICdiYWNrZ3JvdW5kUmVwZWF0JywgJ2JhY2tncm91bmRTaXplJ10sXG4gIGJhY2tncm91bmRQb3NpdGlvbjogWydiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknXSxcbiAgYm9yZGVyOiBbJ2JvcmRlckJvdHRvbUNvbG9yJywgJ2JvcmRlckJvdHRvbVN0eWxlJywgJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlUmVwZWF0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VTb3VyY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCcsICdib3JkZXJUb3BDb2xvcicsICdib3JkZXJUb3BTdHlsZScsICdib3JkZXJUb3BXaWR0aCddLFxuICBib3JkZXJCbG9ja0VuZDogWydib3JkZXJCbG9ja0VuZENvbG9yJywgJ2JvcmRlckJsb2NrRW5kU3R5bGUnLCAnYm9yZGVyQmxvY2tFbmRXaWR0aCddLFxuICBib3JkZXJCbG9ja1N0YXJ0OiBbJ2JvcmRlckJsb2NrU3RhcnRDb2xvcicsICdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCAnYm9yZGVyQmxvY2tTdGFydFdpZHRoJ10sXG4gIGJvcmRlckJvdHRvbTogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCddLFxuICBib3JkZXJDb2xvcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJUb3BDb2xvciddLFxuICBib3JkZXJJbWFnZTogWydib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnXSxcbiAgYm9yZGVySW5saW5lRW5kOiBbJ2JvcmRlcklubGluZUVuZENvbG9yJywgJ2JvcmRlcklubGluZUVuZFN0eWxlJywgJ2JvcmRlcklubGluZUVuZFdpZHRoJ10sXG4gIGJvcmRlcklubGluZVN0YXJ0OiBbJ2JvcmRlcklubGluZVN0YXJ0Q29sb3InLCAnYm9yZGVySW5saW5lU3RhcnRTdHlsZScsICdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sXG4gIGJvcmRlckxlZnQ6IFsnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnXSxcbiAgYm9yZGVyUmFkaXVzOiBbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCAnYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMnLCAnYm9yZGVyVG9wTGVmdFJhZGl1cycsICdib3JkZXJUb3BSaWdodFJhZGl1cyddLFxuICBib3JkZXJSaWdodDogWydib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCddLFxuICBib3JkZXJTdHlsZTogWydib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyUmlnaHRTdHlsZScsICdib3JkZXJUb3BTdHlsZSddLFxuICBib3JkZXJUb3A6IFsnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyV2lkdGg6IFsnYm9yZGVyQm90dG9tV2lkdGgnLCAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgY29sdW1uUnVsZTogWydjb2x1bW5SdWxlQ29sb3InLCAnY29sdW1uUnVsZVN0eWxlJywgJ2NvbHVtblJ1bGVXaWR0aCddLFxuICBjb2x1bW5zOiBbJ2NvbHVtbkNvdW50JywgJ2NvbHVtbldpZHRoJ10sXG4gIGZsZXg6IFsnZmxleEJhc2lzJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnXSxcbiAgZmxleEZsb3c6IFsnZmxleERpcmVjdGlvbicsICdmbGV4V3JhcCddLFxuICBmb250OiBbJ2ZvbnRGYW1pbHknLCAnZm9udEZlYXR1cmVTZXR0aW5ncycsICdmb250S2VybmluZycsICdmb250TGFuZ3VhZ2VPdmVycmlkZScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbicsICdmb250V2VpZ2h0JywgJ2xpbmVIZWlnaHQnXSxcbiAgZm9udFZhcmlhbnQ6IFsnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbiddLFxuICBnYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkOiBbJ2dyaWRBdXRvQ29sdW1ucycsICdncmlkQXV0b0Zsb3cnLCAnZ3JpZEF1dG9Sb3dzJywgJ2dyaWRUZW1wbGF0ZUFyZWFzJywgJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCAnZ3JpZFRlbXBsYXRlUm93cyddLFxuICBncmlkQXJlYTogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCcsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkQ29sdW1uOiBbJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblN0YXJ0J10sXG4gIGdyaWRDb2x1bW5HYXA6IFsnY29sdW1uR2FwJ10sXG4gIGdyaWRHYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkUm93OiBbJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1N0YXJ0J10sXG4gIGdyaWRSb3dHYXA6IFsncm93R2FwJ10sXG4gIGdyaWRUZW1wbGF0ZTogWydncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgbGlzdFN0eWxlOiBbJ2xpc3RTdHlsZUltYWdlJywgJ2xpc3RTdHlsZVBvc2l0aW9uJywgJ2xpc3RTdHlsZVR5cGUnXSxcbiAgbWFyZ2luOiBbJ21hcmdpbkJvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0JywgJ21hcmdpblRvcCddLFxuICBtYXJrZXI6IFsnbWFya2VyRW5kJywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCddLFxuICBtYXNrOiBbJ21hc2tDbGlwJywgJ21hc2tDb21wb3NpdGUnLCAnbWFza0ltYWdlJywgJ21hc2tNb2RlJywgJ21hc2tPcmlnaW4nLCAnbWFza1Bvc2l0aW9uWCcsICdtYXNrUG9zaXRpb25ZJywgJ21hc2tSZXBlYXQnLCAnbWFza1NpemUnXSxcbiAgbWFza1Bvc2l0aW9uOiBbJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWSddLFxuICBvdXRsaW5lOiBbJ291dGxpbmVDb2xvcicsICdvdXRsaW5lU3R5bGUnLCAnb3V0bGluZVdpZHRoJ10sXG4gIG92ZXJmbG93OiBbJ292ZXJmbG93WCcsICdvdmVyZmxvd1knXSxcbiAgcGFkZGluZzogWydwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nVG9wJ10sXG4gIHBsYWNlQ29udGVudDogWydhbGlnbkNvbnRlbnQnLCAnanVzdGlmeUNvbnRlbnQnXSxcbiAgcGxhY2VJdGVtczogWydhbGlnbkl0ZW1zJywgJ2p1c3RpZnlJdGVtcyddLFxuICBwbGFjZVNlbGY6IFsnYWxpZ25TZWxmJywgJ2p1c3RpZnlTZWxmJ10sXG4gIHRleHREZWNvcmF0aW9uOiBbJ3RleHREZWNvcmF0aW9uQ29sb3InLCAndGV4dERlY29yYXRpb25MaW5lJywgJ3RleHREZWNvcmF0aW9uU3R5bGUnXSxcbiAgdGV4dEVtcGhhc2lzOiBbJ3RleHRFbXBoYXNpc0NvbG9yJywgJ3RleHRFbXBoYXNpc1N0eWxlJ10sXG4gIHRyYW5zaXRpb246IFsndHJhbnNpdGlvbkRlbGF5JywgJ3RyYW5zaXRpb25EdXJhdGlvbicsICd0cmFuc2l0aW9uUHJvcGVydHknLCAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIHdvcmRXcmFwOiBbJ292ZXJmbG93V3JhcCddXG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBhc3BlY3RSYXRpbzogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHtcbiAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbHVlRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xufVxuLyoqXG4gKiBHaXZlbiB7Y29sb3I6ICdyZWQnLCBvdmVyZmxvdzogJ2hpZGRlbid9IHJldHVybnMge1xuICogICBjb2xvcjogJ2NvbG9yJyxcbiAqICAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3cnLFxuICogICBvdmVyZmxvd1k6ICdvdmVyZmxvdycsXG4gKiB9LiBUaGlzIGNhbiBiZSByZWFkIGFzIFwidGhlIG92ZXJmbG93WSBwcm9wZXJ0eSB3YXMgc2V0IGJ5IHRoZSBvdmVyZmxvd1xuICogc2hvcnRoYW5kXCIuIFRoYXQgaXMsIHRoZSB2YWx1ZXMgYXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGVhY2ggd2FzIGRlcml2ZWQgZnJvbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgdmFyIGV4cGFuZGVkID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciBsb25naGFuZHMgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleV0gfHwgW2tleV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdoYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXSA9IGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG4vKipcbiAqIFdoZW4gbWl4aW5nIHNob3J0aGFuZCBhbmQgbG9uZ2hhbmQgcHJvcGVydHkgbmFtZXMsIHdlIHdhcm4gZHVyaW5nIHVwZGF0ZXMgaWZcbiAqIHdlIGV4cGVjdCBhbiBpbmNvcnJlY3QgcmVzdWx0IHRvIG9jY3VyLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YXJuIGZvcjpcbiAqXG4gKiBVcGRhdGluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBvdmVyd3JpdHRlbik6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2JheicsIGZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICdiYXonXG4gKiBSZW1vdmluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBsb3N0IHRvbyk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJydcbiAqIFJlbW92aW5nIGEgbG9uZ2hhbmQgcHJvcGVydHkgKHNob3VsZCByZXZlcnQgdG8gc2hvcnRoYW5kOyBkb2Vzbid0KTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnZm9vJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udFZhcmlhbnQgPSAnJ1xuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFN0eWxlcykge1xuICB7XG4gICAgaWYgKCFuZXh0U3R5bGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuZGVkVXBkYXRlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO1xuICAgIHZhciBleHBhbmRlZFN0eWxlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChuZXh0U3R5bGVzKTtcbiAgICB2YXIgd2FybmVkQWJvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHBhbmRlZFVwZGF0ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgICAgdmFyIGNvcnJlY3RPcmlnaW5hbEtleSA9IGV4cGFuZGVkU3R5bGVzW2tleV07XG5cbiAgICAgIGlmIChjb3JyZWN0T3JpZ2luYWxLZXkgJiYgb3JpZ2luYWxLZXkgIT09IGNvcnJlY3RPcmlnaW5hbEtleSkge1xuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG9yaWdpbmFsS2V5ICsgJywnICsgY29ycmVjdE9yaWdpbmFsS2V5O1xuXG4gICAgICAgIGlmICh3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmVkQWJvdXRbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclcyBhIHN0eWxlIHByb3BlcnR5IGR1cmluZyByZXJlbmRlciAoJXMpIHdoZW4gYSAnICsgJ2NvbmZsaWN0aW5nIHByb3BlcnR5IGlzIHNldCAoJXMpIGNhbiBsZWFkIHRvIHN0eWxpbmcgYnVncy4gVG8gJyArIFwiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiICsgJ2ZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggJyArICdzZXBhcmF0ZSB2YWx1ZXMuJywgaXNWYWx1ZUVtcHR5KHN0eWxlVXBkYXRlc1tvcmlnaW5hbEtleV0pID8gJ1JlbW92aW5nJyA6ICdVcGRhdGluZycsIG9yaWdpbmFsS2V5LCBjb3JyZWN0T3JpZ2luYWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBhc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICBpZiAocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5zdHlsZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wcy5zdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW1hZ2VzaXplczogJ2ltYWdlU2l6ZXMnLFxuICBpbWFnZXNyY3NldDogJ2ltYWdlU3JjU2V0JyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRlc2NyaXB0aW9uJzogMCxcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8vIFRoaXMgZXhpc3RzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBSZWFjdERPTUV2ZW50UmVwbGF5aW5nXG4vLyBhbmQgRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG52YXIgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHNldFJlcGxheWluZ0V2ZW50KGV2ZW50KSB7XG4gIHtcbiAgICBpZiAoY3VycmVudFJlcGxheWluZ0V2ZW50ICE9PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gZXZlbnQ7XG59XG5mdW5jdGlvbiByZXNldFJlcGxheWluZ0V2ZW50KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGN1cnJlbnRseSByZXBsYXlpbmcgZXZlbnQgdG8gbm90IGJlIG51bGwuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZXBsYXlpbmdFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgPT09IGN1cnJlbnRSZXBsYXlpbmdFdmVudDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93OyAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG5cbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfSAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuXG5cbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciByZXN0b3JlSW1wbCA9IG51bGw7XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcblxuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc3RvcmVJbXBsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oKSBuZWVkcyB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIGEgdGFyZ2V0IGZvciBjb250cm9sbGVkICcgKyAnZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGZsdXNoU3luY0ltcGwgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgLy8gVE9ETzogUmVzdG9yZSBzdGF0ZSBpbiB0aGUgbWljcm90YXNrLCBhZnRlciB0aGUgZGlzY3JldGUgdXBkYXRlcyBmbHVzaCxcbiAgICAvLyBpbnN0ZWFkIG9mIGVhcmx5IGZsdXNoaW5nIHRoZW0gaGVyZS5cbiAgICBmbHVzaFN5bmNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSwgYikge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH1cblxuICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZFVwZGF0ZXNJbXBsKGZuLCBhLCBiKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59IC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBmbHVzaFN5bmNcbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oX2JhdGNoZWRVcGRhdGVzSW1wbCwgX2Rpc2NyZXRlVXBkYXRlc0ltcGwsIF9mbHVzaFN5bmNJbXBsKSB7XG4gIGJhdGNoZWRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkVXBkYXRlc0ltcGw7XG4gIGZsdXNoU3luY0ltcGwgPSBfZmx1c2hTeW5jSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2N1bWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnICsgJ2RlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCAnICsgJ3NjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSAnICsgJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnICsgJ3RoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCAnICsgJ2NhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgJyArICd0byBiZSBhc3luY2hyb25vdXMuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9IC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG5cblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuXG4gICAgICBpZiAoIWRpZENhbGwpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjczNFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NTg1XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgcmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO1xuXG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBjYXVnaHRFcnJvciA9IG51bGw7IC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG5cbnZhciBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbnZhciByZXRocm93RXJyb3IgPSBudWxsO1xudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICogVE9ETzogU2VlIGlmIGNhdWdodEVycm9yIGFuZCByZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgIGlmICghaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICBoYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICovXG5cbmZ1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICByZXRocm93RXJyb3IgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpIHtcbiAgcmV0dXJuIGhhc0Vycm9yO1xufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgQ2hpbGREZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ29udGVudFJlc2V0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgQ2FsbGJhY2sgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgRGlkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIEZvcmNlQ2xpZW50UmVuZGVyID1cbi8qICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBSZWYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7XG52YXIgU25hcHNob3QgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBQYXNzaXZlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4yMDQ4O1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjQwOTY7XG52YXIgVmlzaWJpbGl0eSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBTdG9yZUNvbnNpc3RlbmN5ID1cbi8qICAgICAgICAgICAgICovXG4xNjM4NDtcbnZhciBMaWZlY3ljbGVFZmZlY3RNYXNrID0gUGFzc2l2ZSB8IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgU25hcHNob3QgfCBTdG9yZUNvbnNpc3RlbmN5OyAvLyBVbmlvbiBvZiBhbGwgY29tbWl0IGZsYWdzIChmbGFncyB3aXRoIHRoZSBsaWZldGltZSBvZiBhIHBhcnRpY3VsYXIgY29tbWl0KVxuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMzI3Njc7IC8vIFRoZXNlIGFyZSBub3QgcmVhbGx5IHNpZGUgZWZmZWN0cywgYnV0IHdlIHN0aWxsIHJldXNlIHRoaXMgZmllbGQuXG5cbnZhciBJbmNvbXBsZXRlID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zMjc2ODtcbnZhciBTaG91bGRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xMzEwNzI7XG52YXIgRm9ya2VkID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcbi8vIGUuZy4gYSBmaWJlciB1c2VzIGEgcGFzc2l2ZSBlZmZlY3QgKGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHVwZGF0ZXMgb24gdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcikuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGVmZXIgbW9yZSB3b3JrIGluIHRoZSB1bm1vdW50IGNhc2UsXG4vLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcbi8vIGFuZCBpbnN0ZWFkIHJlbHkgb24gdGhlIHN0YXRpYyBmbGFnIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgbWF5IGJlIGNsZWFudXAgd29yay5cblxudmFyIFJlZlN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjIwOTcxNTI7XG52YXIgTGF5b3V0U3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAqL1xuNDE5NDMwNDtcbnZhciBQYXNzaXZlU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICovXG44Mzg4NjA4OyAvLyBUaGVzZSBmbGFncyBhbGxvdyB1cyB0byB0cmF2ZXJzZSB0byBmaWJlcnMgdGhhdCBoYXZlIGVmZmVjdHMgb24gbW91bnRcbi8vIHdpdGhvdXQgdHJhdmVyc2luZyB0aGUgZW50aXJlIHRyZWUgYWZ0ZXIgZXZlcnkgY29tbWl0IGZvclxuLy8gZG91YmxlIGludm9raW5nXG5cbnZhciBNb3VudExheW91dERldiA9XG4vKiAgICAgICAgICAgICAgICovXG4xNjc3NzIxNjtcbnZhciBNb3VudFBhc3NpdmVEZXYgPVxuLyogICAgICAgICAgICAgICovXG4zMzU1NDQzMjsgLy8gR3JvdXBzIG9mIGZsYWdzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbW1pdCBwaGFzZSB0byBza2lwIG92ZXIgdHJlZXMgdGhhdFxuLy8gZG9uJ3QgY29udGFpbiBlZmZlY3RzLCBieSBjaGVja2luZyBzdWJ0cmVlRmxhZ3MuXG5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2sgPSAvLyBUT0RPOiBSZW1vdmUgVXBkYXRlIGZsYWcgZnJvbSBiZWZvcmUgbXV0YXRpb24gcGhhc2UgYnkgcmUtbGFuZGluZyBWaXNpYmlsaXR5XG4vLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuVXBkYXRlIHwgU25hcHNob3QgfCAoIDApO1xudmFyIE11dGF0aW9uTWFzayA9IFBsYWNlbWVudCB8IFVwZGF0ZSB8IENoaWxkRGVsZXRpb24gfCBDb250ZW50UmVzZXQgfCBSZWYgfCBIeWRyYXRpbmcgfCBWaXNpYmlsaXR5O1xudmFyIExheW91dE1hc2sgPSBVcGRhdGUgfCBDYWxsYmFjayB8IFJlZiB8IFZpc2liaWxpdHk7IC8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG5cbnZhciBQYXNzaXZlTWFzayA9IFBhc3NpdmUgfCBDaGlsZERlbGV0aW9uOyAvLyBVbmlvbiBvZiB0YWdzIHRoYXQgZG9uJ3QgZ2V0IHJlc2V0IG9uIGNsb25lcy5cbi8vIFRoaXMgYWxsb3dzIGNlcnRhaW4gY29uY2VwdHMgdG8gcGVyc2lzdCB3aXRob3V0IHJlY2FsY3VsYXRpbmcgdGhlbSxcbi8vIGUuZy4gd2hldGhlciBhIHN1YnRyZWUgY29udGFpbnMgcGFzc2l2ZSBlZmZlY3RzIG9yIHBvcnRhbHMuXG5cbnZhciBTdGF0aWNNYXNrID0gTGF5b3V0U3RhdGljIHwgUGFzc2l2ZVN0YXRpYyB8IFJlZlN0YXRpYztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudEEgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbiAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAvLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IGIgPSBuZXh0UGFyZW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuXG5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgcmV0dXJuIGN1cnJlbnRQYXJlbnQgIT09IG51bGwgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjaGlsZCk7XG5cbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY2hpbGQpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG52YXIgc2NoZWR1bGVDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xudmFyIGNhbmNlbENhbGxiYWNrID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG52YXIgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IFNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBMb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWUgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgTm9Nb2RlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wOyAvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG5cbnZhciBDb25jdXJyZW50TW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUHJvZmlsZU1vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFN0cmljdExlZ2FjeU1vZGUgPVxuLyogICAgICAgICAgICAgICAqL1xuODtcbnZhciBTdHJpY3RFZmZlY3RzTW9kZSA9XG4vKiAgICAgICAgICAgICAgKi9cbjE2O1xuXG4vLyBUT0RPOiBUaGlzIGlzIHByZXR0eSB3ZWxsIHN1cHBvcnRlZCBieSBicm93c2Vycy4gTWF5YmUgd2UgY2FuIGRyb3AgaXQuXG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cbiAgaWYgKGFzVWludCA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2coYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSWYgdGhvc2UgdmFsdWVzIGFyZSBjaGFuZ2VkIHRoYXQgcGFja2FnZSBzaG91bGQgYmUgcmVidWlsdCBhbmQgcmVkZXBsb3llZC5cblxudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgPVxuLyogICAgKi9cbjI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZSA9XG4vKiAgICAgICAgICAgICAqL1xuNDtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG44O1xudmFyIERlZmF1bHRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MjQwO1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzAwMjM0MjQ7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBSZXRyeUxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI2ODQzNTQ1NTtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTY7XG52YXIgSWRsZUxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICBjYXNlIFJldHJ5TGFuZTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBuZXh0TGFuZXMgfD0gcGVuZGluZ0xhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKGxhbmVzKSB7XG4gIHZhciBVcmdlbnRMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lO1xuICByZXR1cm4gKGxhbmVzICYgVXJnZW50TGFuZXMpID09PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFRyYW5zaXRpb25MYW5lcykgPT09IGxhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpIHtcblxuICB2YXIgU3luY0RlZmF1bHRMYW5lcyA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgfCBEZWZhdWx0TGFuZTtcbiAgcmV0dXJuIChsYW5lcyAmIFN5bmNEZWZhdWx0TGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykge1xuICAvLyBUaGlzIGlzIGEgc2VwYXJhdGUgY2hlY2sgZnJvbSBpbmNsdWRlc0Jsb2NraW5nTGFuZSBiZWNhdXNlIGEgbGFuZSBjYW5cbiAgLy8gZXhwaXJlIGFmdGVyIGEgcmVuZGVyIGhhcyBhbHJlYWR5IHN0YXJ0ZWQuXG4gIHJldHVybiAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpIHtcbiAgcmV0dXJuIChsYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICAvLyBDeWNsZSB0aHJvdWdoIHRoZSBsYW5lcywgYXNzaWduaW5nIGVhY2ggbmV3IHRyYW5zaXRpb24gdG8gdGhlIG5leHQgbGFuZS5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBtZWFucyBldmVyeSB0cmFuc2l0aW9uIGdldHMgaXRzIG93biBsYW5lLCB1bnRpbCB3ZVxuICAvLyBydW4gb3V0IG9mIGxhbmVzIGFuZCBjeWNsZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcuXG4gIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25MYW5lO1xuICBuZXh0VHJhbnNpdGlvbkxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0VHJhbnNpdGlvbkxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgbmV4dFRyYW5zaXRpb25MYW5lID0gVHJhbnNpdGlvbkxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcbiAgbmV4dFJldHJ5TGFuZSA8PD0gMTtcblxuICBpZiAoKG5leHRSZXRyeUxhbmUgJiBSZXRyeUxhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIG5leHRSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBnZXRzIGlubGluZWQuIE9ubHkgZXhpc3RzIHNvIHRvIGNvbW11bmljYXRlIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbiAgLy8gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSBiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBmZXdlc3Qgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKSB7XG4gIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbGFuZVRvSW5kZXgobGFuZSkge1xuICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLCBiKSB7XG4gIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhIHwgYjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiBzZXQgJiB+c3Vic2V0O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0TGFuZXMoYSwgYikge1xuICByZXR1cm4gYSAmIGI7XG59IC8vIFNlZW1zIHJlZHVuZGFudCwgYnV0IGl0IGNoYW5nZXMgdGhlIHR5cGUgZnJvbSBhIHNpbmdsZSBsYW5lICh1c2VkIGZvclxuLy8gdXBkYXRlcykgdG8gYSBncm91cCBvZiBsYW5lcyAodXNlZCBmb3IgZmx1c2hpbmcgd29yaykuXG5cbmZ1bmN0aW9uIGxhbmVUb0xhbmVzKGxhbmUpIHtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBoaWdoZXJQcmlvcml0eUxhbmUoYSwgYikge1xuICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJpdCByYW5nZXMgZGVjcmVhc2UgaW4gcHJpb3JpdHkgYXMgeW91IGdvIGxlZnQuXG4gIHJldHVybiBhICE9PSBOb0xhbmUgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICAvLyBJbnRlbnRpb25hbGx5IHB1c2hpbmcgb25lIGJ5IG9uZS5cbiAgLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xuICB2YXIgbGFuZU1hcCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVG90YWxMYW5lczsgaSsrKSB7XG4gICAgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmVNYXA7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgdXBkYXRlTGFuZSwgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHVwZGF0ZUxhbmU7IC8vIElmIHRoZXJlIGFyZSBhbnkgc3VzcGVuZGVkIHRyYW5zaXRpb25zLCBpdCdzIHBvc3NpYmxlIHRoaXMgbmV3IHVwZGF0ZVxuICAvLyBjb3VsZCB1bmJsb2NrIHRoZW0uIENsZWFyIHRoZSBzdXNwZW5kZWQgbGFuZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IHJlbmRlcmluZ1xuICAvLyB0aGVtIGFnYWluLlxuICAvL1xuICAvLyBUT0RPOiBXZSByZWFsbHkgb25seSBuZWVkIHRvIHVuc3VzcGVuZCBvbmx5IGxhbmVzIHRoYXQgYXJlIGluIHRoZVxuICAvLyBgc3VidHJlZUxhbmVzYCBvZiB0aGUgdXBkYXRlZCBmaWJlciwgb3IgdGhlIHVwZGF0ZSBsYW5lcyBvZiB0aGUgcmV0dXJuXG4gIC8vIHBhdGguIFRoaXMgd291bGQgZXhjbHVkZSBzdXNwZW5kZWQgdXBkYXRlcyBpbiBhbiB1bnJlbGF0ZWQgc2libGluZyB0cmVlLFxuICAvLyBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgdGhpcyB1cGRhdGUgdG8gdW5ibG9jayBpdC5cbiAgLy9cbiAgLy8gV2UgZG9uJ3QgZG8gdGhpcyBpZiB0aGUgaW5jb21pbmcgdXBkYXRlIGlzIGlkbGUsIGJlY2F1c2Ugd2UgbmV2ZXIgcHJvY2Vzc1xuICAvLyBpZGxlIHVwZGF0ZXMgdW50aWwgYWZ0ZXIgYWxsIHRoZSByZWd1bGFyIHVwZGF0ZXMgaGF2ZSBmaW5pc2hlZDsgdGhlcmUncyBub1xuICAvLyB3YXkgaXQgY291bGQgdW5ibG9jayBhIHRyYW5zaXRpb24uXG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IElkbGVMYW5lKSB7XG4gICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgodXBkYXRlTGFuZSk7IC8vIFdlIGNhbiBhbHdheXMgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRpbWVzdGFtcCBiZWNhdXNlIHdlIHByZWZlciB0aGUgbW9zdFxuICAvLyByZWNlbnQgZXZlbnQsIGFuZCB3ZSBhc3N1bWUgdGltZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5cbiAgZXZlbnRUaW1lc1tpbmRleF0gPSBldmVudFRpbWU7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcykge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcywgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcykge1xuICB2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lczsgLy8gTGV0J3MgdHJ5IGV2ZXJ5dGhpbmcgYWdhaW5cblxuICByb290LnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290Lm11dGFibGVSZWFkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcblxuICB2YXIgbGFuZXMgPSBub0xvbmdlclBlbmRpbmdMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdID0gTm9MYW5lcztcbiAgICBldmVudFRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgLy8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cbiAgLy8gaGF2ZSB0byBjb25zaWRlciBfdHJhbnNpdGl2ZV8gZW50YW5nbGVtZW50cy4gRm9yIGVhY2ggbGFuZSB0aGF0IGlzIGFscmVhZHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuICAvLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG4gIC8vXG4gIC8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbiAgLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4gIC8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuICAvLyBjb21tZW50aW5nIG91dCBvbmUgb2YgdGhlIGNvbmRpdGlvbnMgYmVsb3cuXG4gIHZhciByb290RW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gcm9vdEVudGFuZ2xlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcykge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblxuICAgIGlmICggLy8gSXMgdGhpcyBvbmUgb2YgdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbiAgICBsYW5lICYgZW50YW5nbGVkTGFuZXMgfCAvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gfD0gZW50YW5nbGVkTGFuZXM7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHJlbmRlckxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHJlbmRlckxhbmVzKTtcbiAgdmFyIGxhbmU7XG5cbiAgc3dpdGNoIChyZW5kZXJMYW5lKSB7XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgbGFuZSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgICBsYW5lID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICBjYXNlIFJldHJ5TGFuZTE6XG4gICAgY2FzZSBSZXRyeUxhbmUyOlxuICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICBjYXNlIFJldHJ5TGFuZTQ6XG4gICAgY2FzZSBSZXRyeUxhbmU1OlxuICAgICAgbGFuZSA9IFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVMYW5lOlxuICAgICAgbGFuZSA9IElkbGVIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGFscmVhZHkgZWl0aGVyIGEgaHlkcmF0aW9uIGxhbmUsIG9yIHNob3VsZG4ndFxuICAgICAgLy8gYmUgcmV0cmllZCBhdCBhIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgbGFuZSA9IE5vTGFuZTtcbiAgICAgIGJyZWFrO1xuICB9IC8vIENoZWNrIGlmIHRoZSBsYW5lIHdlIGNob3NlIGlzIHN1c3BlbmRlZC4gSWYgc28sIHRoYXQgaW5kaWNhdGVzIHRoYXQgd2VcbiAgLy8gYWxyZWFkeSBhdHRlbXB0ZWQgYW5kIGZhaWxlZCB0byBoeWRyYXRlIGF0IHRoYXQgbGV2ZWwuIEFsc28gY2hlY2sgaWYgd2UncmVcbiAgLy8gYWxyZWFkeSByZW5kZXJpbmcgdGhhdCBsYW5lLCB3aGljaCBpcyByYXJlIGJ1dCBjb3VsZCBoYXBwZW4uXG5cblxuICBpZiAoKGxhbmUgJiAocm9vdC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSkgIT09IE5vTGFuZSkge1xuICAgIC8vIEdpdmUgdXAgdHJ5aW5nIHRvIGh5ZHJhdGUgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgcmVuZGVyLlxuICAgIHJldHVybiBOb0xhbmU7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcblxuICBpZiAoIWlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgdXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgdXBkYXRlcnMgPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcblxuICAgIGlmICh1cGRhdGVycy5zaXplID4gMCkge1xuICAgICAgdXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsIHx8ICFtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25zRm9yTGFuZXMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xudmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cbiAgdHJ5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuXG5mdW5jdGlvbiBzZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZm4pIHtcbiAgX2F0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGZuO1xufVxuZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gIF9hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO1xufVxudmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZnVuY3Rpb24gc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZm47XG59XG52YXIgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDE7XG5mdW5jdGlvbiBzZXRHZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoZm4pIHtcbiAgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDEgPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eTtcbmZ1bmN0aW9uIHNldEF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5ID0gZm47XG59IC8vIFRPRE86IFVwZ3JhZGUgdGhpcyBkZWZpbml0aW9uIG9uY2Ugd2UncmUgb24gYSBuZXdlciB2ZXJzaW9uIG9mIEZsb3cgdGhhdFxuLy8gaGFzIHRoaXMgZGVmaW5pdGlvbiBidWlsdC1pbi5cblxudmFyIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSBmYWxzZTsgLy8gVGhlIHF1ZXVlIG9mIGRpc2NyZXRlIGV2ZW50cyB0byBiZSByZXBsYXllZC5cblxudmFyIHF1ZXVlZERpc2NyZXRlRXZlbnRzID0gW107IC8vIEluZGljYXRlcyBpZiBhbnkgY29udGludW91cyBldmVudCB0YXJnZXRzIGFyZSBub24tbnVsbCBmb3IgZWFybHkgYmFpbG91dC5cbi8vIGlmIHRoZSBsYXN0IHRhcmdldCB3YXMgZGVoeWRyYXRlZC5cblxudmFyIHF1ZXVlZEZvY3VzID0gbnVsbDtcbnZhciBxdWV1ZWREcmFnID0gbnVsbDtcbnZhciBxdWV1ZWRNb3VzZSA9IG51bGw7IC8vIEZvciBwb2ludGVyIGV2ZW50cyB0aGVyZSBjYW4gYmUgb25lIGxhdGVzdCBldmVudCBwZXIgcG9pbnRlcklkLlxuXG52YXIgcXVldWVkUG9pbnRlcnMgPSBuZXcgTWFwKCk7XG52YXIgcXVldWVkUG9pbnRlckNhcHR1cmVzID0gbmV3IE1hcCgpOyAvLyBXZSBjb3VsZCBjb25zaWRlciByZXBsYXlpbmcgc2VsZWN0aW9uY2hhbmdlIGFuZCB0b3VjaG1vdmVzIHRvby5cblxudmFyIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cyA9IFtdO1xudmFyIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyA9IFsnbW91c2Vkb3duJywgJ21vdXNldXAnLCAndG91Y2hjYW5jZWwnLCAndG91Y2hlbmQnLCAndG91Y2hzdGFydCcsICdhdXhjbGljaycsICdkYmxjbGljaycsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJ1cCcsICdkcmFnZW5kJywgJ2RyYWdzdGFydCcsICdkcm9wJywgJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9uc3RhcnQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdpbnB1dCcsICd0ZXh0SW5wdXQnLCAvLyBJbnRlbnRpb25hbGx5IGNhbWVsQ2FzZVxuJ2NvcHknLCAnY3V0JywgJ3Bhc3RlJywgJ2NsaWNrJywgJ2NoYW5nZScsICdjb250ZXh0bWVudScsICdyZXNldCcsICdzdWJtaXQnXTtcbmZ1bmN0aW9uIGlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0Q29udGFpbmVyczogW3RhcmdldENvbnRhaW5lcl1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5wcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpOyAvLyBXZSBkb24ndCBjdXJyZW50bHkgaGF2ZSBhIHdheSB0byBpbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2ZcbiAgICAgICAgICAvLyBhIHJvb3Qgb3RoZXIgdGhhbiBzeW5jLlxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFRPRE86IFRoaXMgd2lsbCByZWFkIHRoZSBwcmlvcml0eSBpZiBpdCdzIGRpc3BhdGNoZWQgYnkgdGhlIFJlYWN0XG4gIC8vIGV2ZW50IHN5c3RlbSBidXQgbm90IG5hdGl2ZSBldmVudHMuIFNob3VsZCByZWFkIHdpbmRvdy5ldmVudC50eXBlLCBsaWtlXG4gIC8vIHdlIGRvIGZvciB1cGRhdGVzIChnZXRDdXJyZW50RXZlbnRQcmlvcml0eSkuXG4gIHZhciB1cGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSQxKCk7XG4gIHZhciBxdWV1ZWRUYXJnZXQgPSB7XG4gICAgYmxvY2tlZE9uOiBudWxsLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHByaW9yaXR5OiB1cGRhdGVQcmlvcml0eVxuICB9O1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBTdG9wIG9uY2Ugd2UgaGl0IHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBsb3dlciBwcmlvcml0eSB0aGFuXG4gICAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkodXBkYXRlUHJpb3JpdHksIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zcGxpY2UoaSwgMCwgcXVldWVkVGFyZ2V0KTtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpIHtcbiAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0YXJnZXRDb250YWluZXJzID0gcXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lciA9IHRhcmdldENvbnRhaW5lcnNbMF07XG4gICAgdmFyIG5leHRCbG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50LmRvbUV2ZW50TmFtZSwgcXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7XG5cbiAgICBpZiAobmV4dEJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBxdWV1ZWRFdmVudC5uYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50Q2xvbmUgPSBuZXcgbmF0aXZlRXZlbnQuY29uc3RydWN0b3IobmF0aXZlRXZlbnQudHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgICAgICBzZXRSZXBsYXlpbmdFdmVudChuYXRpdmVFdmVudENsb25lKTtcbiAgICAgICAgbmF0aXZlRXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICAgIHJlc2V0UmVwbGF5aW5nRXZlbnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC4gVHJ5IGFnYWluIGxhdGVyLlxuICAgICAgdmFyIF9maWJlcjMgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHRCbG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMyAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihfZmliZXIzKTtcbiAgICAgIH1cblxuICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFRoaXMgdGFyZ2V0IGNvbnRhaW5lciB3YXMgc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQuIFRyeSB0aGUgbmV4dC5cblxuXG4gICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcChxdWV1ZWRFdmVudCwga2V5LCBtYXApIHtcbiAgaWYgKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpKSB7XG4gICAgbWFwLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheVVuYmxvY2tlZEV2ZW50cygpIHtcbiAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlO1xuXG5cbiAgaWYgKHF1ZXVlZEZvY3VzICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRm9jdXMpKSB7XG4gICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICB9XG5cbiAgaWYgKHF1ZXVlZERyYWcgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWREcmFnKSkge1xuICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkTW91c2UpKSB7XG4gICAgcXVldWVkTW91c2UgPSBudWxsO1xuICB9XG5cbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBudWxsO1xuXG4gICAgaWYgKCFoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0KSB7XG4gICAgICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gdHJ1ZTsgLy8gU2NoZWR1bGUgYSBjYWxsYmFjayB0byBhdHRlbXB0IHJlcGxheWluZyBhcyBtYW55IGV2ZW50cyBhcyBhcmVcbiAgICAgIC8vIG5vdyB1bmJsb2NrZWQuIFRoaXMgZmlyc3QgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHVuYmxvY2tlZCB5ZXQuXG4gICAgICAvLyBXZSBjb3VsZCBjaGVjayBpdCBlYXJseSB0byBhdm9pZCBzY2hlZHVsaW5nIGFuIHVubmVjZXNzYXJ5IGNhbGxiYWNrLlxuXG4gICAgICBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksIHJlcGxheVVuYmxvY2tlZEV2ZW50cyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5SWZCbG9ja2VkT24odW5ibG9ja2VkKSB7XG4gIC8vIE1hcmsgYW55dGhpbmcgdGhhdCB3YXMgYmxvY2tlZCBvbiB0aGlzIGFzIG5vIGxvbmdlciBibG9ja2VkXG4gIC8vIGFuZCBlbGlnaWJsZSBmb3IgYSByZXBsYXkuXG4gIGlmIChxdWV1ZWREaXNjcmV0ZUV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERpc2NyZXRlRXZlbnRzWzBdLCB1bmJsb2NrZWQpOyAvLyBUaGlzIGlzIGEgZXhwb25lbnRpYWwgc2VhcmNoIGZvciBlYWNoIGJvdW5kYXJ5IHRoYXQgY29tbWl0cy4gSSB0aGluayBpdCdzXG4gICAgLy8gd29ydGggaXQgYmVjYXVzZSB3ZSBleHBlY3QgdmVyeSBmZXcgZGlzY3JldGUgZXZlbnRzIHRvIHF1ZXVlIHVwIGFuZCBvbmNlXG4gICAgLy8gd2UgYXJlIGFjdHVhbGx5IGZ1bGx5IHVuYmxvY2tlZCBpdCB3aWxsIGJlIGZhc3QgdG8gcmVwbGF5IHRoZW0uXG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVldWVkRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1tpXTtcblxuICAgICAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXVlZEZvY3VzICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEZvY3VzLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZERyYWcgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRHJhZywgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIGlmIChxdWV1ZWRNb3VzZSAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSwgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIHZhciB1bmJsb2NrID0gZnVuY3Rpb24gKHF1ZXVlZEV2ZW50KSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgfTtcblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKHVuYmxvY2spO1xuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaCh1bmJsb2NrKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBxdWV1ZWRUYXJnZXQgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbX2ldO1xuXG4gICAgaWYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG5leHRFeHBsaWNpdFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXTtcblxuICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLlxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChuZXh0RXhwbGljaXRUYXJnZXQpO1xuXG4gICAgICBpZiAobmV4dEV4cGxpY2l0VGFyZ2V0LmJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSB1bmJsb2NrZWQuXG4gICAgICAgIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZzsgLy8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xuXG52YXIgX2VuYWJsZWQgPSB0cnVlOyAvLyBUaGlzIGlzIGV4cG9ydGVkIGluIEZCIGJ1aWxkcyBmb3IgdXNlIGJ5IGxlZ2FjeSBGQiBsYXllciBpbmZyYS5cbi8vIFdlJ2QgbGlrZSB0byByZW1vdmUgdGhpcyBidXQgaXQncyBub3QgY2xlYXIgaWYgdGhpcyBpcyBzYWZlLlxuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBldmVudFByaW9yaXR5ID0gZ2V0RXZlbnRQcmlvcml0eShkb21FdmVudE5hbWUpO1xuICB2YXIgbGlzdGVuZXJXcmFwcGVyO1xuXG4gIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hDb250aW51b3VzRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHkpO1xuICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgZGlzcGF0Y2hFdmVudFdpdGhFbmFibGVDYXB0dXJlUGhhc2VTZWxlY3RpdmVIeWRyYXRpb25XaXRob3V0RGlzY3JldGVFdmVudFJlcGxheShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRXaXRoRW5hYmxlQ2FwdHVyZVBoYXNlU2VsZWN0aXZlSHlkcmF0aW9uV2l0aG91dERpc2NyZXRlRXZlbnRSZXBsYXkoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBibG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCByZXR1cm5fdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKTtcbiAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSkge1xuICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBuZWVkIHRvIGNsZWFyIG9ubHkgaWYgd2UgZGlkbid0IHF1ZXVlIGJlY2F1c2VcbiAgLy8gcXVldWVpbmcgaXMgYWNjdW11bGF0aXZlLlxuXG5cbiAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcblxuICBpZiAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UgJiYgaXNEaXNjcmV0ZUV2ZW50VGhhdFJlcXVpcmVzSHlkcmF0aW9uKGRvbUV2ZW50TmFtZSkpIHtcbiAgICB3aGlsZSAoYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgICAgaWYgKG5leHRCbG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHJldHVybl90YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiA9PT0gYmxvY2tlZE9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgIH1cblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbiAgLy8gaW4gY2FzZSB0aGUgZXZlbnQgc3lzdGVtIG5lZWRzIHRvIHRyYWNlIGl0LlxuXG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIG51bGwsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbnZhciByZXR1cm5fdGFyZ2V0SW5zdCA9IG51bGw7IC8vIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG4vLyBUaGUgcmV0dXJuX3RhcmdldEluc3QgZmllbGQgYWJvdmUgaXMgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZS5cblxuZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gVE9ETzogV2FybiBpZiBfZW5hYmxlZCBpcyBmYWxzZS5cbiAgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgaGFwcGVucyBkdXJpbmcgYSByZXBsYXkgc29tZXRoaW5nIHdlbnQgd3JvbmcgYW5kIGl0IG1pZ2h0IGJsb2NrXG4gICAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbS5cbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gdGFyZ2V0SW5zdCkge1xuICAgICAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAgICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDsgLy8gV2UncmUgbm90IGJsb2NrZWQgb24gYW55dGhpbmcuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIC8vIFVzZWQgYnkgU2ltcGxlRXZlbnRQbHVnaW46XG4gICAgY2FzZSAnY2FuY2VsJzpcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY2xvc2UnOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgY2FzZSAnZHJhZ3N0YXJ0JzpcbiAgICBjYXNlICdkcm9wJzpcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ2ludmFsaWQnOlxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZXVwJzpcbiAgICBjYXNlICdwYXN0ZSc6XG4gICAgY2FzZSAncGF1c2UnOlxuICAgIGNhc2UgJ3BsYXknOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgIGNhc2UgJ3JhdGVjaGFuZ2UnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICBjYXNlICdyZXNpemUnOlxuICAgIGNhc2UgJ3NlZWtlZCc6XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgIGNhc2UgJ3ZvbHVtZWNoYW5nZSc6IC8vIFVzZWQgYnkgcG9seWZpbGxzOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSAnY2hhbmdlJzpcbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzogLy8gT25seSBlbmFibGVDcmVhdGVFdmVudEhhbmRsZUFQSTpcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgJ2JlZm9yZWJsdXInOlxuICAgIGNhc2UgJ2FmdGVyYmx1cic6IC8vIE5vdCB1c2VkIGJ5IFJlYWN0IGJ1dCBjb3VsZCBiZSBieSB1c2VyIGNvZGU6XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICBjYXNlICdiZWZvcmVpbnB1dCc6XG4gICAgY2FzZSAnYmx1cic6XG4gICAgY2FzZSAnZnVsbHNjcmVlbmNoYW5nZSc6XG4gICAgY2FzZSAnZm9jdXMnOlxuICAgIGNhc2UgJ2hhc2hjaGFuZ2UnOlxuICAgIGNhc2UgJ3BvcHN0YXRlJzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgY2FzZSAnc2Nyb2xsJzpcbiAgICBjYXNlICd0b2dnbGUnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAnd2hlZWwnOiAvLyBOb3QgdXNlZCBieSBSZWFjdCBidXQgY291bGQgYmUgYnkgdXNlciBjb2RlOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuXG4gICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBTY2hlZHVsZXIgY2FsbGJhY2suXG4gICAgICAgIC8vIEV2ZW50dWFsbHkgdGhpcyBtZWNoYW5pc20gd2lsbCBiZSByZXBsYWNlZCBieSBhIGNoZWNrXG4gICAgICAgIC8vIG9mIHRoZSBjdXJyZW50IHByaW9yaXR5IG9uIHRoZSBuYXRpdmUgc2NoZWR1bGVyLlxuICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO1xuXG4gICAgICAgIHN3aXRjaCAoc2NoZWR1bGVyUHJpb3JpdHkpIHtcbiAgICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcblxuICAgICAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG5cbiAgICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgTG93U2NoZWR1bGVyUHJpb3JpdHksIHNvbWVob3cuIE1heWJlIHRoZSBzYW1lIGxhbmUgYXMgaHlkcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuXG4gICAgICAgICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICAgICAgICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9KTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICByb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIHN0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNldCgpIHtcbiAgcm9vdCA9IG51bGw7XG4gIHN0YXJ0VGV4dCA9IG51bGw7XG4gIGZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG5cbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTsgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfSAvLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4gIC8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cblxuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9IC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuXG5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYSBmYWN0b3J5IHNvIHRoYXQgd2UgaGF2ZSBkaWZmZXJlbnQgcmV0dXJuZWQgY29uc3RydWN0b3JzLlxuLy8gSWYgd2UgaGFkIGEgc2luZ2xlIGNvbnN0cnVjdG9yLCBpdCB3b3VsZCBiZSBtZWdhbW9ycGhpYyBhbmQgZW5naW5lcyB3b3VsZCBkZW9wdC5cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAgICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAgICpcbiAgICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAgICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gICAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAgICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAgICpcbiAgICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICAgKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICAgKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gICAqL1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLCByZWFjdEV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW19wcm9wTmFtZV07XG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdGhpc1tfcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuXG4gICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3NpZ24oU3ludGhldGljQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7Ly8gTW9kZXJuIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gIH0pO1xuICByZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgZXZlbnRQaGFzZTogMCxcbiAgYnViYmxlczogMCxcbiAgY2FuY2VsYWJsZTogMCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gIGlzVHJ1c3RlZDogMFxufTtcbnZhciBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIHZpZXc6IDAsXG4gIGRldGFpbDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSk7XG52YXIgbGFzdE1vdmVtZW50WDtcbnZhciBsYXN0TW92ZW1lbnRZO1xudmFyIGxhc3RNb3VzZUV2ZW50O1xuXG5mdW5jdGlvbiB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCkge1xuICBpZiAoZXZlbnQgIT09IGxhc3RNb3VzZUV2ZW50KSB7XG4gICAgaWYgKGxhc3RNb3VzZUV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblg7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSAwO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IDA7XG4gICAgfVxuXG4gICAgbGFzdE1vdXNlRXZlbnQgPSBldmVudDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cblxudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YVRyYW5zZmVyOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgcmVsYXRlZFRhcmdldDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cblxudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xuXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xuLy8gSGFwcGVucyB0byBzaGFyZSB0aGUgc2FtZSBsaXN0IGZvciBub3cuXG5cbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xuXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xuXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcblxuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfSAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG5cblxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpOyAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cblxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cblxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07IC8vIE9sZGVyIGJyb3dzZXJzIChTYWZhcmkgPD0gMTAsIGlPUyBTYWZhcmkgPD0gMTAuMikgZG8gbm90IHN1cHBvcnRcbi8vIGdldE1vZGlmaWVyU3RhdGUuIElmIGdldE1vZGlmaWVyU3RhdGUgaXMgbm90IHN1cHBvcnRlZCwgd2UgbWFwIGl0IHRvIGEgc2V0IG9mXG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50LiBJbiB0aGlzIGNhc2UsIExvY2sta2V5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG5cbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG5cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cblxudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBwb2ludGVySWQ6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHByZXNzdXJlOiAwLFxuICB0YW5nZW50aWFsUHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiAwLFxuICBpc1ByaW1hcnk6IDBcbn0pO1xuXG52YXIgU3ludGhldGljUG9pbnRlckV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoUG9pbnRlckV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xuXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICB0b3VjaGVzOiAwLFxuICB0YXJnZXRUb3VjaGVzOiAwLFxuICBjaGFuZ2VkVG91Y2hlczogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb3VjaEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cblxudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogMCxcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IDBcbn0pO1xuXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxuXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcblxuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59IC8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG5cblxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlOyAvLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkJlZm9yZUlucHV0JywgWydjb21wb3NpdGlvbmVuZCcsICdrZXlwcmVzcycsICd0ZXh0SW5wdXQnLCAncGFzdGUnXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsIFsnY29tcG9zaXRpb25lbmQnLCAnZm9jdXNvdXQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdtb3VzZWRvd24nXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblN0YXJ0JywgWydjb21wb3NpdGlvbnN0YXJ0JywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25VcGRhdGUnLCBbJ2NvbXBvc2l0aW9udXBkYXRlJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xufSAvLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG5cblxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cblxuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJiAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25TdGFydCc7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25FbmQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb251cGRhdGUnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uVXBkYXRlJztcbiAgfVxufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcblxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59IC8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cblxuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gJ29uQ29tcG9zaXRpb25TdGFydCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uRW5kJztcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSAnb25Db21wb3NpdGlvblN0YXJ0Jykge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25FbmQnKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgZXZlbnRUeXBlKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsIGRvbUV2ZW50TmFtZSwgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcblxuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTsgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICdjb21wb3NpdGlvbmVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cblxuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgJ29uQmVmb3JlSW5wdXQnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsICdiZWZvcmVpbnB1dCcsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG4gICAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KSB7XG4gIGlmICghY2FuVXNlRE9NKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDEoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25DaGFuZ2UnLCBbJ2NoYW5nZScsICdjbGljaycsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2lucHV0JywgJ2tleWRvd24nLCAna2V5dXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCAnb25DaGFuZ2UnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoJ29uQ2hhbmdlJywgJ2NoYW5nZScsIG51bGwsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG5cblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOyAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cblxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSkge1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuXG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG5cblxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3VzaW4nKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn0gLy8gRm9yIElFOCBhbmQgSUU5LlxuXG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2tleXVwJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdpbnB1dCcgfHwgZG9tRXZlbnROYW1lID09PSAnY2hhbmdlJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCAnbnVtYmVyJywgbm9kZS52YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcblxuICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gIH1cblxuICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCk7XG5cbiAgICBpZiAoaW5zdCkge1xuICAgICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICB9IC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCkge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvbk1vdXNlRW50ZXInLCBbJ21vdXNlb3V0JywgJ21vdXNlb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUxlYXZlJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uUG9pbnRlckVudGVyJywgWydwb2ludGVyb3V0JywgJ3BvaW50ZXJvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJMZWF2ZScsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbn1cbi8qKlxuICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBpc092ZXJFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3ZlcicgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm92ZXInO1xuICB2YXIgaXNPdXRFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JztcblxuICBpZiAoaXNPdmVyRXZlbnQgJiYgIWlzUmVwbGF5aW5nRXZlbnQobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2ldO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8ICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gb3V0ZXJOb2RlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0OyAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG5cblxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5cblxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cblxuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgLy8gRWRnZSBmYWlscyB3aXRoIFwiT2JqZWN0IGV4cGVjdGVkXCIgaW4gc29tZSBzY2VuYXJpb3MuXG4gIC8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4gIC8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuXG4gIGlmICghd2luLmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpOyAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50ICYmIGNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZS5cbiAgICAvLyBTYWZhcmkgd2lsbCBzaG93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGFjY2VzcyByZXN1bHRzIGluIFwiQmxvY2tlZCBhIGZyYW1lIHdpdGggb3JpZ2luXCIuIGUuZzpcbiAgICAvLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIC8vIEEgc2FmZXR5IHdheSBpcyB0byBhY2Nlc3Mgb25lIG9mIHRoZSBjcm9zcyBvcmlnaW4gcHJvcGVydGllczogV2luZG93IG9yIExvY2F0aW9uXG4gICAgLy8gV2hpY2ggbWlnaHQgcmVzdWx0IGluIFwiU2VjdXJpdHlFcnJvclwiIERPTSBFeGNlcHRpb24gYW5kIGl0IGlzIGNvbXBhdGlibGUgdG8gU2FmYXJpLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbiAgICByZXR1cm4gdHlwZW9mIGlmcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKSB7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgaWYgKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KHdpbi5kb2N1bWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAndGV4dCcgfHwgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fCBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8IGVsZW0udHlwZSA9PT0gJ3VybCcgfHwgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG5cbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH0gLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcblxuXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbjtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uU2VsZWN0JywgWydmb2N1c291dCcsICdjb250ZXh0bWVudScsICdkcmFnZW5kJywgJ2ZvY3VzaW4nLCAna2V5ZG93bicsICdrZXl1cCcsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdzZWxlY3Rpb25jaGFuZ2UnXSk7XG59XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldERvY3VtZW50KGV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBldmVudFRhcmdldC53aW5kb3cgPT09IGV2ZW50VGFyZ2V0ID8gZXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IGV2ZW50VGFyZ2V0IDogZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbn1cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgdmFyIGRvYyA9IGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuXG5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO1xuXG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCAnb25TZWxlY3QnKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvblNlbGVjdCcsICdzZWxlY3QnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgICBldmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7IC8vIE5PVEU6IENhcGl0YWxpemF0aW9uIGlzIGltcG9ydGFudCBpbiB0aGlzIGxpc3QhXG4vL1xuLy8gRS5nLiBpdCBuZWVkcyBcInBvaW50ZXJEb3duXCIsIG5vdCBcInBvaW50ZXJkb3duXCIuXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2UgZGVyaXZlIGJvdGggUmVhY3QgbmFtZSAoXCJvblBvaW50ZXJEb3duXCIpXG4vLyBhbmQgRE9NIG5hbWUgKFwicG9pbnRlcmRvd25cIikgZnJvbSB0aGUgc2FtZSBsaXN0LlxuLy9cbi8vIEV4Y2VwdGlvbnMgdGhhdCBkb24ndCBtYXRjaCB0aGlzIGNvbnZlbnRpb24gYXJlIGxpc3RlZCBzZXBhcmF0ZWx5LlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgc2ltcGxlRXZlbnRQbHVnaW5FdmVudHMgPSBbJ2Fib3J0JywgJ2F1eENsaWNrJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwb2ludGVyQ2FuY2VsJywgJ3BvaW50ZXJEb3duJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlck92ZXInLCAncG9pbnRlclVwJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzaXplJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaFN0YXJ0JywgJ3ZvbHVtZUNoYW5nZScsICdzY3JvbGwnLCAndG9nZ2xlJywgJ3RvdWNoTW92ZScsICd3YWl0aW5nJywgJ3doZWVsJ107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLCByZWFjdE5hbWUpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlYWN0TmFtZSwgW2RvbUV2ZW50TmFtZV0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50cygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldmVudE5hbWUgPSBzaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXTtcbiAgICB2YXIgZG9tRXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudE5hbWVbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50TmFtZS5zbGljZSgxKTtcbiAgICByZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwgJ29uJyArIGNhcGl0YWxpemVkRXZlbnQpO1xuICB9IC8vIFNwZWNpYWwgY2FzZXMgd2hlcmUgZXZlbnQgbmFtZXMgZG9uJ3QgbWF0Y2guXG5cblxuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9FTkQsICdvbkFuaW1hdGlvbkVuZCcpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9JVEVSQVRJT04sICdvbkFuaW1hdGlvbkl0ZXJhdGlvbicpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwgJ29uQW5pbWF0aW9uU3RhcnQnKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudCgnZGJsY2xpY2snLCAnb25Eb3VibGVDbGljaycpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KCdmb2N1c2luJywgJ29uRm9jdXMnKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudCgnZm9jdXNvdXQnLCAnb25CbHVyJyk7XG4gIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9FTkQsICdvblRyYW5zaXRpb25FbmQnKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcmVzZWUgcmlnaHQgbm93LlxuXG4gIGlmIChzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zKSB7XG4gICAgZXh0cmFjdEV2ZW50cyQyKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGV4dHJhY3RFdmVudHMkMyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn0gLy8gTGlzdCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIGluZGl2aWR1YWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50cy5cblxuXG52YXIgbWVkaWFFdmVudFR5cGVzID0gWydhYm9ydCcsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ2R1cmF0aW9uY2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2xvYWRlZGRhdGEnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlY2hhbmdlJywgJ3Jlc2l6ZScsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd2b2x1bWVjaGFuZ2UnLCAnd2FpdGluZyddOyAvLyBXZSBzaG91bGQgbm90IGRlbGVnYXRlIHRoZXNlIGV2ZW50cyB0byB0aGUgY29udGFpbmVyLCBidXQgcmF0aGVyXG4vLyBzZXQgdGhlbSBvbiB0aGUgYWN0dWFsIHRhcmdldCBlbGVtZW50IGl0c2VsZi4gVGhpcyBpcyBwcmltYXJpbHlcbi8vIGJlY2F1c2UgdGhlc2UgZXZlbnRzIGRvIG5vdCBjb25zaXN0ZW50bHkgYnViYmxlIGluIHRoZSBET00uXG5cbnZhciBub25EZWxlZ2F0ZWRFdmVudHMgPSBuZXcgU2V0KFsnY2FuY2VsJywgJ2Nsb3NlJywgJ2ludmFsaWQnLCAnbG9hZCcsICdzY3JvbGwnLCAndG9nZ2xlJ10uY29uY2F0KG1lZGlhRXZlbnRUeXBlcykpO1xuXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcHJldmlvdXNJbnN0YW5jZTtcblxuICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICBmb3IgKHZhciBpID0gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IGRpc3BhdGNoTGlzdGVuZXJzW2ldLFxuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcblxuICAgICAgaWYgKGluc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRfaSA9IGRpc3BhdGNoTGlzdGVuZXJzW19pXSxcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsXG4gICAgICAgICAgX2N1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBfbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kubGlzdGVuZXI7XG5cbiAgICAgIGlmIChfaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgX2xpc3RlbmVyLCBfY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgICBldmVudCA9IF9kaXNwYXRjaFF1ZXVlJGkuZXZlbnQsXG4gICAgICAgIGxpc3RlbmVycyA9IF9kaXNwYXRjaFF1ZXVlJGkubGlzdGVuZXJzO1xuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBsaXN0ZW5lcnMsIGluQ2FwdHVyZVBoYXNlKTsgLy8gIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICB9IC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuXG5cbiAgcmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBleHRyYWN0RXZlbnRzJDUoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEVsZW1lbnQpIHtcbiAge1xuICAgIGlmICghbm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpKSB7XG4gICAgICBlcnJvcignRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGRvbUV2ZW50TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXRFbGVtZW50KTtcbiAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBkb21FdmVudE5hbWUsIElTX05PTl9ERUxFR0FURUQsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCB0YXJnZXQpIHtcbiAge1xuICAgIGlmIChub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgJiYgIWlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpIHtcbiAgICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBhIGxpc3RlblRvTmF0aXZlRXZlbnQoKSBjYWxsIGZvciBcIiVzXCIgaW4gdGhlIGJ1YmJsZSBwaGFzZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBkb21FdmVudE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFN5c3RlbUZsYWdzID0gMDtcblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfQ0FQVFVSRV9QSEFTRTtcbiAgfVxuXG4gIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbn0gLy8gVGhpcyBpcyBvbmx5IHVzZWQgYnkgY3JlYXRlRXZlbnRIYW5kbGUgd2hlbiB0aGVcbnZhciBsaXN0ZW5pbmdNYXJrZXIgPSAnX3JlYWN0TGlzdGVuaW5nJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgaWYgKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgLy8gV2UgaGFuZGxlIHNlbGVjdGlvbmNoYW5nZSBzZXBhcmF0ZWx5IGJlY2F1c2UgaXRcbiAgICAgIC8vIGRvZXNuJ3QgYnViYmxlIGFuZCBuZWVkcyB0byBiZSBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2VsZWN0aW9uY2hhbmdlJykge1xuICAgICAgICBpZiAoIW5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBmYWxzZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIHRydWUsIHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4gICAgaWYgKG93bmVyRG9jdW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgYWxzbyBuZWVkcyBkZWR1cGxpY2F0aW9uXG4gICAgICAvLyBidXQgaXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAgaWYgKCFvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl0pIHtcbiAgICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudCgnc2VsZWN0aW9uY2hhbmdlJywgZmFsc2UsIG93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciwgaXNEZWZlcnJlZExpc3RlbmVyRm9yTGVnYWN5RkJTdXBwb3J0KSB7XG4gIHZhciBsaXN0ZW5lciA9IGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKTsgLy8gSWYgcGFzc2l2ZSBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCwgdGhlbiB0aGUgZXZlbnQgd2lsbCBiZVxuICAvLyBhY3RpdmUgYW5kIG5vdCBwYXNzaXZlLlxuXG4gIHZhciBpc1Bhc3NpdmVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBpZiAocGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBCcm93c2VycyBpbnRyb2R1Y2VkIGFuIGludGVydmVudGlvbiwgbWFraW5nIHRoZXNlIGV2ZW50c1xuICAgIC8vIHBhc3NpdmUgYnkgZGVmYXVsdCBvbiBkb2N1bWVudC4gUmVhY3QgZG9lc24ndCBiaW5kIHRoZW1cbiAgICAvLyB0byBkb2N1bWVudCBhbnltb3JlLCBidXQgY2hhbmdpbmcgdGhpcyBub3cgd291bGQgdW5kb1xuICAgIC8vIHRoZSBwZXJmb3JtYW5jZSB3aW5zIGZyb20gdGhlIGNoYW5nZS4gU28gd2UgZW11bGF0ZVxuICAgIC8vIHRoZSBleGlzdGluZyBiZWhhdmlvciBtYW51YWxseSBvbiB0aGUgcm9vdHMgbm93LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTk2NTFcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAndG91Y2hzdGFydCcgfHwgZG9tRXZlbnROYW1lID09PSAndG91Y2htb3ZlJyB8fCBkb21FdmVudE5hbWUgPT09ICd3aGVlbCcpIHtcbiAgICAgIGlzUGFzc2l2ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0YXJnZXRDb250YWluZXIgPSAgdGFyZ2V0Q29udGFpbmVyO1xuICB2YXIgdW5zdWJzY3JpYmVMaXN0ZW5lcjsgLy8gV2hlbiBsZWdhY3lGQlN1cHBvcnQgaXMgZW5hYmxlZCwgaXQncyBmb3Igd2hlbiB3ZVxuXG5cbiAgaWYgKGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lciwgaXNQYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzUGFzc2l2ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lciwgaXNQYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHJldHVybiBncmFuZENvbnRhaW5lciA9PT0gdGFyZ2V0Q29udGFpbmVyIHx8IGdyYW5kQ29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgZ3JhbmRDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBhbmNlc3Rvckluc3QgPSB0YXJnZXRJbnN0O1xuXG4gIGlmICgoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFKSA9PT0gMCAmJiAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX05PTl9ERUxFR0FURUQpID09PSAwKSB7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lck5vZGUgPSB0YXJnZXRDb250YWluZXI7IC8vIElmIHdlIGFyZSB1c2luZyB0aGUgbGVnYWN5IEZCIHN1cHBvcnQgZmxhZywgd2VcblxuICAgIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGUgYmVsb3cgbG9naWMgYXR0ZW1wdHMgdG8gd29yayBvdXQgaWYgd2UgbmVlZCB0byBjaGFuZ2VcbiAgICAgIC8vIHRoZSB0YXJnZXQgZmliZXIgdG8gYSBkaWZmZXJlbnQgYW5jZXN0b3IuIFdlIGhhZCBzaW1pbGFyIGxvZ2ljXG4gICAgICAvLyBpbiB0aGUgbGVnYWN5IGV2ZW50IHN5c3RlbSwgZXhjZXB0IHRoZSBiaWcgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAvLyBzeXN0ZW1zIGlzIHRoYXQgdGhlIG1vZGVybiBldmVudCBzeXN0ZW0gbm93IGhhcyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgLy8gYXR0YWNoZWQgdG8gZWFjaCBSZWFjdCBSb290IGFuZCBSZWFjdCBQb3J0YWwgUm9vdC4gVG9nZXRoZXIsXG4gICAgICAvLyB0aGUgRE9NIG5vZGVzIHJlcHJlc2VudGluZyB0aGVzZSByb290cyBhcmUgdGhlIFwicm9vdENvbnRhaW5lclwiLlxuICAgICAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBhbmNlc3RvciBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLCB3ZSB0cmF2ZXJzZVxuICAgICAgLy8gdXAgdGhlIGZpYmVyIHRyZWUgZnJvbSB0aGUgdGFyZ2V0IGluc3RhbmNlIGFuZCBhdHRlbXB0IHRvIGZpbmRcbiAgICAgIC8vIHJvb3QgYm91bmRhcmllcyB0aGF0IG1hdGNoIHRoYXQgb2Ygb3VyIGN1cnJlbnQgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBJZiB3ZSBmaW5kIHRoYXQgXCJyb290Q29udGFpbmVyXCIsIHdlIGZpbmQgdGhlIHBhcmVudCBmaWJlclxuICAgICAgLy8gc3ViLXRyZWUgZm9yIHRoYXQgcm9vdCBhbmQgbWFrZSB0aGF0IG91ciBhbmNlc3RvciBpbnN0YW5jZS5cbiAgICAgIHZhciBub2RlID0gdGFyZ2V0SW5zdDtcblxuICAgICAgbWFpbkxvb3A6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVUYWcgPSBub2RlLnRhZztcblxuICAgICAgICBpZiAobm9kZVRhZyA9PT0gSG9zdFJvb3QgfHwgbm9kZVRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgaWYgKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGNvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGlzIGEgcG9ydGFsLCBidXQgaXQncyBub3QgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IuXG4gICAgICAgICAgICAvLyBOb3JtYWxseSBwb3J0YWxzIGhhbmRsZSB0aGVpciBvd24gZXZlbnRzIGFsbCB0aGUgd2F5IGRvd24gdG8gdGhlIHJvb3QuXG4gICAgICAgICAgICAvLyBTbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzdG9wIG5vdy4gSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB0aGlzIHBvcnRhbFxuICAgICAgICAgICAgLy8gd2FzIHBhcnQgb2YgKm91ciogcm9vdC5cbiAgICAgICAgICAgIHZhciBncmFuZE5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgICAgICAgd2hpbGUgKGdyYW5kTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZ3JhbmRUYWcgPSBncmFuZE5vZGUudGFnO1xuXG4gICAgICAgICAgICAgIGlmIChncmFuZFRhZyA9PT0gSG9zdFJvb3QgfHwgZ3JhbmRUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhbmRDb250YWluZXIgPSBncmFuZE5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoZ3JhbmRDb250YWluZXIsIHRhcmdldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yIGFuZCB3ZSBmb3VuZCBpdCBhc1xuICAgICAgICAgICAgICAgICAgLy8gYSBwYXJlbnQgb2YgdGhlIFBvcnRhbC4gVGhhdCBtZWFucyB3ZSBjYW4gaWdub3JlIGl0IGJlY2F1c2UgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBQb3J0YWwgd2lsbCBidWJibGUgdGhyb3VnaCB0byB1cy5cbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmFuZE5vZGUgPSBncmFuZE5vZGUucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gTm93IHdlIG5lZWQgdG8gZmluZCBpdCdzIGNvcnJlc3BvbmRpbmcgaG9zdCBmaWJlciBpbiB0aGUgb3RoZXJcbiAgICAgICAgICAvLyB0cmVlLiBUbyBkbyB0aGlzIHdlIGNhbiB1c2UgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsIGJ1dCB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gdmFsaWRhdGUgdGhhdCB0aGUgZmliZXIgaXMgYSBob3N0IGluc3RhbmNlLCBvdGhlcndpc2VcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHRyYXZlcnNlIHVwIHRocm91Z2ggdGhlIERPTSB0aWxsIHdlIGZpbmQgdGhlIGNvcnJlY3RcbiAgICAgICAgICAvLyBub2RlIHRoYXQgaXMgZnJvbSB0aGUgb3RoZXIgdHJlZS5cblxuXG4gICAgICAgICAgd2hpbGUgKGNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnROb2RlLnRhZztcblxuICAgICAgICAgICAgaWYgKHBhcmVudFRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBwYXJlbnRUYWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBhbmNlc3Rvckluc3QgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIGFuY2VzdG9ySW5zdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICB9O1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnRUeXBlLCBpbkNhcHR1cmVQaGFzZSwgYWNjdW11bGF0ZVRhcmdldE9ubHksIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIG9uQmVmb3JlQmx1ciBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIHRha2VcblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciB3YXJuZWRVbmtub3duVGFncztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcjtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO1xudmFyIG5vcm1hbGl6ZUhUTUw7XG5cbntcbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlLFxuICAgIC8vIEVsZWN0cm9uIHNoaXBzIGEgY3VzdG9tIDx3ZWJ2aWV3PiB0YWcgdG8gZGlzcGxheSBleHRlcm5hbCB3ZWIgY29udGVudCBpblxuICAgIC8vIGFuIGlzb2xhdGVkIGZyYW1lIGFuZCBwcm9jZXNzLlxuICAgIC8vIFRoaXMgdGFnIGlzIG5vdCBwcmVzZW50IGluIG5vbiBFbGVjdHJvbiBlbnZpcm9ubWVudHMgc3VjaCBhcyBKU0RvbSB3aGljaFxuICAgIC8vIGlzIG9mdGVuIHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgLy8gQHNlZSBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvYXBpL3dlYnZpZXctdGFnXG4gICAgd2VidmlldzogdHJ1ZVxuICB9O1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywge1xuICAgICAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNcbiAgICB9KTtcbiAgfTsgLy8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbiAgLy8gYnJvd3NlcnMuIEl0IGFkZHMgc3BhY2VzIGFuZCBzb3J0cyB0aGUgcHJvcGVydGllcyBpbiBzb21lXG4gIC8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbiAgLy8gYGV4cGVjdGVkU3R5bGVgIHRvIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIHJlYWQgaXRzIGBzdHlsZWAgYXR0cmlidXRlXG4gIC8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3NcbiAgLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE4MDdcblxuXG4gIGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmcgPSBjYW5Vc2VET00gJiYgIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcblxuICB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgZXJyb3IoJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgfVxuICB9OyAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cblxuXG4gIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59IC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbi8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuXG52YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbnZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShtYXJrdXApIHtcbiAge1xuICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKG1hcmt1cCk7XG4gIH1cblxuICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0LCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KSB7XG4gIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2hvdWxkV2FybkRldikge1xuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc0NvbmN1cnJlbnRNb2RlICYmIGVuYWJsZUNsaWVudFJlbmRlckZhbGxiYWNrT25UZXh0TWlzbWF0Y2gpIHtcbiAgICAvLyBJbiBjb25jdXJyZW50IHJvb3RzLCB3ZSB0aHJvdyB3aGVuIHRoZXJlJ3MgYSB0ZXh0IG1pc21hdGNoIGFuZCByZXZlcnQgdG9cbiAgICAvLyBjbGllbnQgcmVuZGVyaW5nLCB1cCB0byB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBzZXJ2ZXItcmVuZGVyZWQgSFRNTC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpOyAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG5cbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgdHlwZSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7XG4gICAgICAgIGlzOiBwcm9wcy5pc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbiAgICAgIC8vIFRoaXMgcHJldmVudHM6XG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgIG5vZGUubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnNpemUpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGEgc2l6ZSBncmVhdGVyIHRoYW4gMSBjYXVzZXMgYSBzZWxlY3QgdG8gYmVoYXZlIGxpa2UgYG11bHRpcGxlPXRydWVgLCB3aGVyZVxuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB3aGVuIGEgc2VsZWN0IGluIFwic2luZ2xlIHNlbGVjdGlvbiBtb2RlXCIuXG4gICAgICAgICAgbm9kZS5zaXplID0gcHJvcHMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgfSAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuXG5cbiAgdmFyIHByb3BzO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgbG9hZCBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG5cbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMpO1xuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG5cbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB2YXIgbGFzdFN0eWxlID0gbGFzdFByb3BzW3Byb3BLZXldO1xuXG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIDsgZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIGZpYmVyIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2VcbiAgICAgIC8vIHRoZSBhbGxvd2VkIHByb3BlcnR5IGxpc3QgaW4gdGhlIGNvbW1pdCBwaGFzZSBpbnN0ZWFkLlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuXG5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZC5wdXNoKHByb3BLZXksIHN0eWxlVXBkYXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dEh0bWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAge1xuICAgICAgdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFByb3BzW1NUWUxFXSk7XG4gICAgfVxuXG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYuXG5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQsIGlzQ29uY3VycmVudE1vZGUsIHNob3VsZFdhcm5EZXYpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcztcblxuICB7XG4gICAgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgbG9hZCBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBlcnJvciBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcyk7XG5cbiAge1xuICAgIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXR0cmlidXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tfaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wLCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChyYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCwgaXNDb25jdXJyZW50TW9kZSwgc2hvdWxkV2FybkRldik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFdhcm5EZXYgJiYgdHJ1ZSAmJiAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIGVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQgPyBudWxsIDogZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddID09PSB0cnVlKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuXG4gICAgICAgICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBudWxsICYmIHN0YW5kYXJkTmFtZSAhPT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAvLyBJZiBhbiBTVkcgcHJvcCBpcyBzdXBwbGllZCB3aXRoIGJhZCBjYXNpbmcsIGl0IHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBmcm9tIEhUTUwsIGJ1dCB3aWxsIHByb2R1Y2UgYSBtaXNtYXRjaFxuICAgICAgICAgICAgICAvLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBhbHJlYWR5IHdhcm4gYWJvdXQgYmFkIGNhc2luZyBlbHNld2hlcmUuXG4gICAgICAgICAgICAgIC8vIFNvIHdlJ2xsIHNraXAgdGhlIG1pc2xlYWRpbmcgZXh0cmEgbWlzbWF0Y2ggd2FybmluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IHRydWU7IC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cblxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9udFdhcm5DdXN0b21FbGVtZW50ID0gZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCAgO1xuXG4gICAgICAgIGlmICghZG9udFdhcm5DdXN0b21FbGVtZW50ICYmIG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKHNob3VsZFdhcm5EZXYpIHtcbiAgICAgIGlmICggLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcywgdHJ1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCwgaXNDb25jdXJyZW50TW9kZSkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKCkge307XG5cbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG5cbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJywgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcblxuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcblxuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFnOiB0YWdcbiAgICB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9IC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuXG5cbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG5cblxuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuXG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuXG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcblxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuXG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcblxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG5cbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keScgfHwgdGFnID09PSAnZnJhbWVzZXQnO1xuXG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdmcmFtZSc7XG5cbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9IC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuXG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWVzZXQnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuJDEgPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZFRhZyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWc7XG5cbiAgICBpZiAoZGlkV2FybiQxW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybiQxW3dhcm5LZXldID0gdHJ1ZTtcbiAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcblxuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4sIDx0aGVhZD4gb3IgPHRmb290PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcblxuICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGUgPT09ICdub3NjcmlwdCcgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sICE9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gIH1cblxuICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgY3VycmVudEV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gIGlmIChjdXJyZW50RXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBnZXRFdmVudFByaW9yaXR5KGN1cnJlbnRFdmVudC50eXBlKTtcbn1cbi8vIGlmIGEgY29tcG9uZW50IGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLlxuLy8gU29tZSBlbnZpcm9ubWVudHMgbWlnaHQgbm90IGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuXG5cbnZhciBzY2hlZHVsZVRpbWVvdXQgPSB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQ7XG52YXIgY2FuY2VsVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQ7XG52YXIgbm9UaW1lb3V0ID0gLTE7XG52YXIgbG9jYWxQcm9taXNlID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlIDogdW5kZWZpbmVkOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IHR5cGVvZiBsb2NhbFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiBsb2NhbFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGNhbGxiYWNrKS5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xufSA6IHNjaGVkdWxlVGltZW91dDsgLy8gVE9ETzogRGV0ZXJtaW5lIHRoZSBiZXN0IGZhbGxiYWNrIGhlcmUuXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIERlc3BpdGUgdGhlIG5hbWluZyB0aGF0IG1pZ2h0IGltcGx5IG90aGVyd2lzZSwgdGhpcyBtZXRob2Qgb25seVxuICAvLyBmaXJlcyBpZiB0aGVyZSBpcyBhbiBgVXBkYXRlYCBlZmZlY3Qgc2NoZWR1bGVkIGR1cmluZyBtb3VudGluZy5cbiAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gIC8vIGRvZXMgdG8gaW1wbGVtZW50IHRoZSBgYXV0b0ZvY3VzYCBhdHRyaWJ1dGUgb24gdGhlIGNsaWVudCkuIEJ1dFxuICAvLyB0aGVyZSBhcmUgYWxzbyBvdGhlciBjYXNlcyB3aGVuIHRoaXMgbWlnaHQgaGFwcGVuIChzdWNoIGFzIHBhdGNoaW5nXG4gIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpZiAobmV3UHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKG5ld1Byb3BzLnNyYykge1xuICAgICAgICAgIGRvbUVsZW1lbnQuc3JjID0gbmV3UHJvcHMuc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGUoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpOyAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gcmVzZXRUZXh0Q29udGVudChkb21FbGVtZW50KSB7XG4gIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkVG9Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICB2YXIgcGFyZW50Tm9kZTtcblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lcjtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSAvLyBUaGlzIGNvbnRhaW5lciBtaWdodCBiZSB1c2VkIGZvciBhIHBvcnRhbC5cbiAgLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbiAgLy8gdGhyb3VnaCB0aGUgUmVhY3QgdHJlZS4gSG93ZXZlciwgb24gTW9iaWxlIFNhZmFyaSB0aGUgY2xpY2sgd291bGRcbiAgLy8gbmV2ZXIgYnViYmxlIHRocm91Z2ggdGhlICpET00qIHRyZWUgdW5sZXNzIGFuIGFuY2VzdG9yIHdpdGggb25jbGlja1xuICAvLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4gIC8vIFRoaXMgaXMgd2h5IHdlIGVuc3VyZSB0aGF0IG5vbiBSZWFjdCByb290IGNvbnRhaW5lcnMgaGF2ZSBpbmxpbmUgb25jbGlja1xuICAvLyBkZWZpbmVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG5cblxuICB2YXIgcmVhY3RSb290Q29udGFpbmVyID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgaWYgKChyZWFjdFJvb3RDb250YWluZXIgPT09IG51bGwgfHwgcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQpICYmIHBhcmVudE5vZGUub25jbGljayA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW5Db250YWluZXJCZWZvcmUoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KHBhcmVudEluc3RhbmNlLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZTsgLy8gRGVsZXRlIGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG5cbiAgdmFyIGRlcHRoID0gMDtcblxuICBkbyB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgIGlmIChuZXh0Tm9kZSAmJiBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5leHROb2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7IC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cblxuICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7IC8vIFRPRE86IFdhcm4sIHdlIGRpZG4ndCBmaW5kIHRoZSBlbmQgY29tbWVudCBib3VuZGFyeS5cbiAgLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxuXG5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIucGFyZW50Tm9kZSwgc3VzcGVuc2VJbnN0YW5jZSk7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKTtcbiAgfSAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5cblxuICByZXRyeUlmQmxvY2tlZE9uKGNvbnRhaW5lcik7XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgaWYgKGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMoaW5zdGFuY2UpIHtcbiAgdmFyIGRhdGFzZXQgPSBpbnN0YW5jZS5uZXh0U2libGluZyAmJiBpbnN0YW5jZS5uZXh0U2libGluZy5kYXRhc2V0O1xuICB2YXIgZGlnZXN0LCBtZXNzYWdlLCBzdGFjaztcblxuICBpZiAoZGF0YXNldCkge1xuICAgIGRpZ2VzdCA9IGRhdGFzZXQuZGdzdDtcblxuICAgIHtcbiAgICAgIG1lc3NhZ2UgPSBkYXRhc2V0Lm1zZztcbiAgICAgIHN0YWNrID0gZGF0YXNldC5zdGNrO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGRpZ2VzdDogZGlnZXN0LFxuICAgICAgc3RhY2s6IHN0YWNrXG4gICAgfTtcbiAgfSAvLyBsZXQgdmFsdWUgPSB7bWVzc2FnZTogdW5kZWZpbmVkLCBoYXNoOiB1bmRlZmluZWR9O1xuICAvLyBjb25zdCBuZXh0U2libGluZyA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAvLyBpZiAobmV4dFNpYmxpbmcpIHtcbiAgLy8gICBjb25zdCBkYXRhc2V0ID0gKChuZXh0U2libGluZzogYW55KTogSFRNTFRlbXBsYXRlRWxlbWVudCkuZGF0YXNldDtcbiAgLy8gICB2YWx1ZS5tZXNzYWdlID0gZGF0YXNldC5tc2c7XG4gIC8vICAgdmFsdWUuaGFzaCA9IGRhdGFzZXQuaGFzaDtcbiAgLy8gICBpZiAodHJ1ZSkge1xuICAvLyAgICAgdmFsdWUuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAvLyAgIH1cbiAgLy8gfVxuICAvLyByZXR1cm4gdmFsdWU7XG5cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KGluc3RhbmNlLCBjYWxsYmFjaykge1xuICBpbnN0YW5jZS5fcmVhY3RSZXRyeSA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIGZvciAoOyBub2RlICE9IG51bGw7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgbm9kZURhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChub2RlRGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fCBub2RlRGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSB8fCBub2RlRGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZURhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcikge1xuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUocGFyZW50Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5uZXh0U2libGluZyk7XG59XG5mdW5jdGlvbiBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBzaG91bGRXYXJuRGV2KSB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTsgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gIC8vIGdldCBhdHRhY2hlZC5cblxuICB1cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfSAvLyBUT0RPOiBUZW1wb3JhcnkgaGFjayB0byBjaGVjayBpZiB3ZSdyZSBpbiBhIGNvbmN1cnJlbnQgcm9vdC4gV2UgY2FuIGRlbGV0ZVxuICAvLyB3aGVuIHRoZSBsZWdhY3kgcm9vdCBBUEkgaXMgcmVtb3ZlZC5cblxuXG4gIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBzaG91bGRXYXJuRGV2KSB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7IC8vIFRPRE86IFRlbXBvcmFyeSBoYWNrIHRvIGNoZWNrIGlmIHdlJ3JlIGluIGEgY29uY3VycmVudCByb290LiBXZSBjYW4gZGVsZXRlXG4gIC8vIHdoZW4gdGhlIGxlZ2FjeSByb290IEFQSSBpcyByZW1vdmVkLlxuXG4gIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH0gLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuXG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKHBhcmVudFR5cGUpIHtcbiAgcmV0dXJuIHBhcmVudFR5cGUgIT09ICdoZWFkJyAmJiBwYXJlbnRUeXBlICE9PSAnYm9keSc7XG59XG5mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0LCBpc0NvbmN1cnJlbnRNb2RlKSB7XG4gIHZhciBzaG91bGRXYXJuRGV2ID0gdHJ1ZTtcbiAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZS5ub2RlVmFsdWUsIHRleHQsIGlzQ29uY3VycmVudE1vZGUsIHNob3VsZFdhcm5EZXYpO1xufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCwgaXNDb25jdXJyZW50TW9kZSkge1xuICBpZiAocGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICB2YXIgc2hvdWxkV2FybkRldiA9IHRydWU7XG4gICAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZS5ub2RlVmFsdWUsIHRleHQsIGlzQ29uY3VycmVudE1vZGUsIHNob3VsZFdhcm5EZXYpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBPbmx5IEVsZW1lbnQgb3IgRG9jdW1lbnQgY2FuIGJlIHBhcmVudCBub2Rlcy5cbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudEluc3RhbmNlLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnROb2RlLCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UsIGlzQ29uY3VycmVudE1vZGUpIHtcbiAge1xuICAgIGlmIChpc0NvbmN1cnJlbnRNb2RlIHx8IHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lciwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZTogT25seSBFbGVtZW50IG9yIERvY3VtZW50IGNhbiBiZSBwYXJlbnQgbm9kZXMuXG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnRJbnN0YW5jZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlICE9PSBudWxsKSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZTogT25seSBFbGVtZW50IG9yIERvY3VtZW50IGNhbiBiZSBwYXJlbnQgbm9kZXMuXG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnRJbnN0YW5jZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlICE9PSBudWxsKSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcywgaXNDb25jdXJyZW50TW9kZSkge1xuICB7XG4gICAgaWYgKGlzQ29uY3VycmVudE1vZGUgfHwgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQsIGlzQ29uY3VycmVudE1vZGUpIHtcbiAge1xuICAgIGlmIChpc0NvbmN1cnJlbnRNb2RlIHx8IHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50SW5zdGFuY2UsIHRleHQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JIeWRyYXRpbmdDb250YWluZXIocGFyZW50Q29udGFpbmVyKSB7XG4gIHtcbiAgICAvLyBUT0RPOiBUaGlzIGdldHMgbG9nZ2VkIGJ5IG9uUmVjb3ZlcmFibGVFcnJvciwgdG9vLCBzbyB3ZSBzaG91bGQgYmVcbiAgICAvLyBhYmxlIHRvIHJlbW92ZSBpdC5cbiAgICBlcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVGhlIHNlcnZlciBIVE1MIHdhcyByZXBsYWNlZCB3aXRoIGNsaWVudCBjb250ZW50IGluIDwlcz4uJywgcGFyZW50Q29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlUG9ydGFsTW91bnQocG9ydGFsSW5zdGFuY2UpIHtcbiAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocG9ydGFsSW5zdGFuY2UpO1xufVxuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0RmliZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbFByb3BzS2V5ID0gJ19fcmVhY3RQcm9wcyQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkgPSAnX19yZWFjdENvbnRhaW5lciQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRzJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXkgPSAnX19yZWFjdExpc3RlbmVycyQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5ID0gJ19fcmVhY3RIYW5kbGVzJCcgKyByYW5kb21LZXk7XG5mdW5jdGlvbiBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uIGhvc3QgY29tcG9uZW50cy4gSSBkb24ndCB0aGluayBhbGwgb2ZcbiAgLy8gdGhlc2UgZmllbGRzIGFyZSByZWxldmFudC5cbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsUHJvcHNLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleV07XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5XTtcbn1cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cbmZ1bmN0aW9uIG1hcmtDb250YWluZXJBc1Jvb3QoaG9zdFJvb3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IGhvc3RSb290O1xufVxuZnVuY3Rpb24gdW5tYXJrQ29udGFpbmVyQXNSb290KG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG51bGw7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChub2RlKSB7XG4gIHJldHVybiAhIW5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV07XG59IC8vIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBIb3N0Q29tcG9uZW50IG9yIEhvc3RUZXh0IGZpYmVyIGFuY2VzdG9yLlxuLy8gSWYgdGhlIHRhcmdldCBub2RlIGlzIHBhcnQgb2YgYSBoeWRyYXRlZCBvciBub3QgeWV0IHJlbmRlcmVkIHN1YnRyZWUsIHRoZW5cbi8vIHRoaXMgbWF5IGFsc28gcmV0dXJuIGEgU3VzcGVuc2VDb21wb25lbnQgb3IgSG9zdFJvb3QgdG8gaW5kaWNhdGUgdGhhdC5cbi8vIENvbmNlcHR1YWxseSB0aGUgSG9zdFJvb3QgZmliZXIgaXMgYSBjaGlsZCBvZiB0aGUgQ29udGFpbmVyIG5vZGUuIFNvIGlmIHlvdVxuLy8gcGFzcyB0aGUgQ29udGFpbmVyIG5vZGUgYXMgdGhlIHRhcmdldE5vZGUsIHlvdSB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdGhlXG4vLyBIb3N0Um9vdCBiYWNrLiBUbyBnZXQgdG8gdGhlIEhvc3RSb290LCB5b3UgbmVlZCB0byBwYXNzIGEgY2hpbGQgb2YgaXQuXG4vLyBUaGUgc2FtZSB0aGluZyBhcHBsaWVzIHRvIFN1c3BlbnNlIGJvdW5kYXJpZXMuXG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHRhcmdldE5vZGUpIHtcbiAgdmFyIHRhcmdldEluc3QgPSB0YXJnZXROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gIGlmICh0YXJnZXRJbnN0KSB7XG4gICAgLy8gRG9uJ3QgcmV0dXJuIEhvc3RSb290IG9yIFN1c3BlbnNlQ29tcG9uZW50IGhlcmUuXG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH0gLy8gSWYgdGhlIGRpcmVjdCBldmVudCB0YXJnZXQgaXNuJ3QgYSBSZWFjdCBvd25lZCBET00gbm9kZSwgd2UgbmVlZCB0byBsb29rXG4gIC8vIHRvIHNlZSBpZiBvbmUgb2YgaXRzIHBhcmVudHMgaXMgYSBSZWFjdCBvd25lZCBET00gbm9kZS5cblxuXG4gIHZhciBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgLy8gV2UnbGwgY2hlY2sgaWYgdGhpcyBpcyBhIGNvbnRhaW5lciByb290IHRoYXQgY291bGQgaW5jbHVkZVxuICAgIC8vIFJlYWN0IG5vZGVzIGluIHRoZSBmdXR1cmUuIFdlIG5lZWQgdG8gY2hlY2sgdGhpcyBmaXJzdCBiZWNhdXNlXG4gICAgLy8gaWYgd2UncmUgYSBjaGlsZCBvZiBhIGRlaHlkcmF0ZWQgY29udGFpbmVyLCB3ZSBuZWVkIHRvIGZpcnN0XG4gICAgLy8gZmluZCB0aGF0IGlubmVyIGNvbnRhaW5lciBiZWZvcmUgbW92aW5nIG9uIHRvIGZpbmRpbmcgdGhlIHBhcmVudFxuICAgIC8vIGluc3RhbmNlLiBOb3RlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhpcyBmaWVsZCBvbiAgdGhlIHRhcmdldE5vZGVcbiAgICAvLyBpdHNlbGYgYmVjYXVzZSB0aGUgZmliZXJzIGFyZSBjb25jZXB0dWFsbHkgYmV0d2VlbiB0aGUgY29udGFpbmVyXG4gICAgLy8gbm9kZSBhbmQgdGhlIGZpcnN0IGNoaWxkLiBJdCBpc24ndCBzdXJyb3VuZGluZyB0aGUgY29udGFpbmVyIG5vZGUuXG4gICAgLy8gSWYgaXQncyBub3QgYSBjb250YWluZXIsIHdlIGNoZWNrIGlmIGl0J3MgYW4gaW5zdGFuY2UuXG4gICAgdGFyZ2V0SW5zdCA9IHBhcmVudE5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gfHwgcGFyZW50Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcblxuICAgIGlmICh0YXJnZXRJbnN0KSB7XG4gICAgICAvLyBTaW5jZSB0aGlzIHdhc24ndCB0aGUgZGlyZWN0IHRhcmdldCBvZiB0aGUgZXZlbnQsIHdlIG1pZ2h0IGhhdmVcbiAgICAgIC8vIHN0ZXBwZWQgcGFzdCBkZWh5ZHJhdGVkIERPTSBub2RlcyB0byBnZXQgaGVyZS4gSG93ZXZlciB0aGV5IGNvdWxkXG4gICAgICAvLyBhbHNvIGhhdmUgYmVlbiBub24tUmVhY3Qgbm9kZXMuIFdlIG5lZWQgdG8gYW5zd2VyIHdoaWNoIG9uZS5cbiAgICAgIC8vIElmIHdlIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHRoZXJlIGNhbid0IGJlXG4gICAgICAvLyBhIG5lc3RlZCBzdXNwZW5zZSBib3VuZGFyeSB3aXRoaW4gaXQuIFNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGZhc3RcbiAgICAgIC8vIGJhaWxvdXQuIE1vc3Qgb2YgdGhlIHRpbWUsIHdoZW4gcGVvcGxlIGFkZCBub24tUmVhY3QgY2hpbGRyZW4gdG9cbiAgICAgIC8vIHRoZSB0cmVlLCBpdCBpcyB1c2luZyBhIHJlZiB0byBhIGNoaWxkLWxlc3MgRE9NIG5vZGUuXG4gICAgICAvLyBOb3JtYWxseSB3ZSdkIG9ubHkgbmVlZCB0byBjaGVjayBvbmUgb2YgdGhlIGZpYmVycyBiZWNhdXNlIGlmIGl0XG4gICAgICAvLyBoYXMgZXZlciBnb25lIGZyb20gaGF2aW5nIGNoaWxkcmVuIHRvIGRlbGV0aW5nIHRoZW0gb3IgdmljZSB2ZXJzYVxuICAgICAgLy8gaXQgd291bGQgaGF2ZSBkZWxldGVkIHRoZSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IG5lc3RlZCBpbnNpZGUgYWxyZWFkeS5cbiAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoZSBIb3N0Um9vdCBzdGFydHMgb3V0IHdpdGggYW4gYWx0ZXJuYXRlIGl0IG1pZ2h0XG4gICAgICAvLyBoYXZlIG9uZSBvbiB0aGUgYWx0ZXJuYXRlIHNvIHdlIG5lZWQgdG8gY2hlY2sgaW4gY2FzZSB0aGlzIHdhcyBhXG4gICAgICAvLyByb290LlxuICAgICAgdmFyIGFsdGVybmF0ZSA9IHRhcmdldEluc3QuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAodGFyZ2V0SW5zdC5jaGlsZCAhPT0gbnVsbCB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE5leHQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZSBub2RlIHRoYXQgc2tpcHBlZCBwYXN0IGlzXG4gICAgICAgIC8vIG5lc3RlZCB3aXRoaW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFuZCBpZiBzbywgd2hpY2ggb25lLlxuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UodGFyZ2V0Tm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhIHN1c3BlbnNlIGluc3RhbmNlLiBUaGF0IG1lYW5zIHRoYXQgd2UgaGF2ZW4ndFxuICAgICAgICAgIC8vIGh5ZHJhdGVkIGl0IHlldC4gRXZlbiB0aG91Z2ggd2UgbGVhdmUgdGhlIGNvbW1lbnRzIGluIHRoZVxuICAgICAgICAgIC8vIERPTSBhZnRlciBoeWRyYXRpbmcsIGFuZCB0aGVyZSBhcmUgYm91bmRhcmllcyBpbiB0aGUgRE9NXG4gICAgICAgICAgLy8gdGhhdCBjb3VsZCBhbHJlYWR5IGJlIGh5ZHJhdGVkLCB3ZSB3b3VsZG4ndCBoYXZlIGZvdW5kIHRoZW1cbiAgICAgICAgICAvLyB0aHJvdWdoIHRoaXMgcGFzcyBzaW5jZSBpZiB0aGUgdGFyZ2V0IGlzIGh5ZHJhdGVkIGl0IHdvdWxkXG4gICAgICAgICAgLy8gaGF2ZSBoYWQgYW4gaW50ZXJuYWxJbnN0YW5jZUtleSBvbiBpdC5cbiAgICAgICAgICAvLyBMZXQncyBnZXQgdGhlIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgU3VzcGVuc2VDb21wb25lbnRcbiAgICAgICAgICAvLyBhcyB0aGUgZGVlcGVzdCBpbnN0YW5jZS5cbiAgICAgICAgICB2YXIgdGFyZ2V0U3VzcGVuc2VJbnN0ID0gc3VzcGVuc2VJbnN0YW5jZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcblxuICAgICAgICAgIGlmICh0YXJnZXRTdXNwZW5zZUluc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRTdXNwZW5zZUluc3Q7XG4gICAgICAgICAgfSAvLyBJZiB3ZSBkb24ndCBmaW5kIGEgRmliZXIgb24gdGhlIGNvbW1lbnQsIGl0IG1pZ2h0IGJlIGJlY2F1c2VcbiAgICAgICAgICAvLyB3ZSBoYXZlbid0IGdvdHRlbiB0byBoeWRyYXRlIGl0IHlldC4gVGhlcmUgbWlnaHQgc3RpbGwgYmUgYVxuICAgICAgICAgIC8vIHBhcmVudCBib3VuZGFyeSB0aGF0IGhhc24ndCBhYm92ZSB0aGlzIG9uZSBzbyB3ZSBuZWVkIHRvIGZpbmRcbiAgICAgICAgICAvLyB0aGUgb3V0ZXIgbW9zdCB0aGF0IGlzIGtub3duLlxuXG5cbiAgICAgICAgICBzdXNwZW5zZUluc3RhbmNlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTsgLy8gSWYgd2UgZG9uJ3QgZmluZCBvbmUsIHRoZW4gdGhhdCBzaG91bGQgbWVhbiB0aGF0IHRoZSBwYXJlbnRcbiAgICAgICAgICAvLyBob3N0IGNvbXBvbmVudCBhbHNvIGhhc24ndCBoeWRyYXRlZCB5ZXQuIFdlIGNhbiByZXR1cm4gaXRcbiAgICAgICAgICAvLyBiZWxvdyBzaW5jZSBpdCB3aWxsIGJhaWwgb3V0IG9uIHRoZSBpc01vdW50ZWQgY2hlY2sgbGF0ZXIuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgdGFyZ2V0Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHwgbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtcblxuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQgfHwgaW5zdC50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfSAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclNldChub2RlKSB7XG4gIHZhciBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG5cbiAgaWYgKGVsZW1lbnRMaXN0ZW5lclNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gICAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlDb250ZXh0T2JqZWN0OyAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHR5cGUsIGRpZENoYW5nZSkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7IC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuXG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgICBpZiAoIWlzRmliZXJNb3VudGVkKGZpYmVyKSB8fCBmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbnZhciBzeW5jUXVldWUgPSBudWxsO1xudmFyIGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcyA9IGZhbHNlO1xudmFyIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIC8vIFB1c2ggdGhpcyBjYWxsYmFjayBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiBXZSdsbCBmbHVzaCB0aGVzZSBlaXRoZXIgaW5cbiAgLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG4gICAgc3luY1F1ZXVlID0gW2NhbGxiYWNrXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG4gICAgLy8gd2UgYWxyZWFkeSBzY2hlZHVsZWQgb25lIHdoZW4gd2UgY3JlYXRlZCB0aGUgcXVldWUuXG4gICAgc3luY1F1ZXVlLnB1c2goY2FsbGJhY2spO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZUxlZ2FjeVN5bmNDYWxsYmFjayhjYWxsYmFjaykge1xuICBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSB0cnVlO1xuICBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCkge1xuICAvLyBPbmx5IGZsdXNoZXMgdGhlIHF1ZXVlIGlmIHRoZXJlJ3MgYSBsZWdhY3kgc3luYyBjYWxsYmFjayBzY2hlZHVsZWQuXG4gIC8vIFRPRE86IFRoZXJlJ3Mgb25seSBhIHNpbmdsZSB0eXBlIG9mIGNhbGxiYWNrOiBwZXJmb3JtU3luY09uV29ya09uUm9vdC4gU29cbiAgLy8gaXQgbWlnaHQgbWFrZSBtb3JlIHNlbnNlIGZvciB0aGUgcXVldWUgdG8gYmUgYSBsaXN0IG9mIHJvb3RzIGluc3RlYWQgb2YgYVxuICAvLyBsaXN0IG9mIGdlbmVyaWMgY2FsbGJhY2tzLiBUaGVuIHdlIGNhbiBoYXZlIHR3bzogb25lIGZvciBsZWdhY3kgcm9vdHMsIG9uZVxuICAvLyBmb3IgY29uY3VycmVudCByb290cy4gQW5kIHRoaXMgbWV0aG9kIHdvdWxkIG9ubHkgZmx1c2ggdGhlIGxlZ2FjeSBvbmVzLlxuICBpZiAoaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzKSB7XG4gICAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luY0NhbGxiYWNrcygpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nU3luY1F1ZXVlICYmIHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IHRydWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGlzU3luYyA9IHRydWU7XG4gICAgICB2YXIgcXVldWUgPSBzeW5jUXVldWU7IC8vIFRPRE86IElzIHRoaXMgbmVjZXNzYXJ5IGFueW1vcmU/IFRoZSBvbmx5IHVzZXIgY29kZSB0aGF0IHJ1bnMgaW4gdGhpc1xuICAgICAgLy8gcXVldWUgaXMgaW4gdGhlIHJlbmRlciBvciBjb21taXQgcGhhc2VzLlxuXG4gICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcblxuICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhpc1N5bmMpO1xuICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG4gICAgICBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgaWYgKHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBzeW5jUXVldWUgPSBzeW5jUXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgfSAvLyBSZXN1bWUgZmx1c2hpbmcgaW4gdGhlIG5leHQgdGlja1xuXG5cbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlUHJpb3JpdHkpO1xuICAgICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUT0RPOiBVc2UgdGhlIHVuaWZpZWQgZmliZXIgc3RhY2sgbW9kdWxlIGluc3RlYWQgb2YgdGhpcyBsb2NhbCBvbmU/XG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBpdCB5ZXQgdG8gZGVyaXNrIHRoZSBpbml0aWFsIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlXG4vLyB0aGUgd2F5IHdlIHB1c2gvcG9wIHRoZXNlIHZhbHVlcyBpcyBhIGJpdCB1bnVzdWFsLiBJZiB0aGVyZSdzIGEgbWlzdGFrZSwgSSdkXG4vLyByYXRoZXIgdGhlIGlkcyBiZSB3cm9uZyB0aGFuIGNyYXNoIHRoZSB3aG9sZSByZWNvbmNpbGVyLlxudmFyIGZvcmtTdGFjayA9IFtdO1xudmFyIGZvcmtTdGFja0luZGV4ID0gMDtcbnZhciB0cmVlRm9ya1Byb3ZpZGVyID0gbnVsbDtcbnZhciB0cmVlRm9ya0NvdW50ID0gMDtcbnZhciBpZFN0YWNrID0gW107XG52YXIgaWRTdGFja0luZGV4ID0gMDtcbnZhciB0cmVlQ29udGV4dFByb3ZpZGVyID0gbnVsbDtcbnZhciB0cmVlQ29udGV4dElkID0gMTtcbnZhciB0cmVlQ29udGV4dE92ZXJmbG93ID0gJyc7XG5mdW5jdGlvbiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9ya2VkKSAhPT0gTm9GbGFncztcbn1cbmZ1bmN0aW9uIGdldEZvcmtzQXRMZXZlbCh3b3JrSW5Qcm9ncmVzcykge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgcmV0dXJuIHRyZWVGb3JrQ291bnQ7XG59XG5mdW5jdGlvbiBnZXRUcmVlSWQoKSB7XG4gIHZhciBvdmVyZmxvdyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgdmFyIGlkID0gaWRXaXRoTGVhZGluZ0JpdCAmIH5nZXRMZWFkaW5nQml0KGlkV2l0aExlYWRpbmdCaXQpO1xuICByZXR1cm4gaWQudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG59XG5mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgcmVjb25jaWxlIGFuIGFycmF5IChvciBpdGVyYXRvcikgb2YgY2hpbGRcbiAgLy8gZmliZXJzLCBiZWNhdXNlIHRoYXQncyB0aGUgb25seSBwbGFjZSB3aGVyZSB3ZSBrbm93IGhvdyBtYW55IGNoaWxkcmVuIGluXG4gIC8vIHRoZSB3aG9sZSBzZXQgd2l0aG91dCBkb2luZyBleHRyYSB3b3JrIGxhdGVyLCBvciBzdG9yaW5nIGFkZHRpb25hbFxuICAvLyBpbmZvcm1hdGlvbiBvbiB0aGUgZmliZXIuXG4gIC8vXG4gIC8vIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBpcyBzZXBhcmF0ZSBmcm9tIHB1c2hUcmVlSWQg4oCUIGl0J3MgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGUgcmVuZGVyIHBoYXNlIG9mIHRoZSBmb3JrIHBhcmVudCwgbm90IHRoZSBjaGlsZCwgd2hpY2ggaXMgd2hlcmUgd2UgcHVzaFxuICAvLyB0aGUgb3RoZXIgY29udGV4dCB2YWx1ZXMuXG4gIC8vXG4gIC8vIEluIHRoZSBGaXp6IGltcGxlbWVudGF0aW9uIHRoaXMgaXMgbXVjaCBzaW1wbGVyIGJlY2F1c2UgdGhlIGNoaWxkIGlzXG4gIC8vIHJlbmRlcmVkIGluIHRoZSBzYW1lIGNhbGxzdGFjayBhcyB0aGUgcGFyZW50LlxuICAvL1xuICAvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCBhZGQgYSBgZm9ya3NgIGZpZWxkIHRvIHRoZSBGaWJlciB0eXBlLiBJdCB3b3VsZFxuICAvLyBtYWtlIHRoaXMgbW9kdWxlIHNpbXBsZXIuXG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya1Byb3ZpZGVyO1xuICB0cmVlRm9ya1Byb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgdmFyIGJhc2VPdmVyZmxvdyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7IC8vIFRoZSBsZWZ0bW9zdCAxIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBub24taW5jbHVzaXZlLiBJdCdzIG5vdCBwYXJ0XG4gIC8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG5cbiAgdmFyIGJhc2VMZW5ndGggPSBnZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgdmFyIGJhc2VJZCA9IGJhc2VJZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8IGJhc2VMZW5ndGgpO1xuICB2YXIgc2xvdCA9IGluZGV4ICsgMTtcbiAgdmFyIGxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7IC8vIDMwIGlzIHRoZSBtYXggbGVuZ3RoIHdlIGNhbiBzdG9yZSB3aXRob3V0IG92ZXJmbG93aW5nLCB0YWtpbmcgaW50b1xuICAvLyBjb25zaWRlcmF0aW9uIHRoZSBsZWFkaW5nIDEgd2UgdXNlIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG5cbiAgaWYgKGxlbmd0aCA+IDMwKSB7XG4gICAgLy8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbiAgICAvLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoZSBsZW5ndGggb2YgdGhlIGJhc2UgaWQgaXMgZ3JlYXRlciB0aGFuIDU7IGl0IHdvbid0XG4gICAgLy8gd29yayBmb3Igc21hbGxlciBpZHMsIGJlY2F1c2UgeW91IG5lZWQgNSBiaXRzIHBlciBjaGFyYWN0ZXIuXG4gICAgLy9cbiAgICAvLyBXZSBlbmNvZGUgdGhlIGlkIGluIG11bHRpcGxlIHN0ZXBzOiBmaXJzdCB0aGUgYmFzZSBpZCwgdGhlbiB0aGVcbiAgICAvLyByZW1haW5pbmcgZGlnaXRzLlxuICAgIC8vXG4gICAgLy8gRWFjaCA1IGJpdCBzZXF1ZW5jZSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBiYXNlIDMyIGNoYXJhY3Rlci4gU28gZm9yXG4gICAgLy8gZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgaWQgaXMgMjMgYml0cyBsb25nLCB3ZSBjYW4gY29udmVydCAyMCBvZiB0aG9zZVxuICAgIC8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbiAgICAvL1xuICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBob3cgbWFueSBiaXRzIGluIHRoZSBiYXNlIGlkIHJlcHJlc2VudCBhIGNvbXBsZXRlXG4gICAgLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbiAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gYmFzZUxlbmd0aCAlIDU7IC8vIFRoZW4gY3JlYXRlIGEgYml0bWFzayB0aGF0IHNlbGVjdHMgb25seSB0aG9zZSBiaXRzLlxuXG4gICAgdmFyIG5ld092ZXJmbG93Qml0cyA9ICgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDE7IC8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxuXG4gICAgdmFyIG5ld092ZXJmbG93ID0gKGJhc2VJZCAmIG5ld092ZXJmbG93Qml0cykudG9TdHJpbmcoMzIpOyAvLyBOb3cgd2UgY2FuIHJlbW92ZSB0aG9zZSBiaXRzIGZyb20gdGhlIGJhc2UgaWQuXG5cbiAgICB2YXIgcmVzdE9mQmFzZUlkID0gYmFzZUlkID4+IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHZhciByZXN0T2ZCYXNlTGVuZ3RoID0gYmFzZUxlbmd0aCAtIG51bWJlck9mT3ZlcmZsb3dCaXRzOyAvLyBGaW5hbGx5LCBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMgdXNpbmcgdGhlIG5vcm1hbCBhbGdvcml0aG0uIEJlY2F1c2VcbiAgICAvLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxuXG4gICAgdmFyIHJlc3RPZkxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIHJlc3RPZk5ld0JpdHMgPSBzbG90IDw8IHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIGlkID0gcmVzdE9mTmV3Qml0cyB8IHJlc3RPZkJhc2VJZDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBuZXdPdmVyZmxvdyArIGJhc2VPdmVyZmxvdztcbiAgICB0cmVlQ29udGV4dElkID0gMSA8PCByZXN0T2ZMZW5ndGggfCBpZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICB0cmVlQ29udGV4dElkID0gMSA8PCBsZW5ndGggfCBfaWQ7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IF9vdmVyZmxvdztcbiAgfVxufVxuZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTsgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBUaGlzIHdpbGwgYWZmZWN0IGFueSBpZHMgdGhhdCBhcHBlYXJcbiAgLy8gaW4gaXRzIGNoaWxkcmVuLlxuXG4gIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IDE7XG4gICAgdmFyIHNsb3RJbmRleCA9IDA7XG4gICAgcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzKTtcbiAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpIHtcbiAgcmV0dXJuIDMyIC0gY2x6MzIobnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZGluZ0JpdChpZCkge1xuICByZXR1cm4gMSA8PCBnZXRCaXRMZW5ndGgoaWQpIC0gMTtcbn1cblxuZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWVzLlxuICAvLyBUaGlzIGlzIGEgYml0IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBvdGhlciBjb250ZXh0LWxpa2UgbW9kdWxlcyBpbiBGaWJlclxuICAvLyBiZWNhdXNlIHRoZSBzYW1lIEZpYmVyIG1heSBhcHBlYXIgb24gdGhlIHN0YWNrIG11bHRpcGxlIHRpbWVzIGFuZCBmb3JcbiAgLy8gZGlmZmVyZW50IHJlYXNvbnMuIFdlIGhhdmUgdG8ga2VlcCBwb3BwaW5nIHVudGlsIHRoZSB3b3JrLWluLXByb2dyZXNzIGlzXG4gIC8vIG5vIGxvbmdlciBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyKSB7XG4gICAgdHJlZUZvcmtQcm92aWRlciA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtcbiAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICB9XG5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgdHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcblxuICBpZiAodHJlZUNvbnRleHRQcm92aWRlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdHJlZUNvbnRleHRJZCxcbiAgICAgIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5kZWRDb250ZXh0KSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICB0cmVlQ29udGV4dElkID0gc3VzcGVuZGVkQ29udGV4dC5pZDtcbiAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IHN1c3BlbmRlZENvbnRleHQub3ZlcmZsb3c7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKCFnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7IC8vIFRoaXMgZmxhZyBhbGxvd3MgZm9yIHdhcm5pbmcgc3VwcmVzc2lvbiB3aGVuIHdlIGV4cGVjdCB0aGVyZSB0byBiZSBtaXNtYXRjaGVzXG4vLyBkdWUgdG8gZWFybGllciBtaXNtYXRjaGVzIG9yIGEgc3VzcGVuZGVkIGZpYmVyLlxuXG52YXIgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTsgLy8gSHlkcmF0aW9uIGVycm9ycyB0aGF0IHdlcmUgdGhyb3duIGluc2lkZSB0aGlzIGJvdW5kYXJ5XG5cbnZhciBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuSWZIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgIGVycm9yKCdXZSBzaG91bGQgbm90IGJlIGh5ZHJhdGluZyBoZXJlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhIGJ1Zy4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZFN1c3BlbmRPckVycm9yV2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICByZXR1cm4gZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG5cbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xuXG4gIGlmICh0cmVlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dChmaWJlciwgdHJlZUNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcbiAgICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSByZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkLCBpbnN0YW5jZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSk7XG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZGlkU3VzcGVuZE9yRXJyb3JERVYpIHtcbiAgICAgIC8vIEluc2lkZSBhIGJvdW5kYXJ5IHRoYXQgYWxyZWFkeSBzdXNwZW5kZWQuIFdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgdGhlXG4gICAgICAvLyBzaWJsaW5ncyBvZiBhIHN1c3BlbmRlZCBub2RlLiBUaGUgbWlzbWF0Y2ggbWF5IGJlIGR1ZSB0byB0aGUgbWlzc2luZ1xuICAgICAgLy8gZGF0YSwgc28gaXQncyBwcm9iYWJseSBhIGZhbHNlIHBvc2l0aXZlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUsIF9wcm9wcywgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9pc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcblxuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3RleHQsIC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG4gICAgICAgICAgICAgICAgX2lzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gcmV0dXJuRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgX3BhcmVudEluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuICAgICAgICAgIGlmIChfcGFyZW50SW5zdGFuY2UgIT09IG51bGwpIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciBfdHlwZTIgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzMiA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdHlwZTIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0MiA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKF9wYXJlbnRJbnN0YW5jZSwgX3RleHQyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG4gIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cblxuICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShuZXh0SW5zdGFuY2UpO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB7XG4gICAgICAgICAgICBkZWh5ZHJhdGVkOiBzdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICAgICAgICByZXRyeUxhbmU6IE9mZnNjcmVlbkxhbmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdXNwZW5zZVN0YXRlOyAvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuICAgICAgICAgIC8vIFRoaXMgc2ltcGxpZmllcyB0aGUgY29kZSBmb3IgZ2V0SG9zdFNpYmxpbmcgYW5kIGRlbGV0aW5nIG5vZGVzLFxuICAgICAgICAgIC8vIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBjb25zaWRlciBhbGwgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG5cbiAgICAgICAgICB2YXIgZGVoeWRyYXRlZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICAgIGRlaHlkcmF0ZWRGcmFnbWVudC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgICAgICBmaWJlci5jaGlsZCA9IGRlaHlkcmF0ZWRGcmFnbWVudDtcbiAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyOyAvLyBXaGlsZSBhIFN1c3BlbnNlIEluc3RhbmNlIGRvZXMgaGF2ZSBjaGlsZHJlbiwgd2Ugd29uJ3Qgc3RlcCBpbnRvXG4gICAgICAgICAgLy8gaXQgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJbnN0ZWFkLCB3ZSdsbCByZWVudGVyIGl0IGxhdGVyLlxuXG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpIHtcbiAgcmV0dXJuIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3M7XG59XG5cbmZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyAnICsgJ3JlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIGlmIChzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSkge1xuICAgICAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgIH0gLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cblxuXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcblxuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcbiAgICB9IC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG5cblxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgICB2YXIgcHJldkh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuXG4gICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHByZXZIeWRyYXRpb25QYXJlbnRGaWJlciwgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2ID0gIWRpZFN1c3BlbmRPckVycm9yREVWO1xuICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkOyAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkVXBkYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlcik7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG4gICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcbiAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuICAgICAgICAgICAgaXNDb25jdXJyZW50TW9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIHZhciBfaXNDb25jdXJyZW50TW9kZTIgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgIF9pc0NvbmN1cnJlbnRNb2RlMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gIC8vIHNpZGUgb2YgdGhlbS4gV2UgYWxzbyBkb24ndCBkZWxldGUgYW55dGhpbmcgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lci5cblxuXG4gIGlmIChmaWJlci50YWcgIT09IEhvc3RSb290ICYmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiYgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgaWYgKG5leHRJbnN0YW5jZSkge1xuICAgICAgaWYgKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKSB7XG4gICAgICAgIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpO1xuICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzVW5oeWRyYXRlZFRhaWxOb2RlcygpIHtcbiAgcmV0dXJuIGlzSHlkcmF0aW5nICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpIHtcbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4gICAgLy8gZHVyaW5nIHRoZSBoeWRyYXRpb24gYXR0ZW1wdCBhcmUgbm93IHJlY292ZXJlZC4gV2Ugd2lsbCBsb2cgdGhlbSBpblxuICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmc7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgTm9UcmFuc2l0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpIHtcbiAgcmV0dXJuIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIFwiICsgJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM0KTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNSA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG5cbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnM7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xuXG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7fTtcblxue1xuICBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDbGFzcyh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG5cbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgLy8gVE9ETzogQ2xlYW4gdGhpcyB1cCBvbmNlIHdlIHR1cm4gb24gdGhlIHN0cmluZyByZWYgd2FybmluZyBmb3JcbiAgICAgIC8vIGV2ZXJ5b25lLCBiZWNhdXNlIHRoZSBzdHJpY3QgbW9kZSBjYXNlIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG4gICAgICBpZiAoKHJldHVybkZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlIHx8IHdhcm5BYm91dFN0cmluZ1JlZnMpICYmIC8vIFdlIHdhcm4gaW4gUmVhY3RFbGVtZW50LmpzIGlmIG93bmVyIGFuZCBzZWxmIGFyZSBlcXVhbCBmb3Igc3RyaW5nIHJlZnNcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAvLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuICAgICAgIShlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9zZWxmICYmIGVsZW1lbnQuX293bmVyLnN0YXRlTm9kZSAhPT0gZWxlbWVudC5fc2VsZikgJiYgLy8gV2lsbCBhbHJlYWR5IHRocm93IHdpdGggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzXCJcbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkgJiYgLy8gV2lsbCBhbHJlYWR5IHdhcm4gd2l0aCBcIkZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnNcIlxuICAgICAgISh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nICYmICFpc1JlYWN0Q2xhc3MoZWxlbWVudC50eXBlKSkgJiYgLy8gV2lsbCBhbHJlYWR5IHRocm93IHdpdGggXCJFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChzb21lU3RyaW5nUmVmKSBidXQgbm8gb3duZXIgd2FzIHNldFwiXG4gICAgICBlbGVtZW50Ll9vd25lcikge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgJyArICd3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gV2UgcmVjb21tZW5kIHVzaW5nICcgKyAndXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBtaXhlZFJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3Q7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG4gICAgICAgIGlmIChvd25lckZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgc3RyaW5nIHJlZnMuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5zdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmIFwiICsgbWl4ZWRSZWYgKyBcIi4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgXCIgKyAnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0gLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdCBzbyBGbG93IGtub3dzIGl0IHdvbid0IGNoYW5nZSBpbiB0aGUgY2xvc3VyZVxuXG5cbiAgICAgIHZhciByZXNvbHZlZEluc3QgPSBpbnN0O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKG1peGVkUmVmLCAncmVmJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmOyAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgdHlwZW9mIGN1cnJlbnQucmVmID09PSAnZnVuY3Rpb24nICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSByZXNvbHZlZEluc3QucmVmcztcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgbWl4ZWRSZWYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGEgc3RyaW5nLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIG51bGwuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIgKyBtaXhlZFJlZiArIFwiKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZlwiICsgJyB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGZ1bmN0aW9uIGNvbXBvbmVudFxcbicgKyBcIjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudCdzIHJlbmRlciBtZXRob2RcXG5cIiArICczLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuICB2YXIgcGF5bG9hZCA9IGxhenlUeXBlLl9wYXlsb2FkO1xuICB2YXIgaW5pdCA9IGxhenlUeXBlLl9pbml0O1xuICByZXR1cm4gaW5pdChwYXlsb2FkKTtcbn0gLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cblxuXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIHVzZUlkIGFsZ29yaXRobSBuZWVkcyB0byBrbm93IHdoaWNoIGZpYmVycyBhcmVcbiAgICAgIC8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBGb3JrZWQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkge1xuICAgICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpO1xuICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgfSAvLyBJbnNlcnRcblxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywga2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIGluaXQocGF5bG9hZCksIGxhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gY2hpbGQuX2luaXQ7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZEtleShpbml0KHBheWxvYWQpLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcykge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGggZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICB2YXIgX251bWJlck9mRm9ya3MyID0gbmV3SWR4O1xuICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJyArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgICBuZXdDaGlsZHJlbkl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBHZW5lcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuICcgKyAnWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlICcgKyAnYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBLZWVwIGluIG1pbmQgJyArICd5b3UgbWlnaHQgbmVlZCB0byBwb2x5ZmlsbCB0aGVzZSBmZWF0dXJlcyBmb3Igb2xkZXIgYnJvd3NlcnMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgIH0gLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG5cblxuICAgICAgaWYgKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgIH0gLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG5cblxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuXG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAobmV3Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczMgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzNCA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3M0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cblxuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgICAgIC8vIGJlY2F1c2UgaG90IHJlbG9hZGluZyBoYXMgZGlmZmVyZW50IHNlbWFudGljcyB0aGFuIHByb2QgYmVjYXVzZVxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgICAgICB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiYgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cbiAgICAgICAgICAgIHZhciBfZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgIF9leGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICAgIF9leGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9leGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9IC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDsgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBub24tcmVjdXJzaXZlLlxuXG4gICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICB7XG4gICAge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBpcyBpbiB0aGlzIHN1YnRyZWUsIHdlIGRvbid0IGtub3dcbiAgICAgIC8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuICAgICAgLy8gbWFyayBpdCBhcyBoYXZpbmcgdXBkYXRlcy5cbiAgICAgIHZhciBwYXJlbnRTdXNwZW5zZSA9IGZpYmVyLnJldHVybjtcblxuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50U3VzcGVuc2UubGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudFN1c3BlbnNlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX2FsdGVybmF0ZSA9IHBhcmVudFN1c3BlbnNlLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgX2FsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoX2FsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgcGFzc2luZyB0aGlzIGZpYmVyIGFzIHRoZSBwYXJlbnRcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBzY2hlZHVsZSB0aGlzIGZpYmVyIGFzIGhhdmluZyB3b3JrXG4gICAgICAvLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuICAgICAgLy8gdGhpcyBmaWJlciB0byBpbmRpY2F0ZSB0aGF0IGEgY29udGV4dCBoYXMgY2hhbmdlZC5cblxuXG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudFN1c3BlbnNlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuc2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cblxuICAgIGlmIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG5cbiAgICAgIHdoaWxlIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcblxuICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gTm8gbW9yZSBzaWJsaW5ncy4gVHJhdmVyc2UgdXAuXG5cblxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcblxuICBpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgdmFyIGZpcnN0Q29udGV4dCA9IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG5cbiAgICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgICAvLyBDb250ZXh0IGxpc3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuIE1hcmsgdGhhdCB0aGlzIGZpYmVyIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgaWYgKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsdWUgPSAgY29udGV4dC5fY3VycmVudFZhbHVlIDtcblxuICBpZiAobGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID09PSBjb250ZXh0KSA7IGVsc2Uge1xuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBtZW1vaXplZFZhbHVlOiB2YWx1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRlcGVuZGVuY3kgZm9yIHRoaXMgY29tcG9uZW50LiBDcmVhdGUgYSBuZXcgbGlzdC5cblxuXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGZpcnN0Q29udGV4dDogY29udGV4dEl0ZW1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dCA9IGNvbnRleHRJdGVtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmVuZGVyLiBXaGVuIHRoaXMgcmVuZGVyIGV4aXRzLCBlaXRoZXIgYmVjYXVzZSBpdCBmaW5pc2hlcyBvciBiZWNhdXNlIGl0IGlzXG4vLyBpbnRlcnJ1cHRlZCwgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZCBvbnRvIHRoZSBtYWluIHBhcnRcbi8vIG9mIHRoZSBxdWV1ZS5cblxudmFyIGNvbmN1cnJlbnRRdWV1ZXMgPSBudWxsO1xuZnVuY3Rpb24gcHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSkge1xuICBpZiAoY29uY3VycmVudFF1ZXVlcyA9PT0gbnVsbCkge1xuICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBbcXVldWVdO1xuICB9IGVsc2Uge1xuICAgIGNvbmN1cnJlbnRRdWV1ZXMucHVzaChxdWV1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gIC8vIFRyYW5zZmVyIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIG9udG8gdGhlIG1haW4gcXVldWUuIEVhY2ggcXVldWUgaGFzIGFcbiAgLy8gYHBlbmRpbmdgIGZpZWxkIGFuZCBhbiBgaW50ZXJsZWF2ZWRgIGZpZWxkLiBXaGVuIHRoZXkgYXJlIG5vdCBudWxsLCB0aGV5XG4gIC8vIHBvaW50IHRvIHRoZSBsYXN0IG5vZGUgaW4gYSBjaXJjdWxhciBsaW5rZWQgbGlzdC4gV2UgbmVlZCB0byBhcHBlbmQgdGhlXG4gIC8vIGludGVybGVhdmVkIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgcGVuZGluZyBsaXN0IGJ5IGpvaW5pbmcgdGhlbSBpbnRvIGFcbiAgLy8gc2luZ2xlLCBjaXJjdWxhciBsaXN0LlxuICBpZiAoY29uY3VycmVudFF1ZXVlcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uY3VycmVudFF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgIHZhciBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuICAgICAgaWYgKGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5pbnRlcmxlYXZlZCA9IG51bGw7XG4gICAgICAgIHZhciBmaXJzdEludGVybGVhdmVkVXBkYXRlID0gbGFzdEludGVybGVhdmVkVXBkYXRlLm5leHQ7XG4gICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKGxhc3RQZW5kaW5nVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGU7XG4gICAgICAgICAgbGFzdEludGVybGVhdmVkVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbGFzdEludGVybGVhdmVkVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIGludGVybGVhdmVkID0gcXVldWUuaW50ZXJsZWF2ZWQ7XG5cbiAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlOyAvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgcHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5pbnRlcmxlYXZlZCA9IHVwZGF0ZTtcbiAgcmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gIGlmIChpbnRlcmxlYXZlZCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGVuZGluZyBxdWV1ZS5cblxuICAgIHB1c2hDb25jdXJyZW50VXBkYXRlUXVldWUocXVldWUpO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICBpbnRlcmxlYXZlZC5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gIGlmIChpbnRlcmxlYXZlZCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGVuZGluZyBxdWV1ZS5cblxuICAgIHB1c2hDb25jdXJyZW50VXBkYXRlUXVldWUocXVldWUpO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICBpbnRlcmxlYXZlZC5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIHJldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpIHtcbiAgcmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcbn0gLy8gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgYmUgZG9uZSBmb3IgYmFja3dhcmRzXG4vLyBjb21wYXRpYmlsaXR5IGFuZCBzaG91bGQgYWx3YXlzIGJlIGFjY29tcGFuaWVkIGJ5IGEgd2FybmluZy5cblxudmFyIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290O1xuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGxhbmVzLlxuXG5cbiAgdmFyIG5vZGUgPSBzb3VyY2VGaWJlcjtcbiAgdmFyIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50LmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudC5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoKHBhcmVudC5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIFVwZGF0ZVN0YXRlID0gMDtcbnZhciBSZXBsYWNlU3RhdGUgPSAxO1xudmFyIEZvcmNlVXBkYXRlID0gMjtcbnZhciBDYXB0dXJlVXBkYXRlID0gMzsgLy8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cblxudmFyIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZTtcbnZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU7XG5cbntcbiAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xuICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICBmaXJzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgc2hhcmVkOiB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG4gICAgICBsYW5lczogTm9MYW5lc1xuICAgIH0sXG4gICAgZWZmZWN0czogbnVsbFxuICB9O1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xufVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBDbG9uZSB0aGUgdXBkYXRlIHF1ZXVlIGZyb20gY3VycmVudC4gVW5sZXNzIGl0J3MgYWxyZWFkeSBhIGNsb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBldmVudFRpbWU6IGV2ZW50VGltZSxcbiAgICBsYW5lOiBsYW5lLFxuICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgcGF5bG9hZDogbnVsbCxcbiAgICBjYWxsYmFjazogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoKSkge1xuICAgIC8vIFRoaXMgaXMgYW4gdW5zYWZlIHJlbmRlciBwaGFzZSB1cGRhdGUuIEFkZCBkaXJlY3RseSB0byB0aGUgdXBkYXRlXG4gICAgLy8gcXVldWUgc28gd2UgY2FuIHByb2Nlc3MgaXQgaW1tZWRpYXRlbHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgIH1cblxuICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7IC8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuICAgIC8vIHRoaXMgZmliZXIuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIHRoZSBjYXNlIHdoZXJlIHlvdVxuICAgIC8vIHVwZGF0ZSBhIGRpZmZlcmVudCBjb21wb25lbnQgZHVyaW5nIHJlbmRlciBwaGFzZSB0aGFuIHRoZSBvbmUgdGhhdCBpc1xuICAgIC8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxuXG4gICAgcmV0dXJuIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsIHNoYXJlZFF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc1RyYW5zaXRpb25MYW5lKGxhbmUpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBzaGFyZWRRdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleSBtdXN0XG4gICAgLy8gaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuICAgIC8vIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2UgbWF5IGVudGFuZ2xlXG4gICAgLy8gbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZiB3ZSAqZG9uJ3QqXG4gICAgLy8gZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cbiAgICBxdWV1ZUxhbmVzID0gaW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcywgcm9vdC5wZW5kaW5nTGFuZXMpOyAvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxuXG4gICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuICAgIHNoYXJlZFF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuICAgIC8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4gICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCBhcmUgdGhyb3duIGJ5IGEgY2hpbGQgZHVyaW5nIHRoZSByZW5kZXJcbiAgLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbiAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBDaGVjayBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIGNsb25lLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbiAgICAgIC8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuICAgICAgLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4gICAgICAvLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG4gICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuICAgICAgdmFyIG5ld0xhc3QgPSBudWxsO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHVwZGF0ZXMgYW5kIGNsb25lIHRoZW0uXG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlLmV2ZW50VGltZSxcbiAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICAgICAgbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyBBcHBlbmQgdGhlIGNhcHR1cmVkIHVwZGF0ZSB0aGUgZW5kIG9mIHRoZSBjbG9uZWQgbGlzdC5cblxuXG4gICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgICAgbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gYmFzZSB1cGRhdGVzLlxuICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG5cbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICB9XG5cbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBwcmV2U3RhdGUsIG5leHRQcm9wcywgaW5zdGFuY2UpIHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICAgIH0gLy8gU3RhdGUgb2JqZWN0XG5cblxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgIH1cbiAgICAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAge1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXRlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICB9XG5cbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIElmIHNvLCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsOyAvLyBUaGUgcGVuZGluZyBxdWV1ZSBpcyBjaXJjdWxhci4gRGlzY29ubmVjdCB0aGUgcG9pbnRlciBiZXR3ZWVuIGZpcnN0XG4gICAgLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cblxuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDsgLy8gQXBwZW5kIHBlbmRpbmcgdXBkYXRlcyB0byBiYXNlIHF1ZXVlXG5cbiAgICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9XG5cbiAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlOyAvLyBJZiB0aGVyZSdzIGEgY3VycmVudCBxdWV1ZSwgYW5kIGl0J3MgZGlmZmVyZW50IGZyb20gdGhlIGJhc2UgcXVldWUsIHRoZW5cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuICAgIC8vIHF1ZXVlIGlzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IHdpdGggbm8gY3ljbGVzLCB3ZSBjYW4gYXBwZW5kIHRvIGJvdGhcbiAgICAvLyBsaXN0cyBhbmQgdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLlxuICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gICAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHZhciBjdXJyZW50TGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgIT09IGxhc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuXG5cbiAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVzIHRvIGNvbXB1dGUgdGhlIHJlc3VsdC5cbiAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4gICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cbiAgICB2YXIgbmV3TGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdGaXJzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciBuZXdMYXN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG4gICAgICB2YXIgdXBkYXRlRXZlbnRUaW1lID0gdXBkYXRlLmV2ZW50VGltZTtcblxuICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuXG5cbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgbmV3U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgLy8gSWYgdGhlIHVwZGF0ZSB3YXMgYWxyZWFkeSBjb21taXR0ZWQsIHdlIHNob3VsZCBub3QgcXVldWUgaXRzXG4gICAgICAgIC8vIGNhbGxiYWNrIGFnYWluLlxuICAgICAgICB1cGRhdGUubGFuZSAhPT0gTm9MYW5lKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG4gICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVmZmVjdHMgPSBbdXBkYXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7IC8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbiAgICAvLyBwcm9jZXNzIHRoZW0gZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgd2UgZG8gbmVlZCB0byB0cmFjayB3aGljaCBsYW5lc1xuICAgIC8vIGFyZSByZW1haW5pbmcuXG5cbiAgICB2YXIgbGFzdEludGVybGVhdmVkID0gcXVldWUuc2hhcmVkLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGxhc3RJbnRlcmxlYXZlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgaW50ZXJsZWF2ZWQubGFuZSk7XG4gICAgICAgIGludGVybGVhdmVkID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIH0gd2hpbGUgKGludGVybGVhdmVkICE9PSBsYXN0SW50ZXJsZWF2ZWQpO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuICAgICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgIHF1ZXVlLnNoYXJlZC5sYW5lcyA9IE5vTGFuZXM7XG4gICAgfSAvLyBTZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgd2hhdGV2ZXIgaXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZS5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBmaW5lIGJlY2F1c2UgdGhlIG9ubHkgdHdvIG90aGVyIHRoaW5ncyB0aGF0IGNvbnRyaWJ1dGUgdG9cbiAgICAvLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4gICAgLy8gYmVnaW4gcGhhc2UgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUsIHNvIHdlJ3ZlIGFscmVhZHlcbiAgICAvLyBkZWFsdCB3aXRoIHRoZSBwcm9wcy4gQ29udGV4dCBpbiBjb21wb25lbnRzIHRoYXQgc3BlY2lmeVxuICAgIC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4gICAgLy8gdGhhdCByZWdhcmRsZXNzLlxuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnICsgKFwicmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2spKTtcbiAgfVxuXG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuZnVuY3Rpb24gY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFF1ZXVlLCBpbnN0YW5jZSkge1xuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgdmFyIGVmZmVjdHMgPSBmaW5pc2hlZFF1ZXVlLmVmZmVjdHM7XG4gIGZpbmlzaGVkUXVldWUuZWZmZWN0cyA9IG51bGw7XG5cbiAgaWYgKGVmZmVjdHMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZWZmZWN0LmNhbGxiYWNrO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIGlmIChjID09PSBOT19DT05URVhUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTsgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTsgLy8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAvLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4gIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBOT19DT05URVhULCBmaWJlcik7XG4gIHZhciBuZXh0Um9vdENvbnRleHQgPSBnZXRSb290SG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSk7IC8vIE5vdyB0aGF0IHdlIGtub3cgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LCByZXBsYWNlIGl0LlxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSk7IC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuXG4gIGlmIChjb250ZXh0ID09PSBuZXh0Q29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwOyAvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcbi8vIGluaGVyaXRlZCBkZWVwbHkgZG93biB0aGUgc3VidHJlZS4gVGhlIHVwcGVyIGJpdHMgb25seSBhZmZlY3Rcbi8vIHRoaXMgaW1tZWRpYXRlIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBnZXRzIHJlc2V0IGVhY2ggbmV3XG4vLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxuXG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxOyAvLyBTdWJ0cmVlIEZsYWdzOlxuLy8gSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IGluZGljYXRlcyB0aGF0IG9uZSBvZiBvdXIgcGFyZW50IFN1c3BlbnNlXG4vLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cbi8vIEVpdGhlciBiZWNhdXNlIGl0IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIG9yIGlzIG5vdCBtb3VudGVkIGF0IGFsbC5cbi8vIFdlIGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBhdFxuLy8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG4vLyBhbmQvb3Igc3VzcGVuZCB0aGUgY29tbWl0IHRvIGF2b2lkIGhpZGluZyB0aGUgcGFyZW50IGNvbnRlbnQuXG5cbnZhciBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgPSAxOyAvLyBTaGFsbG93IEZsYWdzOlxuLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMjtcbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuZnVuY3Rpb24gaGFzU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIGZsYWcpIHtcbiAgcmV0dXJuIChwYXJlbnRDb250ZXh0ICYgZmxhZykgIT09IDA7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHNoYWxsb3dDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgfCBzaGFsbG93Q29udGV4dDtcbn1cbmZ1bmN0aW9uIGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc3VidHJlZUNvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgfCBzdWJ0cmVlQ29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hTdXNwZW5zZUNvbnRleHQoZmliZXIsIG5ld0NvbnRleHQpIHtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdDb250ZXh0LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUNvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgLy8gSWYgaXQgd2FzIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHRoYXQganVzdCBzdXNwZW5kZWQsIGNhcHR1cmUgYW5kIHJlbmRlciB0aGVcbiAgLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGRlaHlkcmF0ZWQgYm91bmRhcnkgYWx3YXlzIGNhcHR1cmVzLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsgLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG4gIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgICovXG4wOyAvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxuXG52YXIgSGFzRWZmZWN0ID1cbi8qICovXG4xOyAvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cblxudmFyIEluc2VydGlvbiA9XG4vKiAgKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG44O1xuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aCA9IDA7XG59XG4vLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdmVyc2lvbiB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG1hdGNoZXMgdGhlIG9uZVxuLy8gdGhhdCBpcyBldmVudHVhbGx5IHJlYWQgZHVyaW5nIGh5ZHJhdGlvbi5cbi8vIElmIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlcmUncyBhIHBvdGVudGlhbCB0ZWFyIGFuZCBhIGZ1bGwgZGVvcHQgcmVuZGVyIGlzIHJlcXVpcmVkLlxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCwgbXV0YWJsZVNvdXJjZSkge1xuICB2YXIgZ2V0VmVyc2lvbiA9IG11dGFibGVTb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihtdXRhYmxlU291cmNlLl9zb3VyY2UpOyAvLyBUT0RPIENsZWFyIHRoaXMgZGF0YSBvbmNlIGFsbCBwZW5kaW5nIGh5ZHJhdGlvbiB3b3JrIGlzIGZpbmlzaGVkLlxuICAvLyBSZXRhaW5pbmcgaXQgZm9yZXZlciBtYXkgaW50ZXJmZXJlIHdpdGggR0MuXG5cbiAgaWYgKHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9PSBudWxsKSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gW211dGFibGVTb3VyY2UsIHZlcnNpb25dO1xuICB9IGVsc2Uge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5wdXNoKG11dGFibGVTb3VyY2UsIHZlcnNpb24pO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q7XG5cbntcbiAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xufVxuXG4vLyBUaGVzZSBhcmUgc2V0IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb21wb25lbnQuXG52YXIgcmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gSSd2ZSBuYW1lZCBpdCBkaWZmZXJlbnRseSB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7IC8vIEhvb2tzIGFyZSBzdG9yZWQgYXMgYSBsaW5rZWQgbGlzdCBvbiB0aGUgZmliZXIncyBtZW1vaXplZFN0YXRlIGZpZWxkLiBUaGVcbi8vIGN1cnJlbnQgaG9vayBsaXN0IGlzIHRoZSBsaXN0IHRoYXQgYmVsb25ncyB0byB0aGUgY3VycmVudCBmaWJlci4gVGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGhvb2sgbGlzdCBpcyBhIG5ldyBsaXN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG5cbnZhciBjdXJyZW50SG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBhdCBhbnkgcG9pbnQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXNcbi8vIGRvZXMgbm90IGdldCByZXNldCBpZiB3ZSBkbyBhbm90aGVyIHJlbmRlciBwYXNzOyBvbmx5IHdoZW4gd2UncmUgY29tcGxldGVseVxuLy8gZmluaXNoZWQgZXZhbHVhdGluZyB0aGlzIGNvbXBvbmVudC4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gd2Uga25vd1xuLy8gd2hldGhlciB3ZSBuZWVkIHRvIGNsZWFyIHJlbmRlciBwaGFzZSB1cGRhdGVzIGFmdGVyIGEgdGhyb3cuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFdoZXJlIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9ubHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciBwYXNzLiBUaGlzXG4vLyBnZXRzIHJlc2V0IGFmdGVyIGVhY2ggYXR0ZW1wdC5cbi8vIFRPRE86IE1heWJlIHRoZXJlJ3Mgc29tZSB3YXkgdG8gY29uc29saWRhdGUgdGhpcyB3aXRoXG4vLyBgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZWAuIE9yIHdpdGggYG51bWJlck9mUmVSZW5kZXJzYC5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2VJZCBob29rcyBpbiB0aGlzIGNvbXBvbmVudC5cblxudmFyIGxvY2FsSWRDb3VudGVyID0gMDsgLy8gVXNlZCBmb3IgaWRzIHRoYXQgYXJlIGdlbmVyYXRlZCBjb21wbGV0ZWx5IGNsaWVudC1zaWRlIChpLmUuIG5vdCBkdXJpbmdcbi8vIGh5ZHJhdGlvbikuIFRoaXMgY291bnRlciBpcyBnbG9iYWwsIHNvIGNsaWVudCBpZHMgYXJlIG5vdCBzdGFibGUgYWNyb3NzXG4vLyByZW5kZXIgYXR0ZW1wdHMuXG5cbnZhciBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1OyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDsgLy8gSW4gREVWLCB0aGlzIGxpc3QgZW5zdXJlcyB0aGF0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdGhlIHNhbWUgb3JkZXIgYmV0d2VlbiByZW5kZXJzLlxuLy8gVGhlIGxpc3Qgc3RvcmVzIHRoZSBvcmRlciBvZiBob29rcyB1c2VkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgKG1vdW50KS5cbi8vIFN1YnNlcXVlbnQgcmVuZGVycyAodXBkYXRlcykgcmVmZXJlbmNlIHRoaXMgbGlzdC5cblxudmFyIGhvb2tUeXBlc0RldiA9IG51bGw7XG52YXIgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gSW4gREVWLCB0aGlzIHRyYWNrcyB3aGV0aGVyIGN1cnJlbnRseSByZW5kZXJpbmcgY29tcG9uZW50IG5lZWRzIHRvIGlnbm9yZVxuLy8gdGhlIGRlcGVuZGVuY2llcyBmb3IgSG9va3MgdGhhdCBuZWVkIHRoZW0gKGUuZy4gdXNlRWZmZWN0IG9yIHVzZU1lbW8pLlxuLy8gV2hlbiB0cnVlLCBzdWNoIEhvb2tzIHdpbGwgYWx3YXlzIGJlIFwicmVtb3VudGVkXCIuIE9ubHkgdXNlZCBkdXJpbmcgaG90IHJlbG9hZC5cblxudmFyIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ID09PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNEZXYgPSBbaG9va05hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKztcblxuICAgICAgaWYgKGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKSB7XG4gICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICB7XG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCAmJiBkZXBzICE9PSBudWxsICYmICFpc0FycmF5KGRlcHMpKSB7XG4gICAgICAvLyBWZXJpZnkgZGVwcywgYnV0IG9ubHkgb24gbW91bnQgdG8gYXZvaWQgZXh0cmEgY2hlY2tzLlxuICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGVpciB0eXBlIHdvdWxkIGNoYW5nZSBhcyB1c3VhbGx5IHlvdSBkZWZpbmUgdGhlbSBpbmxpbmUuXG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gJyArICdzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicsIGN1cnJlbnRIb29rTmFtZUluRGV2LCB0eXBlb2YgZGVwcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGN1cnJlbnRIb29rTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YWJsZSA9ICcnO1xuICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldO1xuICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7IC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgICAvLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG5cbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuICAgICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJyArICcgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicgKyAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyArICclcycgKyAnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJywgY29tcG9uZW50TmFtZSwgdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIHtcbiAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHtcbiAgICAgIC8vIE9ubHkgdHJ1ZSB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGJlaW5nIGhvdCByZWxvYWRlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcsIG5leHRSZW5kZXJMYW5lcykge1xuICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5cbiAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAvLyBUT0RPIFdhcm4gaWYgbm8gaG9va3MgYXJlIHVzZWQgYXQgYWxsIGR1cmluZyBtb3VudCwgdGhlbiBzb21lIGFyZSB1c2VkIGR1cmluZyB1cGRhdGUuXG4gIC8vIEN1cnJlbnRseSB3ZSB3aWxsIGlkZW50aWZ5IHRoZSB1cGRhdGUgcmVuZGVyIGFzIGEgbW91bnQgYmVjYXVzZSBtZW1vaXplZFN0YXRlID09PSBudWxsLlxuICAvLyBUaGlzIGlzIHRyaWNreSBiZWNhdXNlIGl0J3MgdmFsaWQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgY29tcG9uZW50cyAoZS5nLiBSZWFjdC5sYXp5KVxuICAvLyBVc2luZyBtZW1vaXplZFN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBtb3VudC91cGRhdGUgb25seSB3b3JrcyBpZiBhdCBsZWFzdCBvbmUgc3RhdGVmdWwgaG9vayBpcyB1c2VkLlxuICAvLyBOb24tc3RhdGVmdWwgaG9va3MgKGUuZy4gY29udGV4dCkgZG9uJ3QgZ2V0IGFkZGVkIHRvIG1lbW9pemVkU3RhdGUsXG4gIC8vIHNvIG1lbW9pemVkU3RhdGUgd291bGQgYmUgbnVsbCBkdXJpbmcgdXBkYXRlcyBhbmQgbW91bnRzLlxuXG4gIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICB9IGVsc2UgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGhhbmRsZXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgY29tcG9uZW50IGlzIHVwZGF0aW5nLFxuICAgICAgLy8gYnV0IG5vIHN0YXRlZnVsIGhvb2tzIGhhdmUgYmVlbiB1c2VkLlxuICAgICAgLy8gV2Ugd2FudCB0byBtYXRjaCB0aGUgcHJvZHVjdGlvbiBjb2RlIGJlaGF2aW9yICh3aGljaCB3aWxsIHVzZSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50KSxcbiAgICAgIC8vIGJ1dCB3aXRoIHRoZSBleHRyYSBERVYgdmFsaWRhdGlvbiB0byBlbnN1cmUgaG9va3Mgb3JkZXJpbmcgaGFzbid0IGNoYW5nZWQuXG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgZG9lcyB0aGF0LlxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7IC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhIHJlbmRlciBwaGFzZSB1cGRhdGVcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKSB7XG4gICAgLy8gS2VlcCByZW5kZXJpbmcgaW4gYSBsb29wIGZvciBhcyBsb25nIGFzIHJlbmRlciBwaGFzZSB1cGRhdGVzIGNvbnRpbnVlIHRvXG4gICAgLy8gYmUgc2NoZWR1bGVkLiBVc2UgYSBjb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG4gICAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcblxuICAgIGRvIHtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgICAgIH1cblxuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcblxuICAgICAge1xuICAgICAgICAvLyBFdmVuIHdoZW4gaG90IHJlbG9hZGluZywgYWxsb3cgZGVwZW5kZW5jaWVzIHRvIHN0YWJpbGl6ZVxuICAgICAgICAvLyBhZnRlciBmaXJzdCByZW5kZXIgdG8gcHJldmVudCBpbmZpbml0ZSByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbiAgICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcbiAgICAgIH0gLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuXG4gICAgICBjdXJyZW50SG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEFsc28gdmFsaWRhdGUgaG9vayBvcmRlciBmb3IgY2FzY2FkaW5nIHVwZGF0ZXMuXG4gICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICB9XG5cbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA7XG4gICAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICB9IC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXG5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGhvb2tUeXBlc0RldjtcbiAgfSAvLyBUaGlzIGNoZWNrIHVzZXMgY3VycmVudEhvb2sgc28gdGhhdCBpdCB3b3JrcyB0aGUgc2FtZSBpbiBERVYgYW5kIHByb2QgYnVuZGxlcy5cbiAgLy8gaG9va1R5cGVzRGV2IGNvdWxkIGNhdGNoIG1vcmUgY2FzZXMgKGUuZy4gY29udGV4dCkgYnV0IG9ubHkgaW4gREVWIGJ1bmRsZXMuXG5cblxuICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPSBjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBjdXJyZW50SG9vay5uZXh0ICE9PSBudWxsO1xuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIENvbmZpcm0gdGhhdCBhIHN0YXRpYyBmbGFnIHdhcyBub3QgYWRkZWQgb3IgcmVtb3ZlZCBzaW5jZSB0aGUgbGFzdFxuICAgIC8vIHJlbmRlci4gSWYgdGhpcyBmaXJlcywgaXQgc3VnZ2VzdHMgdGhhdCB3ZSBpbmNvcnJlY3RseSByZXNldCB0aGUgc3RhdGljXG4gICAgLy8gZmxhZ3MgaW4gc29tZSBvdGhlciBwYXJ0IG9mIHRoZSBjb2RlYmFzZS4gVGhpcyBoYXMgaGFwcGVuZWQgYmVmb3JlLCBmb3JcbiAgICAvLyBleGFtcGxlLCBpbiB0aGUgU3VzcGVuc2VMaXN0IGltcGxlbWVudGF0aW9uLlxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBTdGF0aWNNYXNrKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU3RhdGljTWFzaykgJiYgLy8gRGlzYWJsZSB0aGlzIHdhcm5pbmcgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgbGVnYWN5IFN1c3BlbnNlIGlzIHdlaXJkXG4gICAgLy8gYW5kIGNyZWF0ZXMgZmFsc2UgcG9zaXRpdmVzLiBUbyBtYWtlIHRoaXMgd29yayBpbiBsZWdhY3kgbW9kZSwgd2UnZFxuICAgIC8vIG5lZWQgdG8gbWFyayBmaWJlcnMgdGhhdCBjb21taXQgaW4gYW4gaW5jb21wbGV0ZSBzdGF0ZSwgc29tZWhvdy4gRm9yXG4gICAgLy8gbm93IEknbGwgZGlzYWJsZSB0aGUgd2FybmluZyB0aGF0IG1vc3Qgb2YgdGhlIGJ1Z3MgdGhhdCB3b3VsZCB0cmlnZ2VyXG4gICAgLy8gaXQgYXJlIGVpdGhlciBleGNsdXNpdmUgdG8gY29uY3VycmVudCBtb2RlIG9yIGV4aXN0IGluIGJvdGguXG4gICAgKGN1cnJlbnQubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2UgJyArICdub3RpZnkgdGhlIFJlYWN0IHRlYW0uJyk7XG4gICAgfVxuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGlzIGlzIHJlc2V0IGJ5IGNoZWNrRGlkUmVuZGVySWRIb29rXG4gIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcblxuICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsICcgKyAnZWFybHkgcmV0dXJuIHN0YXRlbWVudC4nKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgcmVuZGVyV2l0aEhvb2tzIGNhbGwuXG4gIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVuZGVyV2l0aEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG4gIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byByZXNldCB0aGUgZmxhZ3MgaGVyZSwgYmVjYXVzZSB0aGV5J3JlIHJlc2V0IGluIHRoZVxuICAvLyBjb21wbGV0ZSBwaGFzZSAoYnViYmxlUHJvcGVydGllcykuXG5cbiAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihNb3VudFBhc3NpdmVEZXYgfCBNb3VudExheW91dERldiB8IFBhc3NpdmUgfCBVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oUGFzc2l2ZSB8IFVwZGF0ZSk7XG4gIH1cblxuICBjdXJyZW50LmxhbmVzID0gcmVtb3ZlTGFuZXMoY3VycmVudC5sYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc0FmdGVyVGhyb3coKSB7XG4gIC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuICAgIC8vIHBoYXNlLCB3aGljaCB3ZSBhcmUgbm93IGFib3J0aW5nLiBSZW1vdmUgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWVzIHNvXG4gICAgLy8gdGhleSBkbyBub3QgcGVyc2lzdCB0byB0aGUgbmV4dCByZW5kZXIuIERvIG5vdCByZW1vdmUgdXBkYXRlcyBmcm9tIGhvb2tzXG4gICAgLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cbiAgICAvL1xuICAgIC8vIE9ubHkgcmVzZXQgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUgaWYgaXQgaGFzIGEgY2xvbmUuIElmIGl0IGRvZXNcbiAgICAvLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG4gICAgLy8gc2NoZWR1bGVkIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgdmFyIGhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBob29rID0gaG9vay5uZXh0O1xuICAgIH1cblxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgdmFyIGhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IGhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2s7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBib3RoIGZvciB1cGRhdGVzIGFuZCBmb3IgcmUtcmVuZGVycyB0cmlnZ2VyZWQgYnkgYVxuICAvLyByZW5kZXIgcGhhc2UgdXBkYXRlLiBJdCBhc3N1bWVzIHRoZXJlIGlzIGVpdGhlciBhIGN1cnJlbnQgaG9vayB3ZSBjYW5cbiAgLy8gY2xvbmUsIG9yIGEgd29yay1pbi1wcm9ncmVzcyBob29rIGZyb20gYSBwcmV2aW91cyByZW5kZXIgcGFzcyB0aGF0IHdlIGNhblxuICAvLyB1c2UgYXMgYSBiYXNlLiBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGJhc2UgbGlzdCwgd2UgbXVzdCBzd2l0Y2ggdG9cbiAgLy8gdGhlIGRpc3BhdGNoZXIgdXNlZCBmb3IgbW91bnRzLlxuICB2YXIgbmV4dEN1cnJlbnRIb29rO1xuXG4gIGlmIChjdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICB9XG5cbiAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICB9XG5cbiAgaWYgKG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9uZSBmcm9tIHRoZSBjdXJyZW50IGhvb2suXG4gICAgaWYgKG5leHRDdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuJyk7XG4gICAgfVxuXG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgdmFyIG5ld0hvb2sgPSB7XG4gICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IG5ld0hvb2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXdIb29rO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEVmZmVjdDogbnVsbCxcbiAgICBzdG9yZXM6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudCA9IGN1cnJlbnRIb29rOyAvLyBUaGUgbGFzdCByZWJhc2UgdXBkYXRlIHRoYXQgaXMgTk9UIHBhcnQgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cbiAgdmFyIGJhc2VRdWV1ZSA9IGN1cnJlbnQuYmFzZVF1ZXVlOyAvLyBUaGUgbGFzdCBwZW5kaW5nIHVwZGF0ZSB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgbmV3IHVwZGF0ZXMgdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAvLyBXZSdsbCBhZGQgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cbiAgICBpZiAoYmFzZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBNZXJnZSB0aGUgcGVuZGluZyBxdWV1ZSBhbmQgdGhlIGJhc2UgcXVldWUuXG4gICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICB2YXIgcGVuZGluZ0ZpcnN0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdGaXJzdDtcbiAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdXJyZW50LmJhc2VRdWV1ZSAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgIC8vIEludGVybmFsIGludmFyaWFudCB0aGF0IHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBmZWFzaWJseSBjb3VsZCBpblxuICAgICAgICAvLyB0aGUgZnV0dXJlIGlmIHdlIGltcGxlbWVudCByZXN1bWluZywgb3Igc29tZSBmb3JtIG9mIHRoYXQuXG4gICAgICAgIGVycm9yKCdJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoYmFzZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHF1ZXVlIHRvIHByb2Nlc3MuXG4gICAgdmFyIGZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgdmFyIG5ld1N0YXRlID0gY3VycmVudC5iYXNlU3RhdGU7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0O1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZTtcblxuICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBpZiAodXBkYXRlLmhhc0VhZ2VyU3RhdGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSBpcyBhIHN0YXRlIHVwZGF0ZSAobm90IGEgcmVkdWNlcikgYW5kIHdhcyBwcm9jZXNzZWQgZWFnZXJseSxcbiAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlXG4gICAgICAgICAgbmV3U3RhdGUgPSB1cGRhdGUuZWFnZXJTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsICYmIHVwZGF0ZSAhPT0gZmlyc3QpO1xuXG4gICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdDtcbiAgICB9IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBob29rLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBJbnRlcmxlYXZlZCB1cGRhdGVzIGFyZSBzdG9yZWQgb24gYSBzZXBhcmF0ZSBxdWV1ZS4gV2UgYXJlbid0IGdvaW5nIHRvXG4gIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4gIC8vIGFyZSByZW1haW5pbmcuXG5cblxuICB2YXIgbGFzdEludGVybGVhdmVkID0gcXVldWUuaW50ZXJsZWF2ZWQ7XG5cbiAgaWYgKGxhc3RJbnRlcmxlYXZlZCAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IGxhc3RJbnRlcmxlYXZlZDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBpbnRlcmxlYXZlZExhbmUgPSBpbnRlcmxlYXZlZC5sYW5lO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgaW50ZXJsZWF2ZWRMYW5lKTtcbiAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMoaW50ZXJsZWF2ZWRMYW5lKTtcbiAgICAgIGludGVybGVhdmVkID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICB9IHdoaWxlIChpbnRlcmxlYXZlZCAhPT0gbGFzdEludGVybGVhdmVkKTtcbiAgfSBlbHNlIGlmIChiYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuICAgIC8vIHplcm8gb25jZSB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgcXVldWUubGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZztcbiAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyByZW5kZXIncy5cbiAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlOyAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAvLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuXG4gICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0U25hcHNob3Q7XG4gIHZhciBpc0h5ZHJhdGluZyA9IGdldElzSHlkcmF0aW5nKCk7XG5cbiAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yICcgKyAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuJyk7XG4gICAgfVxuXG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgaWYgKG5leHRTbmFwc2hvdCAhPT0gZ2V0U2VydmVyU25hcHNob3QoKSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbiAgICAvLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4gICAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cbiAgICAvL1xuICAgIC8vIFdlIHdvbid0IGRvIHRoaXMgaWYgd2UncmUgaHlkcmF0aW5nIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LCBiZWNhdXNlIGlmXG4gICAgLy8gdGhlIGNvbnRlbnQgaXMgc3RhbGUsIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGFueXdheS4gSW5zdGVhZCB3ZSdsbCBwYXRjaFxuICAgIC8vIGl0IHVwIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG5cblxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByZW5kZXJMYW5lcykpIHtcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4gIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gIHZhciBpbnN0ID0ge1xuICAgIHZhbHVlOiBuZXh0U25hcHNob3QsXG4gICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90XG4gIH07XG4gIGhvb2sucXVldWUgPSBpbnN0OyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gc3Vic2NyaWJlIHRvIHRoZSBzdG9yZS5cblxuICBtb3VudEVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHVwZGF0ZSB0aGUgbXV0YWJsZSBpbnN0YW5jZSBmaWVsZHMuIFdlIHdpbGwgdXBkYXRlXG4gIC8vIHRoaXMgd2hlbmV2ZXIgc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgb3IgdmFsdWUgY2hhbmdlcy4gQmVjYXVzZSB0aGVyZSdzIG5vXG4gIC8vIGNsZWFuLXVwIGZ1bmN0aW9uLCBhbmQgd2UgdHJhY2sgdGhlIGRlcHMgY29ycmVjdGx5LCB3ZSBjYW4gY2FsbCBwdXNoRWZmZWN0XG4gIC8vIGRpcmVjdGx5LCB3aXRob3V0IHN0b3JpbmcgYW55IGFkZGl0aW9uYWwgc3RhdGUuIEZvciB0aGUgc2FtZSByZWFzb24sIHdlXG4gIC8vIGRvbid0IG5lZWQgdG8gc2V0IGEgc3RhdGljIGZsYWcsIGVpdGhlci5cbiAgLy8gVE9ETzogV2UgY2FuIG1vdmUgdGhpcyB0byB0aGUgcGFzc2l2ZSBwaGFzZSBvbmNlIHdlIGFkZCBhIHByZS1jb21taXRcbiAgLy8gY29uc2lzdGVuY3kgY2hlY2suIFNlZSB0aGUgbmV4dCBjb21tZW50LlxuXG4gIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmU7XG4gIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpLCB1bmRlZmluZWQsIG51bGwpO1xuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOyAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4gIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cbiAgdmFyIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXMobmV4dFNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2U25hcHNob3QgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzbmFwc2hvdENoYW5nZWQgPSAhb2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuXG4gIGlmIChzbmFwc2hvdENoYW5nZWQpIHtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gaG9vay5xdWV1ZTtcbiAgdXBkYXRlRWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcbiAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG4gIGlmIChpbnN0LmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fCBzbmFwc2hvdENoYW5nZWQgfHwgLy8gQ2hlY2sgaWYgdGhlIHN1c2JjcmliZSBmdW5jdGlvbiBjaGFuZ2VkLiBXZSBjYW4gc2F2ZSBzb21lIG1lbW9yeSBieVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHdlIHNjaGVkdWxlZCBhIHN1YnNjcmlwdGlvbiBlZmZlY3QgYWJvdmUuXG4gIHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiBIYXNFZmZlY3QpIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlO1xuICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpLCB1bmRlZmluZWQsIG51bGwpOyAvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbiAgICAvLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4gICAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cblxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByZW5kZXJMYW5lcykpIHtcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gIGZpYmVyLmZsYWdzIHw9IFN0b3JlQ29uc2lzdGVuY3k7XG4gIHZhciBjaGVjayA9IHtcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsXG4gICAgdmFsdWU6IHJlbmRlcmVkU25hcHNob3RcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RvcmVzID0gY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgaWYgKHN0b3JlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmVzLnB1c2goY2hlY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gIC8vIFRoZXNlIGFyZSB1cGRhdGVkIGluIHRoZSBwYXNzaXZlIHBoYXNlXG4gIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gU29tZXRoaW5nIG1heSBoYXZlIGJlZW4gbXV0YXRlZCBpbiBiZXR3ZWVuIHJlbmRlciBhbmQgY29tbWl0LiBUaGlzIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhbiBldmVudCB0aGF0IGZpcmVkIGJlZm9yZSB0aGUgcGFzc2l2ZSBlZmZlY3RzLCBvciBpdCBjb3VsZFxuICAvLyBoYXZlIGJlZW4gaW4gYSBsYXlvdXQgZWZmZWN0LiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkIGhhdmUgdXNlZCB0aGUgb2xkXG4gIC8vIHNuYXBzaG8gYW5kIGdldFNuYXBzaG90IHZhbHVlcyB0byBiYWlsIG91dC4gV2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSB0aW1lLlxuXG4gIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIHZhciBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBpbnRlcmxlYXZlZDogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgZGVzdHJveSwgZGVwcykge1xuICB2YXIgZWZmZWN0ID0ge1xuICAgIHRhZzogdGFnLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgZGVwczogZGVwcyxcbiAgICAvLyBDaXJjdWxhclxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIGxhc3RFZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICAgIGVmZmVjdC5uZXh0ID0gZmlyc3RFZmZlY3Q7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAge1xuICAgIHZhciBfcmVmMiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gX3JlZjI7XG4gICAgcmV0dXJuIF9yZWYyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgdW5kZWZpbmVkLCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBkZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RWZmZWN0ID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICBkZXN0cm95ID0gcHJldkVmZmVjdC5kZXN0cm95O1xuXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChNb3VudFBhc3NpdmVEZXYgfCBQYXNzaXZlIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtb3VudEVmZmVjdEltcGwoUGFzc2l2ZSB8IFBhc3NpdmVTdGF0aWMsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICB7XG4gICAgZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gIH1cblxuICBpZiAoIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZWZDYWxsYmFjayA9IHJlZjtcblxuICAgIHZhciBfaW5zdCA9IGNyZWF0ZSgpO1xuXG4gICAgcmVmQ2FsbGJhY2soX2luc3QpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZWZPYmplY3QgPSByZWY7XG5cbiAgICB7XG4gICAgICBpZiAoIXJlZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJyArICdyZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCAnYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKHJlZk9iamVjdCkuam9pbignLCAnKSArICd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9pbnN0MiA9IGNyZWF0ZSgpO1xuXG4gICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBfaW5zdDI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZk9iamVjdC5jdXJyZW50ID0gbnVsbDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gIHtcbiAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgfVxuXG4gIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikgey8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxudmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cbmZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZXNvbHZlZEN1cnJlbnRIb29rID0gY3VycmVudEhvb2s7XG4gIHZhciBwcmV2VmFsdWUgPSByZXNvbHZlZEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhIG1vdW50LlxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVyZW5kZXIgZHVyaW5nIGFuIHVwZGF0ZS5cbiAgICB2YXIgcHJldlZhbHVlID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSkge1xuICB2YXIgc2hvdWxkRGVmZXJWYWx1ZSA9ICFpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhyZW5kZXJMYW5lcyk7XG5cbiAgaWYgKHNob3VsZERlZmVyVmFsdWUpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVyZ2VudCB1cGRhdGUuIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwga2VlcCB1c2luZyB0aGVcbiAgICAvLyBwcmV2aW91cyB2YWx1ZSBhbmQgc3Bhd24gYSBkZWZlcnJlZCByZW5kZXIgdG8gdXBkYXRlIGl0IGxhdGVyLlxuICAgIGlmICghb2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyXG4gICAgICB2YXIgZGVmZXJyZWRMYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGRlZmVycmVkTGFuZSk7XG4gICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7IC8vIFNldCB0aGlzIHRvIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVuZGVyZWQgdmFsdWUgaXMgaW5jb25zaXN0ZW50XG4gICAgICAvLyBmcm9tIHRoZSBsYXRlc3QgdmFsdWUuIFRoZSBuYW1lIFwiYmFzZVN0YXRlXCIgZG9lc24ndCByZWFsbHkgbWF0Y2ggaG93IHdlXG4gICAgICAvLyB1c2UgaXQgYmVjYXVzZSB3ZSdyZSByZXVzaW5nIGEgc3RhdGUgaG9vayBmaWVsZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGFcbiAgICAgIC8vIG5ldyBvbmUuXG5cbiAgICAgIGhvb2suYmFzZVN0YXRlID0gdHJ1ZTtcbiAgICB9IC8vIFJldXNlIHRoZSBwcmV2aW91cyB2YWx1ZVxuXG5cbiAgICByZXR1cm4gcHJldlZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIHVyZ2VudCB1cGRhdGUsIHNvIHdlIGNhbiB1c2UgdGhlIGxhdGVzdCB2YWx1ZSByZWdhcmRsZXNzXG4gICAgLy8gb2Ygd2hhdCBpdCBpcy4gTm8gbmVlZCB0byBkZWZlciBpdC5cbiAgICAvLyBIb3dldmVyLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgc3Bhd25lZCByZW5kZXIsIHRoZW4gd2UgbmVlZCB0byBtYXJrXG4gICAgLy8gdGhpcyBhcyBhbiB1cGRhdGUgdG8gcHJldmVudCB0aGUgZmliZXIgZnJvbSBiYWlsaW5nIG91dC5cbiAgICAvL1xuICAgIC8vIGBiYXNlU3RhdGVgIGlzIHRydWUgd2hlbiB0aGUgY3VycmVudCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcmVuZGVyZWRcbiAgICAvLyB2YWx1ZS4gVGhlIG5hbWUgZG9lc24ndCByZWFsbHkgbWF0Y2ggaG93IHdlIHVzZSBpdCBiZWNhdXNlIHdlJ3JlIHJldXNpbmdcbiAgICAvLyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgaWYgKGhvb2suYmFzZVN0YXRlKSB7XG4gICAgICAvLyBGbGlwIHRoaXMgYmFjayB0byBmYWxzZS5cbiAgICAgIGhvb2suYmFzZVN0YXRlID0gZmFsc2U7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2V0UGVuZGluZywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGhpZ2hlckV2ZW50UHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSwgQ29udGludW91c0V2ZW50UHJpb3JpdHkpKTtcbiAgc2V0UGVuZGluZyh0cnVlKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSB7fTtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIF9tb3VudFN0YXRlID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZVswXSxcbiAgICAgIHNldFBlbmRpbmcgPSBfbW91bnRTdGF0ZVsxXTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIG5ldmVyIGNoYW5nZXMuXG5cblxuICB2YXIgc3RhcnQgPSBzdGFydFRyYW5zaXRpb24uYmluZChudWxsLCBzZXRQZW5kaW5nKTtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBzdGFydDtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGVbMF07XG5cbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHN0YXJ0ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIGlzUGVuZGluZyA9IF9yZXJlbmRlclN0YXRlWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxudmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpIHtcbiAge1xuICAgIHJldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsgLy8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4gIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuICAvLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuICAvLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuICAvLyBhIHJlZmVyZW5jZSB0by5cblxuICB2YXIgaWRlbnRpZmllclByZWZpeCA9IHJvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlkO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCgpOyAvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cblxuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAgIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuXG4gICAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgICB9XG5cbiAgICBpZCArPSAnOic7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbiAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAncicgKyBnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikgKyAnOic7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGlkID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdXBkYXRlLmVhZ2VyU3RhdGUgPSBlYWdlclN0YXRlO1xuXG4gICAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aC4gV2UgY2FuIGJhaWwgb3V0IHdpdGhvdXQgc2NoZWR1bGluZyBSZWFjdCB0byByZS1yZW5kZXIuXG4gICAgICAgICAgICAvLyBJdCdzIHN0aWxsIHBvc3NpYmxlIHRoYXQgd2UnbGwgbmVlZCB0byByZWJhc2UgdGhpcyB1cGRhdGUgbGF0ZXIsXG4gICAgICAgICAgICAvLyBpZiB0aGUgY29tcG9uZW50IHJlLXJlbmRlcnMgZm9yIGEgZGlmZmVyZW50IHJlYXNvbiBhbmQgYnkgdGhhdFxuICAgICAgICAgICAgLy8gdGltZSB0aGUgcmVkdWNlciBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IERvIHdlIHN0aWxsIG5lZWQgdG8gZW50YW5nbGUgdHJhbnNpdGlvbnMgaW4gdGhpcyBjYXNlP1xuICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgcmV0dXJuIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG59IC8vIFRPRE86IE1vdmUgdG8gUmVhY3RGaWJlckNvbmN1cnJlbnRVcGRhdGVzP1xuXG5cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbiAgICAvLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4gICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4gICAgLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbiAgICAvLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBxdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSwgYWN0aW9uKSB7XG5cbiAge1xuICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNdXRhYmxlU291cmNlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbnZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovXG5cbnZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbnZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkge1xuICByZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO1xufVxuXG5mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCkge1xuICB7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDEoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMSgpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDEoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG4gICAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuICAgICAgICAgICAgLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKSB7XG5cbiAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93JDEoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuICAvLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbiAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgYmFzZVByb3BzKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjaztcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMSA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5ICcgKyAnbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0ICcgKyAnYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgJyArIFwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzbid0IHN1cHBvcnRlZC4gVHJ5IFwiICsgJ3RvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoICcgKyAndG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBtZW1vaXplZFN0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdG9yLmNoaWxkQ29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDEuaGFzKGN0b3IpICYmIC8vIFN0cmljdCBNb2RlIGhhcyBpdHMgb3duIHdhcm5pbmcgZm9yIGxlZ2FjeSBjb250ZXh0LCBzbyB3ZSBjYW4gc2tpcFxuICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCBpcyBubyBsb25nZXIgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBVc2UgJyArICdSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZFxcblxcbi4nICsgJ0xlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZXMgJiYgIWRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMS5oYXMoY3RvcikgJiYgLy8gU3RyaWN0IE1vZGUgaGFzIGl0cyBvd24gd2FybmluZyBmb3IgbGVnYWN5IGNvbnRleHQsIHNvIHdlIGNhbiBza2lwXG4gICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDEuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBVc2UgJyArICdSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC5cXG5cXG4nICsgJ0xlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0b3IuY29udGV4dFR5cGUgJiYgY3Rvci5jb250ZXh0VHlwZXMgJiYgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5hZGQoY3Rvcik7XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlY2xhcmVzIGJvdGggY29udGV4dFR5cGVzIGFuZCBjb250ZXh0VHlwZSBzdGF0aWMgcHJvcGVydGllcy4gJyArICdUaGUgbGVnYWN5IGNvbnRleHRUeXBlcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuXG4gIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgcHJvcHMpIHtcbiAgdmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIHtcbiAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiBjdG9yKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBjb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IGN0b3IuY29udGV4dFR5cGVzO1xuICAgIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gY29udGV4dFR5cGVzICE9PSBudWxsICYmIGNvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnRleHQgPSBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA/IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gICAgLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuXG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSB7fTtcbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAgICB7XG4gICAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgICB9XG5cbiAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgICAgIH1cblxuICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2ZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAgICAgIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IF9maWJlckZsYWdzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfZmliZXJGbGFnczIgPSBVcGRhdGU7XG5cbiAgICAgIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MyIHw9IExheW91dFN0YXRpYztcbiAgICAgIH1cblxuICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIF9maWJlckZsYWdzMiB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gX2ZpYmVyRmxhZ3MyO1xuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHN0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn0gLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cblxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID8gdW5yZXNvbHZlZE9sZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgdW5yZXNvbHZlZE5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IHVucmVzb2x2ZWROZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAodW5yZXNvbHZlZE9sZFByb3BzID09PSB1bnJlc29sdmVkTmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgJiYgIShlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHx8IC8vIFRPRE86IEluIHNvbWUgY2FzZXMsIHdlJ2xsIGVuZCB1cCBjaGVja2luZyBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkIHR3aWNlLFxuICAvLyBib3RoIGJlZm9yZSBhbmQgYWZ0ZXIgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaGFzIGJlZW4gY2FsbGVkLiBOb3QgaWRlYWwsXG4gIC8vIGJ1dCBJJ20gbG9hdGggdG8gcmVmYWN0b3IgdGhpcyBmdW5jdGlvbi4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIG1lbW9pemVkXG4gIC8vIGNvbXBvbmVudHMgc28gaXQncyBub3QgdGhhdCBjb21tb24uXG4gIGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICA7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKSxcbiAgICBkaWdlc3Q6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIGRpZ2VzdCwgc3RhY2spIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBudWxsLFxuICAgIHN0YWNrOiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiBudWxsLFxuICAgIGRpZ2VzdDogZGlnZXN0ICE9IG51bGwgPyBkaWdlc3QgOiBudWxsXG4gIH07XG59XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKTsgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG5cbiAgICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnOyAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgICAvLyBXZSByZWNvcmQgdGhpcyBpbmZvcm1hdGlvbiBhcyBhbiBleHBhbmRvIG9uIHRoZSBlcnJvci5cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICBpZiAoYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIC8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuICAgICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgICAvLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXG5cbiAgICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBzb3VyY2UgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHNvdXJjZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuXG4gICAgICBpZiAoYm91bmRhcnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSkgfHwgJ0Fub255bW91cyc7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSBjb21wb25lbnROYW1lTWVzc2FnZSArIFwiXFxuXCIgKyBjb21wb25lbnRTdGFjayArIFwiXFxuXFxuXCIgKyAoXCJcIiArIGVycm9yQm91bmRhcnlNZXNzYWdlKTsgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oY29tYmluZWRNZXNzYWdlKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHdlIHByaW50IHRoZSBlcnJvciBkaXJlY3RseS5cbiAgICAgIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBtZXNzYWdlLCB0aGUgSlMgc3RhY2ssIGFuZCBhbnl0aGluZyB0aGUgYnJvd3NlciB3YW50cyB0byBzaG93LlxuICAgICAgLy8gV2UgcGFzcyB0aGUgZXJyb3Igb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIG1lc3NhZ2Ugc28gdGhhdCB0aGUgYnJvd3NlciBkaXNwbGF5cyB0aGUgZXJyb3IgbmF0aXZlbHkuXG4gICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTsgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cblxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogbnVsbFxuICB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvciQxKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKGZpYmVyLmxhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuICAvL1xuICAvLyBUaGUgZGF0YSBtaWdodCByZXNvbHZlIGJlZm9yZSB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNvbW1pdCB0aGUgZmFsbGJhY2suIE9yLFxuICAvLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4gIC8vIGF0dGFjaCBhIGxpc3RlbmVyIG5vdy4gV2hlbiBpdCByZXNvbHZlcyAoXCJwaW5nc1wiKSwgd2UgY2FuIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIHRyeSByZW5kZXJpbmcgdGhlIHRyZWUgYWdhaW4uXG4gIC8vXG4gIC8vIE9ubHkgYXR0YWNoIGEgbGlzdGVuZXIgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lc1xuICAvLyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICAvL1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeSBTdXNwZW5zZSBhbHdheXNcbiAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG4gICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdha2VhYmxlLnRoZW4ocGluZywgcGluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LCByb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gUmV0cnkgbGlzdGVuZXJcbiAgLy9cbiAgLy8gSWYgdGhlIGZhbGxiYWNrIGRvZXMgY29tbWl0LCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGRpZmZlcmVudCB0eXBlIG9mXG4gIC8vIGxpc3RlbmVyLiBUaGlzIG9uZSBzY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBTdXNwZW5zZSBib3VuZGFyeSB0byB0dXJuXG4gIC8vIHRoZSBmYWxsYmFjayBzdGF0ZSBvZmYuXG4gIC8vXG4gIC8vIFN0YXNoIHRoZSB3YWtlYWJsZSBvbiB0aGUgYm91bmRhcnkgZmliZXIgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGVcbiAgLy8gY29tbWl0IHBoYXNlLlxuICAvL1xuICAvLyBXaGVuIHRoZSB3YWtlYWJsZSByZXNvbHZlcywgd2UnbGwgYXR0ZW1wdCB0byByZW5kZXIgdGhlIGJvdW5kYXJ5XG4gIC8vIGFnYWluIChcInJldHJ5XCIpLlxuICB2YXIgd2FrZWFibGVzID0gc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzID09PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gbmV3IFNldCgpO1xuICAgIHVwZGF0ZVF1ZXVlLmFkZCh3YWtlYWJsZSk7XG4gICAgc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICB9IGVsc2Uge1xuICAgIHdha2VhYmxlcy5hZGQod2FrZWFibGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3VzcGVuZGVkQ29tcG9uZW50KHNvdXJjZUZpYmVyLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gQSBsZWdhY3kgbW9kZSBTdXNwZW5zZSBxdWlyaywgb25seSByZWxldmFudCB0byBob29rIGNvbXBvbmVudHMuXG5cblxuICB2YXIgdGFnID0gc291cmNlRmliZXIudGFnO1xuXG4gIGlmICgoc291cmNlRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8IHRhZyA9PT0gRm9yd2FyZFJlZiB8fCB0YWcgPT09IFNpbXBsZU1lbW9Db21wb25lbnQpKSB7XG4gICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBjdXJyZW50U291cmNlLnVwZGF0ZVF1ZXVlO1xuICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKSB7XG4gIHZhciBub2RlID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgLy8gYm91bmRhcnkuXG5cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIG1hcmtzIGEgU3VzcGVuc2UgYm91bmRhcnkgc28gdGhhdCB3aGVuIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2ssXG4gIC8vIGl0IGNhcHR1cmVzIHRoZSBzdXNwZW5kZWQgXCJleGNlcHRpb25cIiBhbmQgZG9lcyBhIHNlY29uZCAoZmFsbGJhY2spIHBhc3MuXG4gIGlmICgoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAvLyBMZWdhY3kgTW9kZSBTdXNwZW5zZVxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIGluIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAvLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbiAgICAvLyBudWxsIGFuZCBrZWVwIHJlbmRlcmluZy4gV2hlbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgY29tcGxldGVzLFxuICAgIC8vIHdlJ2xsIGRvIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbiAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeSA9PT0gcmV0dXJuRmliZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBzdXNwZW5kZWQgd2hpbGUgcmVjb25jaWxpbmcgdGhlIGNoaWxkcmVuIG9mXG4gICAgICAvLyBhIFN1c3BlbnNlIGJvdW5kYXJ5J3MgaW5uZXIgT2Zmc2NyZWVuIHdyYXBwZXIgZmliZXIuIFRoaXMgaGFwcGVuc1xuICAgICAgLy8gd2hlbiBhIFJlYWN0LmxhenkgY29tcG9uZW50IGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbiAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgICAgLy9cbiAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGltcGxlbWVudGVkIGFzIG11bHRpcGxlIGZpYmVycywgYnV0IHRoZXlcbiAgICAgIC8vIGFyZSBhIHNpbmdsZSBjb25jZXB0dWFsIHVuaXQuIFRoZSBsZWdhY3kgbW9kZSBiZWhhdmlvciB3aGVyZSB3ZVxuICAgICAgLy8gcHJldGVuZCB0aGUgc3VzcGVuZGVkIGZpYmVyIGNvbW1pdHRlZCBhcyBgbnVsbGAgd29uJ3Qgd29yayxcbiAgICAgIC8vIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHRoZSBcInN1c3BlbmRlZFwiIGZpYmVyIGlzIHRoZSBpbm5lclxuICAgICAgLy8gT2Zmc2NyZWVuIHdyYXBwZXIuXG4gICAgICAvL1xuICAgICAgLy8gQmVjYXVzZSB0aGUgY29udGVudHMgb2YgdGhlIGJvdW5kYXJ5IGhhdmVuJ3Qgc3RhcnRlZCByZW5kZXJpbmdcbiAgICAgIC8vIHlldCAoaS5lLiBub3RoaW5nIGluIHRoZSB0cmVlIGhhcyBwYXJ0aWFsbHkgcmVuZGVyZWQpIHdlIGNhblxuICAgICAgLy8gc3dpdGNoIHRvIHRoZSByZWd1bGFyLCBjb25jdXJyZW50IG1vZGUgYmVoYXZpb3I6IG1hcmsgdGhlXG4gICAgICAvLyBib3VuZGFyeSB3aXRoIFNob3VsZENhcHR1cmUgYW5kIGVudGVyIHRoZSB1bndpbmQgcGhhc2UuXG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7IC8vIFdlJ3JlIGdvaW5nIHRvIGNvbW1pdCB0aGlzIGZpYmVyIGV2ZW4gdGhvdWdoIGl0IGRpZG4ndCBjb21wbGV0ZS5cbiAgICAgIC8vIEJ1dCB3ZSBzaG91bGRuJ3QgY2FsbCBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgb3IgY2FsbGJhY2tzLiBSZW1vdmVcbiAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG4gICAgICBpZiAoc291cmNlRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50LiBDaGFuZ2UgdGhlIHRhZyBzbyBpdCdzIG5vdCBtaXN0YWtlbiBmb3IgYVxuICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyA9IEluY29tcGxldGVDbGFzc0NvbXBvbmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4gICAgICAgICAgLy8gc2luY2UgaXQncyBrbm93biB0byBiZSBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFVzZSBhIGZvcmNlIHVwZGF0ZSB0b1xuICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBTeW5jTGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSwgU3luY0xhbmUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cblxuXG4gICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbiAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG4gICAgcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO1xuXG4gICAge1xuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgc291cmNlRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICAgIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtcblxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAgICAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuXG4gICAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICBpZiAoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHN5bmMgdXBkYXRlLiBTdXNwZW5kLiBTaW5jZSB3ZSdyZSBub3QgYWN0aXZhdGluZyBhXG4gICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcbiAgICAgICAgLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbiAgICAgICAgLy8gcmVmcmVzaCB0cmFuc2l0aW9ucyBzaG91bGQgd29yaywgdG9vLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gY29tbWl0XG4gICAgICAgIC8vIHRoZSBmYWxsYmFja3MgYW55d2F5LilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjYXNlIGFsc28gYXBwbGllcyB0byBpbml0aWFsIGh5ZHJhdGlvbi5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhpcyBpcyBhIHN5bmMvZGlzY3JldGUgdXBkYXRlLiBXZSB0cmVhdCB0aGlzIGNhc2UgbGlrZSBhbiBlcnJvclxuICAgICAgLy8gYmVjYXVzZSBkaXNjcmV0ZSByZW5kZXJzIGFyZSBleHBlY3RlZCB0byBwcm9kdWNlIGEgY29tcGxldGUgdHJlZVxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIGV4dGVybmFsIHN0YXRlLlxuXG5cbiAgICAgIHZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3IgPSBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnICsgJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTsgLy8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuICAgICAgLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxuXG4gICAgICB2YWx1ZSA9IHVuY2F1Z2h0U3VzcGVuc2VFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTtcblxuICAgICAgdmFyIF9zdXNwZW5zZUJvdW5kYXJ5ID0gZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpOyAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBkdXJpbmcgaHlkcmF0aW9uLCB3ZSBtYXkgYmUgYWJsZSB0byByZWNvdmVyIGJ5XG4gICAgICAvLyBkaXNjYXJkaW5nIHRoZSBkZWh5ZHJhdGVkIGNvbnRlbnQgYW5kIHN3aXRjaGluZyB0byBhIGNsaWVudCByZW5kZXIuXG4gICAgICAvLyBJbnN0ZWFkIG9mIHN1cmZhY2luZyB0aGUgZXJyb3IsIGZpbmQgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnlcbiAgICAgIC8vIGFuZCByZW5kZXIgaXQgYWdhaW4gd2l0aG91dCBoeWRyYXRpb24uXG5cblxuICAgICAgaWYgKF9zdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgoX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFNldCBhIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB3ZSBzaG91bGQgdHJ5IHJlbmRlcmluZyB0aGUgbm9ybWFsXG4gICAgICAgICAgLy8gY2hpbGRyZW4gYWdhaW4sIG5vdCB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoX3N1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKTsgLy8gRXZlbiB0aG91Z2ggdGhlIHVzZXIgbWF5IG5vdCBiZSBhZmZlY3RlZCBieSB0aGlzIGVycm9yLCB3ZSBzaG91bGRcbiAgICAgICAgLy8gc3RpbGwgbG9nIGl0IHNvIGl0IGNhbiBiZSBmaXhlZC5cblxuICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICByZW5kZXJEaWRFcnJvcih2YWx1ZSk7IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfZXJyb3JJbmZvLCBsYW5lKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBlcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzICYmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCBfbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCkge1xuICB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IHN1c3BlbmRzLiBJdCByZXR1cm5zIHRoZVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcztcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcztcbnZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xudmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyO1xudmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO1xudmFyIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQ7XG5cbntcbiAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnMgPSB7fTtcbiAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciA9IHt9O1xuICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyA9IHt9O1xuICBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIENvbXBvbmVudC5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgZXJyb3IoJyVzOiBTdXBwb3J0IGZvciBkZWZhdWx0UHJvcHMgd2lsbCBiZSByZW1vdmVkIGZyb20gbWVtbyBjb21wb25lbnRzICcgKyAnaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVXNlIEphdmFTY3JpcHQgZGVmYXVsdCBwYXJhbWV0ZXJzIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKF9pbm5lclByb3BUeXBlcykge1xuICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICBjaGVja1Byb3BUeXBlcyhfaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChvdXRlck1lbW9UeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgLy8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG91dGVyTWVtb1R5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gbnVsbDtcbiAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cbiAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gb3V0ZXJNZW1vVHlwZSAmJiBvdXRlck1lbW9UeXBlLnByb3BUeXBlcztcblxuICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoZSBwcm9wcyBhcmUgc2hhbGxvd2x5IGVxdWFsLiBSZXVzZSB0aGUgcHJldmlvdXMgcHJvcHMgb2JqZWN0LCBsaWtlIHdlXG4gICAgICAvLyB3b3VsZCBkdXJpbmcgYSBub3JtYWwgZmliZXIgYmFpbG91dC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHN0cm9uZyBndWFyYW50ZWVzIHRoYXQgdGhlIHByb3BzIG9iamVjdCBpcyByZWZlcmVudGlhbGx5XG4gICAgICAvLyBlcXVhbCBkdXJpbmcgdXBkYXRlcyB3aGVyZSB3ZSBjYW4ndCBiYWlsIG91dCBhbnl3YXkg4oCUIGxpa2UgaWYgdGhlIHByb3BzXG4gICAgICAvLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuICAgICAgLy8gc2FtZSBiYXRjaC5cbiAgICAgIC8vXG4gICAgICAvLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG4gICAgICAvLyBhY3Jvc3MgZGlmZmVyZW50IHdheXMgb2YgbWVtb2l6aW5nIGEgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgUmVhY3QubWVtb1xuICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IGludGVybmFsIEZpYmVyIGxheW91dCBpZiB5b3UgcGFzcyBhIG5vcm1hbCBmdW5jdGlvblxuICAgICAgLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuICAgICAgLy8gbGlrZSBmb3J3YXJkUmVmIChNZW1vQ29tcG9uZW50KS4gQnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuICAgICAgLy8gV3JhcHBpbmcgYSBjb21wb25lbnQgaW4gZm9yd2FyZFJlZiAob3IgUmVhY3QubGF6eSwgZXRjKSBzaG91bGRuJ3RcbiAgICAgIC8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcztcblxuICAgICAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuICAgICAgICAvLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW11bGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiApIHtcbiAgICAvLyBSZW5kZXJpbmcgYSBoaWRkZW4gdHJlZS5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBob3cgT2Zmc2NyZWVuIHNob3VsZCB3b3JrIHdpdGggdHJhbnNpdGlvbnMgaW4gdGhlIGZ1dHVyZVxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGwsXG4gICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgIHZhciBzcGF3bmVkQ2FjaGVQb29sID0gbnVsbDsgLy8gV2UncmUgaGlkZGVuLCBhbmQgd2UncmUgbm90IHJlbmRlcmluZyBhdCBPZmZzY3JlZW4uIFdlIHdpbGwgYmFpbCBvdXRcbiAgICAgIC8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxuXG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IHNwYXduZWRDYWNoZVBvb2wsXG4gICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlci4gVGhlIHN1cnJvdW5kaW5nIHZpc2libGUgY29udGVudCBoYXMgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBOb3cgd2UgcmVzdW1lIHJlbmRlcmluZyB0aGUgaGlkZGVuIHRyZWUuXG4gICAgICAvLyBSZW5kZXJpbmcgYXQgb2Zmc2NyZWVuLCBzbyB3ZSBjYW4gY2xlYXIgdGhlIGJhc2UgbGFuZXMuXG4gICAgICB2YXIgX25leHRTdGF0ZTIgPSB7XG4gICAgICAgIGJhc2VMYW5lczogTm9MYW5lcyxcbiAgICAgICAgY2FjaGVQb29sOiBudWxsLFxuICAgICAgICB0cmFuc2l0aW9uczogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlMjsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICB2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmJhc2VMYW5lcyA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICB2YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgfVxuXG4gICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBfc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufSAvLyBOb3RlOiBUaGVzZSBoYXBwZW4gdG8gaGF2ZSBpZGVudGljYWwgYmVnaW4gcGhhc2VzLCBmb3Igbm93LiBXZSBzaG91bGRuJ3QgaG9sZFxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG4gICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZlN0YXRpYztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuICAgIHN3aXRjaCAoc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cbiAgICAgICAgICB2YXIgdGVtcEluc3RhbmNlID0gbmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcywgX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRlbXBJbnN0YW5jZS5zdGF0ZTtcblxuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgICAgICAgIHZhciBlcnJvciQxID0gbmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLCB3b3JrSW5Qcm9ncmVzcyksIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHNob3VsZFVwZGF0ZTtcblxuICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICByZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTsgLy8gSW4gdGhlIGluaXRpYWwgcGFzcyB3ZSBtaWdodCBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG5cbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIHZhciBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKCBwcmV2U3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgLy8gVGhpcyBpcyBhIGh5ZHJhdGlvbiByb290IHdob3NlIHNoZWxsIGhhcyBub3QgeWV0IGh5ZHJhdGVkLiBXZSBzaG91bGRcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUuXG4gICAgLy8gRmxpcCBpc0RlaHlkcmF0ZWQgdG8gZmFsc2UgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIHRoaXMgcmVuZGVyXG4gICAgLy8gZmluaXNoZXMsIHRoZSByb290IHdpbGwgbm8gbG9uZ2VyIGJlIGRlaHlkcmF0ZWQuXG4gICAgdmFyIG92ZXJyaWRlU3RhdGUgPSB7XG4gICAgICBlbGVtZW50OiBuZXh0Q2hpbGRyZW4sXG4gICAgICBpc0RlaHlkcmF0ZWQ6IGZhbHNlLFxuICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZSxcbiAgICAgIHBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXM6IG5leHRTdGF0ZS5wZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzLFxuICAgICAgdHJhbnNpdGlvbnM6IG5leHRTdGF0ZS50cmFuc2l0aW9uc1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4gICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4gICAgICAvLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLlxuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJyArICdvZiBhIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGUgZW50aXJlIHJvb3Qgd2lsbCBzd2l0Y2ggdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIHJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBfcmVjb3ZlcmFibGVFcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKG5ldyBFcnJvcignVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlICcgKyAnaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuJyksIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzLCBfcmVjb3ZlcmFibGVFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvdXRlcm1vc3Qgc2hlbGwgaGFzIG5vdCBoeWRyYXRlZCB5ZXQuIFN0YXJ0IGh5ZHJhdGluZy5cbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB2YXIgY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgICB2YXIgbm9kZSA9IGNoaWxkO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUm9vdCBpcyBub3QgZGVoeWRyYXRlZC4gRWl0aGVyIHRoaXMgaXMgYSBjbGllbnQtb25seSByb290LCBvciBpdFxuICAgIC8vIGFscmVhZHkgaHlkcmF0ZWQuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIHJlY292ZXJhYmxlRXJyb3IpIHtcbiAgLy8gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG4gIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG4gICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGFzIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICE9PSBudWxsICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ29udGVudFJlc2V0O1xuICB9XG5cbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXp5Q29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKSB7XG4gIHJlc2V0U3VzcGVuZGVkQ3VycmVudE9uTW91bnRJbkxlZ2FjeU1vZGUoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlTWVtb0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLCByZXNvbHZlZFByb3BzKSwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICAgIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIGhpbnQgPSAnJztcblxuICB7XG4gICAgaWYgKENvbXBvbmVudCAhPT0gbnVsbCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgaGludCA9ICcgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT8nO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1lbnRpb24gRm9yd2FyZFJlZiBvciBNZW1vQ29tcG9uZW50XG4gIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbC5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gXCIgKyAoXCJMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQpKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgcmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpOyAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuXG4gIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgcmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIGhhc0lkO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICB7XG4gICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIC8vIFJ1biB0aGVzZSBjaGVja3MgaW4gcHJvZHVjdGlvbiBvbmx5IGlmIHRoZSBmbGFnIGlzIG9mZi5cbiAgLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cbiAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICAgIHZhciBoYXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAge1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKG51bGwsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSwgcmVuZGVyTGFuZXMpO1xuXG4gICAge1xuICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCAnJztcbiAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcblxuICAgICAgaWYgKGRlYnVnU291cmNlKSB7XG4gICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4gJyArICdEaWQgeW91IG1lYW4gdG8gdXNlIFJlYWN0LmZvcndhcmRSZWYoKT8lcycsIGluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggQ29tcG9uZW50LmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCclczogU3VwcG9ydCBmb3IgZGVmYXVsdFByb3BzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGZ1bmN0aW9uIGNvbXBvbmVudHMgJyArICdpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBVc2UgSmF2YVNjcmlwdCBkZWZhdWx0IHBhcmFtZXRlcnMgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgdHJlZUNvbnRleHQ6IG51bGwsXG4gIHJldHJ5TGFuZTogTm9MYW5lXG59O1xuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLFxuICAgIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSxcbiAgICB0cmFuc2l0aW9uczogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNhY2hlUG9vbCA9IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuICAgIGNhY2hlUG9vbDogY2FjaGVQb29sLFxuICAgIHRyYW5zaXRpb25zOiBwcmV2T2Zmc2NyZWVuU3RhdGUudHJhbnNpdGlvbnNcbiAgfTtcbn0gLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIGlubGluZSB0aGlzIGJhY2tcblxuXG5mdW5jdGlvbiBzaG91bGRSZW1haW5PbkZhbGxiYWNrKHN1c3BlbnNlQ29udGV4dCwgY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgbmVlZCB0b1xuICAvLyByZW1haW4gb24gdGhhdCBmYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNvbnRlbnQgaGFzIHJlc29sdmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgU3VzcGVuc2VMaXN0IGNvb3JkaW5hdGVzIHdoZW4gbmVzdGVkIGNvbnRlbnQgYXBwZWFycy5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdXNwZW5zZVN0YXRlID09PSBudWxsKSB7XG4gICAgICAvLyBDdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBEb24ndCBoaWRlIGl0LCBldmVuIGlmIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuICAgICAgLy8gaXMgdHJ1ZS4gTW9yZSBwcmVjaXNlIG5hbWUgbWlnaHQgYmUgXCJGb3JjZVJlbWFpblN1c3BlbnNlRmFsbGJhY2tcIi5cbiAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBmYWN0b3Jpbmcgc21lbGwuIENhbid0IHJlbWFpbiBvbiBhIGZhbGxiYWNrIGlmIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5cblxuICByZXR1cm4gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogU2hvdWxkIG5vdCByZW1vdmUgcmVuZGVyIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gIHJldHVybiByZW1vdmVMYW5lcyhjdXJyZW50LmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIHN1c3BlbmQuXG5cbiAge1xuICAgIGlmIChzaG91bGRTdXNwZW5kKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICB2YXIgc2hvd0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKGRpZFN1c3BlbmQgfHwgc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQpKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbiAgICAvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgIHNob3dGYWxsYmFjayA9IHRydWU7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXR0ZW1wdGluZyB0aGUgbWFpbiBjb250ZW50XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50IG9yIHRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgc3RhdGUuXG4gICAgICAvLyBNYXJrIHRoaXMgc3VidHJlZSBjb250ZXh0IGFzIGhhdmluZyBhdCBsZWFzdCBvbmUgaW52aXNpYmxlIHBhcmVudCB0aGF0IGNvdWxkXG4gICAgICAvLyBoYW5kbGUgdGhlIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gQXZvaWRlZCBib3VuZGFyaWVzIGFyZSBub3QgY29uc2lkZXJlZCBzaW5jZSB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbiAgICAgIHtcbiAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxpYXRpb24gbG9naWMuIFR3b1xuICAvLyBtYWluIHJlYXNvbnMgdGhpcyBpcyBzbyBjb21wbGljYXRlZC5cbiAgLy9cbiAgLy8gRmlyc3QsIExlZ2FjeSBNb2RlIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhlXG4gIC8vIHByaW1hcnkgdHJlZSB3aWxsIGNvbW1pdCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUsIHNvIHdoZW4gd2UgZG8gdGhlXG4gIC8vIHNlY29uZCBwYXNzIHRvIHJlbmRlciB0aGUgZmFsbGJhY2ssIHdlIGRvIHNvbWUgZXhjZWVkaW5nbHksIHVoLCBjbGV2ZXJcbiAgLy8gaGFja3MgdG8gbWFrZSB0aGF0IG5vdCB0b3RhbGx5IGJyZWFrLiBMaWtlIHRyYW5zZmVycmluZyBlZmZlY3RzIGFuZFxuICAvLyBkZWxldGlvbnMgZnJvbSBoaWRkZW4gdHJlZS4gSW4gQ29uY3VycmVudCBNb2RlLCBpdCdzIG11Y2ggc2ltcGxlcixcbiAgLy8gYmVjYXVzZSB3ZSBiYWlsb3V0IG9uIHRoZSBwcmltYXJ5IHRyZWUgY29tcGxldGVseSBhbmQgbGVhdmUgaXQgaW4gaXRzIG9sZFxuICAvLyBzdGF0ZSwgbm8gZWZmZWN0cy4gU2FtZSBhcyB3aGF0IHdlIGRvIGZvciBPZmZzY3JlZW4gKGV4Y2VwdCB0aGF0XG4gIC8vIE9mZnNjcmVlbiBkb2Vzbid0IGhhdmUgdGhlIGZpcnN0IHJlbmRlciBwYXNzKS5cbiAgLy9cbiAgLy8gU2Vjb25kIGlzIGh5ZHJhdGlvbi4gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIFN1c3BlbnNlIGZpYmVyIGhhcyBhIHNsaWdodGx5XG4gIC8vIGRpZmZlcmVudCBsYXlvdXQsIHdoZXJlIHRoZSBjaGlsZCBwb2ludHMgdG8gYSBkZWh5ZHJhdGVkIGZyYWdtZW50LCB3aGljaFxuICAvLyBjb250YWlucyB0aGUgRE9NIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFRoaXJkLCBldmVuIGlmIHlvdSBzZXQgYWxsIHRoYXQgYXNpZGUsIFN1c3BlbnNlIGlzIGxpa2UgZXJyb3IgYm91bmRhcmllcyBpblxuICAvLyB0aGF0IHdlIGZpcnN0IHdlIHRyeSB0byByZW5kZXIgb25lIHRyZWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSByZW5kZXIgYWdhaW5cbiAgLy8gYW5kIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0cmVlLiBMaWtlIGEgdHJ5L2NhdGNoIGJsb2NrLiBTbyB3ZSBoYXZlIHRvIHRyYWNrXG4gIC8vIHdoaWNoIGJyYW5jaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nLiBJZGVhbGx5IHdlIHdvdWxkIG1vZGVsIHRoaXMgdXNpbmdcbiAgLy8gYSBzdGFjay5cblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudC5cblxuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGVoeWRyYXRlZCA9IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgaWYgKGRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBkZWh5ZHJhdGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuXG4gICAgICByZXR1cm4gZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RlaHlkcmF0ZWQgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgaWYgKF9kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIG5leHRQcm9wcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIubWVtb2l6ZWRTdGF0ZSA9IHByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjIgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuICAvLyB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCBOb0xhbmVzLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gbnVsbDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIERlbGV0ZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnRcbiAgICB2YXIgZGVsZXRpb25zID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnRdO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIGlmICggLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuICAobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfSAvLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG4gICAgLy8gdG8gZGVsZXRlIGl0LlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHByaW1hcnlDaGlsZFByb3BzKTsgLy8gU2luY2Ugd2UncmUgcmV1c2luZyBhIGN1cnJlbnQgdHJlZSwgd2UgbmVlZCB0byByZXVzZSB0aGUgZmxhZ3MsIHRvby5cbiAgICAvLyAoV2UgZG9uJ3QgZG8gdGhpcyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBpbiBsZWdhY3kgbW9kZSB3ZSBkb24ndCByZS11c2VcbiAgICAvLyB0aGUgY3VycmVudCB0cmVlOyBzZWUgcHJldmlvdXMgYnJhbmNoLilcblxuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuICB9XG5cbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQsIGZhbGxiYWNrQ2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4gICAgLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIHJlY292ZXJhYmxlRXJyb3IpIHtcbiAgLy8gRmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuIEJlY2F1c2UgdGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAgLy8gaW1wbGljYXRpb25zLCBpdCdzIGNvbnNpZGVyZWQgYSByZWNvdmVyYWJsZSBlcnJvciwgZXZlbiB0aG91Z2ggdGhlIHVzZXJcbiAgLy8gbGlrZWx5IHdvbid0IG9ic2VydmUgYW55dGhpbmcgd3Jvbmcgd2l0aCB0aGUgVUkuXG4gIC8vXG4gIC8vIFRoZSBlcnJvciBpcyBwYXNzZWQgaW4gYXMgYW4gYXJndW1lbnQgdG8gZW5mb3JjZSB0aGF0IGV2ZXJ5IGNhbGxlciBwcm92aWRlXG4gIC8vIGEgY3VzdG9tIG1lc3NhZ2UsIG9yIGV4cGxpY2l0bHkgb3B0IG91dCAoY3VycmVudGx5IHRoZSBvbmx5IHBhdGggdGhhdCBvcHRzXG4gIC8vIG91dCBpcyBsZWdhY3kgbW9kZTsgZXZlcnkgY29uY3VycmVudCBwYXRoIHByb3ZpZGVzIGFuIGVycm9yKS5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3IgIT09IG51bGwpIHtcbiAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICB9IC8vIFRoaXMgd2lsbCBhZGQgdGhlIG9sZCBmaWJlciB0byB0aGUgZGVsZXRpb24gbGlzdFxuXG5cbiAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTsgLy8gV2UncmUgbm93IG5vdCBzdXNwZW5kZWQgbm9yIGRlaHlkcmF0ZWQuXG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4gIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgZmliZXJNb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgZmliZXJNb2RlKTtcbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIGZpYmVyTW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkpIGFscmVhZHkgbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIGRyb3BwZWQgdGhlIGVmZmVjdCBsaXN0IHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgIC8vIGRlbGV0aW9uLiBXZSBuZWVkIHRvIHJlY29uY2lsZSB0byBkZWxldGUgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBEdXJpbmcgdGhlIGZpcnN0IHBhc3MsIHdlJ2xsIGJhaWwgb3V0IGFuZCBub3QgZHJpbGwgaW50byB0aGUgY2hpbGRyZW4uXG4gIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHRoZSBjb250ZW50IGluIHBsYWNlIGFuZCB0cnkgdG8gaHlkcmF0ZSBpdCBsYXRlci5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignQ2Fubm90IGh5ZHJhdGUgU3VzcGVuc2UgaW4gbGVnYWN5IG1vZGUuIFN3aXRjaCBmcm9tICcgKyAnUmVhY3RET00uaHlkcmF0ZShlbGVtZW50LCBjb250YWluZXIpIHRvICcgKyAnUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCA8QXBwIC8+KScgKyAnLnJlbmRlcihlbGVtZW50KSBvciByZW1vdmUgdGhlIFN1c3BlbnNlIGNvbXBvbmVudHMgZnJvbSAnICsgJ3RoZSBzZXJ2ZXIgcmVuZGVyZWQgY29tcG9uZW50cy4nKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKFN5bmNMYW5lKTtcbiAgfSBlbHNlIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgIC8vIFRoaXMgaXMgYSBjbGllbnQtb25seSBib3VuZGFyeS4gU2luY2Ugd2Ugd29uJ3QgZ2V0IGFueSBjb250ZW50IGZyb20gdGhlIHNlcnZlclxuICAgIC8vIGZvciB0aGlzLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoYXQgYXQgYSBoaWdoZXIgcHJpb3JpdHkgYmFzZWQgb24gd2hlbiBpdCB3b3VsZFxuICAgIC8vIGhhdmUgdGltZWQgb3V0LiBJbiB0aGVvcnkgd2UgY291bGQgcmVuZGVyIGl0IGluIHRoaXMgcGFzcyBidXQgaXQgd291bGQgaGF2ZSB0aGVcbiAgICAvLyB3cm9uZyBwcmlvcml0eSBhc3NvY2lhdGVkIHdpdGggaXQgYW5kIHdpbGwgcHJldmVudCBoeWRyYXRpb24gb2YgcGFyZW50IHBhdGguXG4gICAgLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgd29yayBsZWZ0IG9uIGl0IHRvIHJlbmRlciBpdCBpbiBhIHNlcGFyYXRlIGNvbW1pdC5cbiAgICAvLyBUT0RPIFRoaXMgdGltZSBzaG91bGQgYmUgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIHNlcnZlciByZW5kZXJlZCByZXNwb25zZSB0aGF0IGlzXG4gICAgLy8gYSBwYXJlbnQgdG8gdGhpcyBib3VuZGFyeSB3YXMgZGlzcGxheWVkLiBIb3dldmVyLCBzaW5jZSB3ZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZVxuICAgIC8vIGEgcHJvdG9jb2wgdG8gdHJhbnNmZXIgdGhhdCB0aW1lLCB3ZSdsbCBqdXN0IGVzdGltYXRlIGl0IGJ5IHVzaW5nIHRoZSBjdXJyZW50XG4gICAgLy8gdGltZS4gVGhpcyB3aWxsIG1lYW4gdGhhdCBTdXNwZW5zZSB0aW1lb3V0cyBhcmUgc2xpZ2h0bHkgc2hpZnRlZCB0byBsYXRlciB0aGFuXG4gICAgLy8gdGhleSBzaG91bGQgYmUuXG4gICAgLy8gU2NoZWR1bGUgYSBub3JtYWwgcHJpIHVwZGF0ZSB0byByZW5kZXIgdGhpcyBjb250ZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoRGVmYXVsdEh5ZHJhdGlvbkxhbmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlJ2xsIGNvbnRpbnVlIGh5ZHJhdGluZyB0aGUgcmVzdCBhdCBvZmZzY3JlZW4gcHJpb3JpdHkgc2luY2Ugd2UnbGwgYWxyZWFkeVxuICAgIC8vIGJlIHNob3dpbmcgdGhlIHJpZ2h0IGNvbnRlbnQgY29taW5nIGZyb20gdGhlIHNlcnZlciwgaXQgaXMgbm8gcnVzaC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZGlkU3VzcGVuZCwgbmV4dFByb3BzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLCByZW5kZXJMYW5lcykge1xuICBpZiAoIWRpZFN1c3BlbmQpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGFzcy4gQXR0ZW1wdCB0byBoeWRyYXRlLlxuICAgIC8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuICAgIC8vIGJ1dCBhZnRlciB3ZSd2ZSBhbHJlYWR5IGNvbW1pdHRlZCBvbmNlLlxuICAgIHdhcm5JZkh5ZHJhdGluZygpO1xuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIC8vIFRPRE86IFdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIGFyZ3VtZW50XG4gICAgICAvLyByZXF1aXJlZCDigJQgZXZlcnkgY29uY3VycmVudCBtb2RlIHBhdGggdGhhdCBjYXVzZXMgaHlkcmF0aW9uIHRvXG4gICAgICAvLyBkZS1vcHQgdG8gY2xpZW50IHJlbmRlcmluZyBzaG91bGQgaGF2ZSBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGluIGEgcGVybWFuZW50IGZhbGxiYWNrIHN0YXRlLiBJbiB0aGlzIGNhc2UsIHdlJ2xsIG5ldmVyXG4gICAgICAvLyBnZXQgYW4gdXBkYXRlIGFuZCB3ZSdsbCBuZXZlciBiZSBhYmxlIHRvIGh5ZHJhdGUgdGhlIGZpbmFsIGNvbnRlbnQuIExldCdzIGp1c3QgdHJ5IHRoZVxuICAgICAgLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG4gICAgICB2YXIgZGlnZXN0LCBtZXNzYWdlLCBzdGFjaztcblxuICAgICAge1xuICAgICAgICB2YXIgX2dldFN1c3BlbnNlSW5zdGFuY2VGID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKHN1c3BlbnNlSW5zdGFuY2UpO1xuXG4gICAgICAgIGRpZ2VzdCA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5kaWdlc3Q7XG4gICAgICAgIG1lc3NhZ2UgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYubWVzc2FnZTtcbiAgICAgICAgc3RhY2sgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYuc3RhY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvcjtcblxuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSAnICsgJ2R1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRWYWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IsIGRpZ2VzdCwgc3RhY2spO1xuICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgY2FwdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIC8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG5cblxuICAgIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSB8fCBoYXNDb250ZXh0Q2hhbmdlZCkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIG1lYW5zIHRoYXQgd2UgYXJlIG5vdyB1bmFibGUgdG9cbiAgICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICBpZiAoYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gTm9MYW5lICYmIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKSB7XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBtdXRhdGluZyBzaW5jZSB0aGlzIHJlbmRlciB3aWxsIGdldCBpbnRlcnJ1cHRlZC4gVGhpc1xuICAgICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAgICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lOyAvLyBUT0RPOiBJZGVhbGx5IHRoaXMgd291bGQgaW5oZXJpdCB0aGUgZXZlbnQgdGltZSBvZiB0aGUgY3VycmVudCByZW5kZXJcblxuICAgICAgICAgIHZhciBldmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbiAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSk7XG4gICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUsIGV2ZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBzY2hlZHVsZWQgaGlnaGVyIHByaSB3b3JrIGFib3ZlLCB0aGlzIHdpbGwgcHJvYmFibHkganVzdCBhYm9ydCB0aGUgcmVuZGVyXG4gICAgICAvLyBzaW5jZSB3ZSBub3cgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgd29yaywgYnV0IGluIGNhc2UgaXQgZG9lc24ndCwgd2UgbmVlZCB0byBwcmVwYXJlIHRvXG4gICAgICAvLyByZW5kZXIgc29tZXRoaW5nLCBpZiB3ZSB0aW1lIG91dC4gRXZlbiBpZiB0aGF0IHJlcXVpcmVzIHVzIHRvIGRlbGV0ZSBldmVyeXRoaW5nIGFuZFxuICAgICAgLy8gc2tpcCBoeWRyYXRpb24uXG4gICAgICAvLyBEZWxheSBoYXZpbmcgdG8gZG8gdGhpcyBhcyBsb25nIGFzIHRoZSBzdXNwZW5zZSB0aW1lb3V0IGFsbG93cyB1cy5cblxuXG4gICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG5cbiAgICAgIHZhciBfY2FwdHVyZWRWYWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUobmV3IEVycm9yKCdUaGlzIFN1c3BlbnNlIGJvdW5kYXJ5IHJlY2VpdmVkIGFuIHVwZGF0ZSBiZWZvcmUgaXQgZmluaXNoZWQgJyArICdoeWRyYXRpbmcuIFRoaXMgY2F1c2VkIHRoZSBib3VuZGFyeSB0byBzd2l0Y2ggdG8gY2xpZW50IHJlbmRlcmluZy4gJyArICdUaGUgdXN1YWwgd2F5IHRvIGZpeCB0aGlzIGlzIHRvIHdyYXAgdGhlIG9yaWdpbmFsIHVwZGF0ZSAnICsgJ2luIHN0YXJ0VHJhbnNpdGlvbi4nKSk7XG5cbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIF9jYXB0dXJlZFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIHN0aWxsIHBlbmRpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHNlcnZlciwgc28gd2UgY2FuJ3QgaHlkcmF0ZSBpdHNcbiAgICAgIC8vIGNvbnRlbnQuIFdlIHRyZWF0IGl0IGFzIGlmIHRoaXMgY29tcG9uZW50IHN1c3BlbmRlZCBpdHNlbGYuIEl0IG1pZ2h0IHNlZW0gYXMgaWZcbiAgICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4gICAgICAvLyBsb3Qgb2YgdW5uZWNlc3Nhcnkgd29yayBhbmQgaXMgdW5saWtlbHkgdG8gY29tcGxldGUgc2luY2UgaXQgb2Z0ZW4gd2lsbCBzdXNwZW5kXG4gICAgICAvLyBvbiBtaXNzaW5nIGRhdGEgYW55d2F5LiBBZGRpdGlvbmFsbHksIHRoZSBzZXJ2ZXIgbWlnaHQgYmUgYWJsZSB0byByZW5kZXIgbW9yZVxuICAgICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4gICAgICAvLyBvbiB0aGUgY2xpZW50IHRoYW4gaWYgd2UganVzdCBsZWF2ZSBpdCBhbG9uZS4gSWYgdGhlIHNlcnZlciB0aW1lcyBvdXQgb3IgZXJyb3JzXG4gICAgICAvLyB0aGVzZSBzaG91bGQgdXBkYXRlIHRoaXMgYm91bmRhcnkgdG8gdGhlIHBlcm1hbmVudCBGYWxsYmFjayBzdGF0ZSBpbnN0ZWFkLlxuICAgICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7IC8vIExlYXZlIHRoZSBjaGlsZCBpbiBwbGFjZS4gSS5lLiB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudC5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHJldHJ5IHRoaXMgYm91bmRhcnkgb25jZSB0aGUgc2VydmVyIGhhcyBzZW50IHRoZSByZXN1bHQuXG5cbiAgICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcbiAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KHN1c3BlbnNlSW5zdGFuY2UsIHJldHJ5KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LlxuICAgICAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLnRyZWVDb250ZXh0KTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBIeWRyYXRpbmc7XG4gICAgICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIgcGFzcy4gV2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gaHlkcmF0ZWQsIGJ1dFxuICAgIC8vIHNvbWV0aGluZyBlaXRoZXIgc3VzcGVuZGVkIG9yIGVycm9yZWQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBoeWRyYXRpb24uIFRyeSBhZ2FpbiB3aXRob3V0IGh5ZHJhdGluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcblxuICAgICAgdmFyIF9jYXB0dXJlZFZhbHVlMiA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUobmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7XG5cbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIF9jYXB0dXJlZFZhbHVlMik7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbiAgICAgIC8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG4gICAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCk7XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgZmlyc3RDaGlsZCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbiAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuICAvLyB0byB1bmJsb2NrLlxuICB2YXIgbm9kZSA9IGZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuICAgICAgLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4gICAgICAvLyBsaXN0IGl0c2VsZi5cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4gICAgICAvLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpIHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbiAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3JcbiAgLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4gIC8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4gIC8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuICAvLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxuICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcbiAgdmFyIGxhc3RDb250ZW50Um93ID0gbnVsbDtcblxuICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgIGxhc3RDb250ZW50Um93ID0gcm93O1xuICAgIH1cblxuICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAocmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCAmJiByZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICd0b2dldGhlcicgJiYgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSkge1xuICAgICAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG4gICAgICBpZiAodGFpbE1vZGUgIT09ICdjb2xsYXBzZWQnICYmIHRhaWxNb2RlICE9PSAnaGlkZGVuJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAge1xuICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5KGNoaWxkU2xvdCk7XG4gICAgdmFyIGlzSXRlcmFibGUgPSAhaXNBbkFycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBbkFycmF5IHx8IGlzSXRlcmFibGUpIHtcbiAgICAgIHZhciB0eXBlID0gaXNBbkFycmF5ID8gJ2FycmF5JyA6ICdpdGVyYWJsZSc7XG5cbiAgICAgIGVycm9yKCdBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiAnICsgJ2FuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6ICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+IC4uLiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uICcgKyAnPC9TdXNwZW5zZUxpc3Q+JywgdHlwZSwgaW5kZXgsIHR5cGUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4oY2hpbGRyZW4sIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAoKHJldmVhbE9yZGVyID09PSAnZm9yd2FyZHMnIHx8IHJldmVhbE9yZGVyID09PSAnYmFja3dhcmRzJykgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkcmVuW2ldLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5JdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW5JdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHZhciBfaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiAnICsgJ1RoaXMgaXMgbm90IHVzZWZ1bCBzaW5jZSBpdCBuZWVkcyBtdWx0aXBsZSByb3dzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsIHJldmVhbE9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGlzQmFja3dhcmRzLCB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocmVuZGVyU3RhdGUgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsOiB0YWlsLFxuICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIFN1c3BlbnNlTGlzdCBkb2Vzbid0IHdvcmsgc28gd2UganVzdFxuICAgIC8vIHVzZSBtYWtlIGl0IGEgbm9vcCBieSB0cmVhdGluZyBpdCBhcyB0aGUgZGVmYXVsdCByZXZlYWxPcmRlci5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnRSb3cgPSBmaW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO1xuICAgICAgICAgIHZhciB0YWlsO1xuXG4gICAgICAgICAgaWYgKGxhc3RDb250ZW50Um93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbiAgICAgICAgICAgIHRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG4gICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcbiAgICAgICAgICAgIGxhc3RDb250ZW50Um93LnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAvLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2VcbiAgICAgICAgICAvLyBvcmRlci5cbiAgICAgICAgICB2YXIgX3RhaWwgPSBudWxsO1xuICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJvdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Um93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuICAgICAgICAgICAgX3RhaWwgPSByb3c7XG4gICAgICAgICAgICByb3cgPSBuZXh0Um93O1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIHRydWUsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgX3RhaWwsIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB0YWlsTW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICB7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBudWxsLCAvLyB0YWlsXG4gICAgICAgICAgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4gICAgICAgICAgLy8gYSBib3VuZGFyeS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuICB7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXdQcm9wcykpIHtcbiAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcbiAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVyUHJvcFR5cGVzID0gd29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLCBuZXdQcm9wcywgJ3Byb3AnLCAnQ29udGV4dC5Qcm92aWRlcicpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuXG4gIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0SXMob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4gICAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICB7XG4gICAgaWYgKGNvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICBpZiAoY29udGV4dCAhPT0gY29udGV4dC5Db25zdW1lcikge1xuICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9jb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJlbmRlciA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQoY29udGV4dCk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCkge1xuICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGxhenkgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmOyAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG4gICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwcmV2U2libGluZy5zaWJsaW5nICE9PSBvbGRXb3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gV2Uga25vdyB0aGF0IHRoaXMgY29tcG9uZW50IHdpbGwgc3VzcGVuZCBhZ2FpbiBiZWNhdXNlIGlmIGl0IGhhc1xuICAgICAgICAgICAgLy8gYmVlbiB1bnN1c3BlbmRlZCBpdCBoYXMgY29tbWl0dGVkIGFzIGEgcmVzb2x2ZWQgU3VzcGVuc2UgY29tcG9uZW50LlxuICAgICAgICAgICAgLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7IC8vIFdlIHNob3VsZCBuZXZlciByZW5kZXIgdGhlIGNoaWxkcmVuIG9mIGEgZGVoeWRyYXRlZCBib3VuZGFyeSB1bnRpbCB3ZVxuICAgICAgICAgICAgLy8gdXBncmFkZSBpdC4gV2UgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrLlxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZExhbmVzID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztcblxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbiAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuICAgICAgICAgICAgICAvLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4gICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG4gICAgICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCAmJiAvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbiAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbiAgICAgIC8vIGl0cyBwYXJlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbiAgICAgIC8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4gICAgICAvLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbiAgICAgIC8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbiAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gZ2V0Rm9ya3NBdExldmVsKCk7XG4gICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICAgIH1cbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsIF91bnJlc29sdmVkUHJvcHMzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIF9yZXNvbHZlZFByb3BzMywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoX3R5cGUyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSwgX3Jlc29sdmVkUHJvcHMzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlMiwgX3Jlc29sdmVkUHJvcHMzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MiA/IF91bnJlc29sdmVkUHJvcHM0IDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MiwgX3VucmVzb2x2ZWRQcm9wczQpO1xuXG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZlN0YXRpYztcbiAgfVxufVxuXG52YXIgYXBwZW5kQWxsQ2hpbGRyZW47XG52YXIgdXBkYXRlSG9zdENvbnRhaW5lcjtcbnZhciB1cGRhdGVIb3N0Q29tcG9uZW50JDE7XG52YXIgdXBkYXRlSG9zdFRleHQkMTtcblxue1xuICAvLyBNdXRhdGlvbiBtb2RlXG4gIGFwcGVuZEFsbENoaWxkcmVuID0gZnVuY3Rpb24gKHBhcmVudCwgd29ya0luUHJvZ3Jlc3MsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSwgaXNIaWRkZW4pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7Ly8gTm9vcFxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4gICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAvLyBJbiBtdXRhdGlvbiBtb2RlLCB0aGlzIGlzIHN1ZmZpY2llbnQgZm9yIGEgYmFpbG91dCBiZWNhdXNlXG4gICAgICAvLyB3ZSB3b24ndCB0b3VjaCB0aGlzIG5vZGUgZXZlbiBpZiBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4gICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG5cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTsgLy8gVE9ETzogRXhwZXJpZW5jaW5nIGFuIGVycm9yIHdoZXJlIG9sZFByb3BzIGlzIG51bGwuIFN1Z2dlc3RzIGEgaG9zdFxuICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cblxuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkOyAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cblxuICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICBpZiAoaGFzVW5oeWRyYXRlZFRhaWxOb2RlcygpICYmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcbiAgICB3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKHdvcmtJblByb2dyZXNzKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXIgfCBJbmNvbXBsZXRlIHwgU2hvdWxkQ2FwdHVyZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCAmJiBuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAvLyBTdXNwZW5zZSBib3VuZGFyeSwgYW5kIGFsc28gYWZ0ZXIgd2UndmUgcmVlbnRlcmVkIGl0IGZvciBmdXJ0aGVyIGh5ZHJhdGlvbi5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKCF3YXNIeWRyYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgIC8vIHN0YXRlIHNpbmNlIHdlJ3JlIG5vdyBleGl0aW5nIG91dCBvZiBpdC4gcG9wSHlkcmF0aW9uU3RhdGUgZG9lc24ndCBkbyB0aGF0IGZvciB1cy5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkIGFuZCB1bnN1c3BlbmRlZC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgIC8vIGFzIGhhdmluZyBoeWRyYXRlZCBzbyBldmVudHMga25vdyB0aGF0IHRoZXkncmUgZnJlZSB0byBiZSBpbnZva2VkLlxuICAgICAgLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cbiAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgLy8gU28gd2UgbWlnaHQgYXMgd2VsbCBhbHdheXMgbWFyayB0aGlzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoX2lzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChfcHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIHRoaXMgdHJlZS4gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlcixcbiAgICAvLyB0aGVyZSBtYXkgaGF2ZSBiZWVuIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uXG4gICAgLy8gYXR0ZW1wdC4gSWYgc28sIGFkZCB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZS5cbiAgICB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpOyAvLyBGYWxsIHRocm91Z2ggdG8gbm9ybWFsIFN1c3BlbnNlIHBhdGhcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKCAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3RcbiAgICAgICAgICAgICAgIXByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQgfHwgLy8gQ2hlY2sgaWYgd2UgcmV2ZXJ0ZWQgdG8gY2xpZW50IHJlbmRlcmluZyAoZS5nLiBkdWUgdG8gYW4gZXJyb3IpXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb21taXQuIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBSZWFjdCByZW5kZXJpbmcgaW50byBhXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdG9vLCBiZWNhdXNlIGN1cnJlbnQuY2hpbGQgd291bGQgb25seSBiZSBudWxsIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIGNvbnRhaW5lciB3b3VsZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gYmUgZW1wdHkpLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90OyAvLyBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLCB0aGVyZSBtYXkgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgLy8gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb24gYXR0ZW1wdC4gSWYgc28sIGFkZFxuICAgICAgICAgICAgICAgIC8vIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlIGNvbW1pdCBwaGFzZS5cblxuICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cblxuXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcblxuICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG5cbiAgICAgICAgICB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsgLy8gU3BlY2lhbCBwYXRoIGZvciBkZWh5ZHJhdGVkIGJvdW5kYXJpZXMuIFdlIG1heSBldmVudHVhbGx5IG1vdmUgdGhpc1xuICAgICAgICAvLyB0byBpdHMgb3duIGZpYmVyIHR5cGUgc28gdGhhdCB3ZSBjYW4gYWRkIG90aGVyIGtpbmRzIG9mIGh5ZHJhdGlvblxuICAgICAgICAvLyBib3VuZGFyaWVzIHRoYXQgYXJlbid0IGFzc29jaWF0ZWQgd2l0aCBhIFN1c3BlbnNlIHRyZWUuIEluIGFudGljaXBhdGlvblxuICAgICAgICAvLyBvZiBzdWNoIGEgcmVmYWN0b3IsIGFsbCB0aGUgaHlkcmF0aW9uIGxvZ2ljIGlzIGNvbnRhaW5lZCBpblxuICAgICAgICAvLyB0aGlzIGJyYW5jaC5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCA9IGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSk7XG5cbiAgICAgICAgICBpZiAoIWZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlLiBUaGVyZSB3ZXJlIHJlbWFpbmluZyB1bmh5ZHJhdGVkIG5vZGVzLiBXZSB0cmVhdFxuICAgICAgICAgICAgICAvLyB0aGlzIGFzIGEgbWlzbWF0Y2guIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxuICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBEaWQgbm90IGZpbmlzaCBoeWRyYXRpbmcsIGVpdGhlciBiZWNhdXNlIHRoaXMgaXMgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgLy8gcmVuZGVyIG9yIGJlY2F1c2Ugc29tZXRoaW5nIHN1c3BlbmRlZC5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDb250aW51ZSB3aXRoIHRoZSBub3JtYWwgU3VzcGVuc2UgcGF0aC5cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7IC8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAvLyBhIHBhc3NpdmUgZWZmZWN0LCB3aGljaCBpcyB3aGVuIHdlIHByb2Nlc3MgdGhlIHRyYW5zaXRpb25zXG5cblxuICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgIT09IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gYW4gZWZmZWN0IHRvIHRvZ2dsZSB0aGUgc3VidHJlZSdzIHZpc2liaWxpdHkuIFdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgICAvLyBmYWxsYmFjayAtPiBwcmltYXJ5LCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIHNjaGVkdWxlcyB0aGlzIGVmZmVjdFxuICAgICAgICAgIC8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgICAvLyBwcmltYXJ5IC0+IGZhbGxiYWNrLCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIGRvZXMgbm90IGhhdmUgYSBjb21wbGV0ZVxuICAgICAgICAgIC8vIHBoYXNlLiBTbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGl0cyBlZmZlY3QgaGVyZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoaXMgZmxhZyB0byBjb25uZWN0L2Rpc2Nvbm5lY3QgdGhlIGVmZmVjdHMsIGJ1dCB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxvZ2ljIGFwcGxpZXM6IHdoZW4gcmUtY29ubmVjdGluZywgdGhlIE9mZnNjcmVlbiBmaWJlcidzIGNvbXBsZXRlXG4gICAgICAgICAgLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbiAgICAgICAgICAvLyBpcyBhY3RpdmUgdGhhdCB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwuXG5cblxuICAgICAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAgICAgdmFyIF9vZmZzY3JlZW5GaWJlcjIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIF9vZmZzY3JlZW5GaWJlcjIuZmxhZ3MgfD0gVmlzaWJpbGl0eTsgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgICAvLyBpbiB0aGUgY29uY3VycmVudCB0cmVlIGFscmVhZHkgc3VzcGVuZGVkIGR1cmluZyB0aGlzIHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBidWcuXG5cbiAgICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBiYWNrIHRvIHRocm93RXhjZXB0aW9uIGJlY2F1c2UgdGhpcyBpcyB0b28gbGF0ZVxuICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbGFyZ2UgdHJlZSB3aGljaCBpcyBjb21tb24gZm9yIGluaXRpYWwgbG9hZHMuIFdlXG4gICAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgICAvLyB0aGlzIG1hcmtlciwgYW5kIHRoaXMgaXMgdG9vIGxhdGUuXG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgcmVuZGVyIGFscmVhZHkgaGFkIGEgcGluZyBvciBsb3dlciBwcmkgdXBkYXRlcyxcbiAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhYmxlIHRvIGltbWVkaWF0ZWx5IHJlc3RhcnQgZnJvbSB3aXRoaW4gdGhyb3dFeGNlcHRpb24uXG4gICAgICAgICAgICAgIHZhciBoYXNJbnZpc2libGVDaGlsZENvbnRleHQgPSBjdXJyZW50ID09PSBudWxsICYmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlIHx8ICFlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrKTtcblxuICAgICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBpbiBhbiBpbnZpc2libGUgdHJlZSBvciBhIG5ldyByZW5kZXIsIHRoZW4gc2hvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG4gICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3YWtlYWJsZXMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuICAgICAgICAgIC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcHJlcGFyZVBvcnRhbE1vdW50KHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIH1cblxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgICAvLyBzZXF1ZW50aWFsIHRvIGVuc3VyZSB0aGlzIHN3aXRjaCBpcyBjb21waWxlZCB0byBhIGp1bXAgdGFibGUuXG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbmFibGVzLiBJbnN0ZWFkLCB3ZSdsbCB0cmFuc2ZlciBpdHMgdGhlbmFibGVzIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuc2VMaXN0IHNvIHRoYXQgaXQgY2FuIHJldHJ5IGlmIHRoZXkgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIG9mIHRoZXNlIGluIHRoZSBsaXN0IGJ1dCBzaW5jZSB3ZSdyZVxuICAgICAgICAgICAgICAgICAgLy8gZ29pbmcgdG8gd2FpdCBmb3IgYWxsIG9mIHRoZW0gYW55d2F5LCBpdCBkb2Vzbid0IHJlYWxseSBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG9uZXMgZ2V0cyB0byBwaW5nLiBJbiB0aGVvcnkgd2UgY291bGQgZ2V0IGNsZXZlciBhbmQga2VlcFxuICAgICAgICAgICAgICAgICAgLy8gdHJhY2sgb2YgaG93IG1hbnkgZGVwZW5kZW5jaWVzIHJlbWFpbiBidXQgaXQgZ2V0cyB0cmlja3kgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG1lYW50aW1lLCB3ZSBjYW4gYWRkL3JlbW92ZS9jaGFuZ2UgaXRlbXMgYW5kIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJhaWwgb3V0IG9mIHRoZSBsb29wIGJlZm9yZSBmaW5kaW5nIGFueSBidXQgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndCBtYXR0ZXIgc2luY2UgdGhhdCBtZWFucyB0aGF0IHRoZSBvdGhlciBib3VuZGFyaWVzIHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZCBmaW5kIGFscmVhZHkgaGFzIHRoZWlyIGxpc3RlbmVycyBhdHRhY2hlZC5cblxuICAgICAgICAgICAgICAgICAgdmFyIG5ld1RoZW5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1RoZW5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG5ld1RoZW5hYmxlcztcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgfSAvLyBSZXJlbmRlciB0aGUgd2hvbGUgbGlzdCwgYnV0IHRoaXMgdGltZSwgd2UnbGwgZm9yY2UgZmFsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAvLyB0byBzdGF5IGluIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjaGlsZCBmaWJlcnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGUuXG5cblxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICAgICAgICAgICAgICAgIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTsgLy8gU2V0IHVwIHRoZSBTdXNwZW5zZSBDb250ZXh0IHRvIGZvcmNlIHN1c3BlbnNlIGFuZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgLy8gcmVyZW5kZXIgdGhlIGNoaWxkcmVuLlxuXG4gICAgICAgICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7IC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsICYmIG5vdygpID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG4gICAgICAgICAgICAgIC8vIGxlZnQgaW4gdGhlIHRhaWwuIFdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyIGF0dGVtcHRzIHRvIHJlbmRlclxuICAgICAgICAgICAgICAvLyB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBnb2luZyB0byByZW5kZXIgdGhlIHRhaWwuXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJlbmRlcmVkIHJvdyB0byB0aGUgY2hpbGQgbGlzdC5cbiAgICAgICAgICBpZiAoIWRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICB2YXIgX3N1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZW5kZXJlZFRhaWwpO1xuXG4gICAgICAgICAgICBpZiAoX3N1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7IC8vIEVuc3VyZSB3ZSB0cmFuc2ZlciB0aGUgdXBkYXRlIHF1ZXVlIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgICAgICAgICAgIC8vIGdldCBsb3N0IGlmIHRoaXMgcm93IGVuZHMgdXAgZHJvcHBlZCBkdXJpbmcgYSBzZWNvbmQgcGFzcy5cblxuICAgICAgICAgICAgICB2YXIgX25ld1RoZW5hYmxlcyA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgaWYgKF9uZXdUaGVuYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9uZXdUaGVuYWJsZXM7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCB0cnVlKTsgLy8gVGhpcyBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQuXG5cbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgPT09IG51bGwgJiYgcmVuZGVyU3RhdGUudGFpbE1vZGUgPT09ICdoaWRkZW4nICYmICFyZW5kZXJlZFRhaWwuYWx0ZXJuYXRlICYmICFnZXRJc0h5ZHJhdGluZygpIC8vIFdlIGRvbid0IGN1dCBpdCBpZiB3ZSdyZSBoeWRyYXRpbmcuXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4gICAgICAgICAgICAvLyBleGNlZWQgaXQuXG4gICAgICAgICAgICBub3coKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4gICAgICAgICAgICAvLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJlbmRlcmVkVGFpbC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlbmRlclN0YXRlLmxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyU3RhdGUubGFzdCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbiAgICAgICAgICAvLyBQb3AgYSByb3cuXG4gICAgICAgICAgdmFyIG5leHQgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG5leHQ7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgICBuZXh0LnNpYmxpbmcgPSBudWxsOyAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LlxuICAgICAgICAgIC8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBqdXN0IGF2b2lkIHBvcHBpbmcgaXQgaW5zdGVhZCBhbmQgb25seVxuICAgICAgICAgIC8vIHNldHRpbmcgaXQgdGhlIGZpcnN0IHRpbWUgd2UgZ28gZnJvbSBub3Qgc3VzcGVuZGVkIHRvIHN1c3BlbmRlZC5cblxuICAgICAgICAgIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIERvIGEgcGFzcyBvdmVyIHRoZSBuZXh0IHJvdy5cbiAgICAgICAgICAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX25leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJldklzSGlkZGVuICE9PSBuZXh0SXNIaWRkZW4gJiYgKCAvLyBMZWdhY3lIaWRkZW4gZG9lc24ndCBkbyBhbnkgaGlkaW5nIOKAlCBpdCBvbmx5IHByZS1yZW5kZXJzLlxuICAgICAgICAgICFlbmFibGVMZWdhY3lIaWRkZW4gKSkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5leHRJc0hpZGRlbiB8fCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgZm9yIGhpZGRlbiBjaGlsZHJlbiB1bmxlc3Mgd2UncmUgcmVuZGVyaW5nXG4gICAgICAgICAgLy8gYXQgb2Zmc2NyZWVuIHByaW9yaXR5LlxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHN1YnRyZWVSZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlIGluIHRoZSBoaWRkZW4gc3VidHJlZS5cbiAgICAgICAgICAgICAgLy8gSWYgc28sIHdlIG5lZWQgdG8gaGlkZSB0aG9zZSBub2RlcyBpbiB0aGUgY29tbWl0IHBoYXNlLCBzb1xuICAgICAgICAgICAgICAvLyBzY2hlZHVsZSBhIHZpc2liaWxpdHkgZWZmZWN0LlxuICAgICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZmxhZ3MyID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKF9mbGFnczIgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MyICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlOyAvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTsgLy8gU3VzcGVuc2VMaXN0IGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggYW55dGhpbmcuIEl0IHNob3VsZCd2ZSBiZWVuXG4gICAgICAgIC8vIGNhdWdodCBieSBhIG5lc3RlZCBib3VuZGFyeS4gSWYgbm90LCBpdCBzaG91bGQgYnViYmxlIHRocm91Z2guXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblxuICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZS5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3QgPSBpbnRlcnJ1cHRlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcG9wUmVuZGVyTGFuZXMoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59IC8vIFVzZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHN0YWNrLlxuLy8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlU3VzcGVuc2VMYXlvdXRFZmZlY3RTZW1hbnRpY3MgaXMgZW5hYmxlZC5cblxuXG52YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gZmFsc2U7XG52YXIgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGZhbHNlO1xudmFyIFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcbnZhciBuZXh0RWZmZWN0ID0gbnVsbDsgLy8gVXNlZCBmb3IgUHJvZmlsaW5nIGJ1aWxkcyB0byB0cmFjayB1cGRhdGVycy5cblxudmFyIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG52YXIgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKSB7XG4gIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4gIC8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4gIC8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbiAgLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsIGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LCBpbnN0YW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnREaWRNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmV0VmFsO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzICYmIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIHJldFZhbCA9IHJlZihudWxsKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldFZhbCA9IHJlZihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0VmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpIHtcbiAgdHJ5IHtcbiAgICBkZXN0cm95KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuICB2YXIgc2hvdWxkRmlyZSA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG4gIHJldHVybiBzaG91bGRGaXJlO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBCZWZvcmVNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzICYmIGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAvLyBVbm1vdW50XG4gICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUoKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoKGVmZmVjdC50YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChlZmZlY3QudGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlRWZmZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSAnICsgaG9va05hbWUgKyAnKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiAnICsgJ0luc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgJyArICdhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG4nICsgaG9va05hbWUgKyAnKCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJyVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcgKyAnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLCBob29rTmFtZSwgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIHtcbiAgICAvLyBPbmx5IFByb2ZpbGVycyB3aXRoIHdvcmsgaW4gdGhlaXIgc3VidHJlZSB3aWxsIGhhdmUgYW4gVXBkYXRlIGVmZmVjdCBzY2hlZHVsZWQuXG4gICAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUG9zdENvbW1pdDsgLy8gVGhpcyB2YWx1ZSB3aWxsIHN0aWxsIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1pdCBwaGFzZS5cbiAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IGdldCByZXNldCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwaGFzZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblBvc3RDb21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0KGlkLCBwaGFzZSwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH0gLy8gQnViYmxlIHRpbWVzIHRvIHRoZSBuZXh0IG5lYXJlc3QgYW5jZXN0b3IgUHJvZmlsZXIuXG4gICAgICAgICAgICAvLyBBZnRlciB3ZSBwcm9jZXNzIHRoYXQgUHJvZmlsZXIsIHdlJ2xsIGJ1YmJsZSBmdXJ0aGVyIHVwLlxuXG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICByb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcblxuICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIGlmICgoZmluaXNoZWRXb3JrLmZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoICFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbiAgICAgICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cblxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uQ29tbWl0LFxuICAgICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICAgIHZhciBlZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwaGFzZSA9IGN1cnJlbnQgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Db21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNvbW1pdChmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgICAgfSAvLyBTY2hlZHVsZSBhIHBhc3NpdmUgZWZmZWN0IGZvciB0aGlzIFByb2ZpbGVyIHRvIGNhbGwgb25Qb3N0Q29tbWl0IGhvb2tzLlxuICAgICAgICAgICAgICAvLyBUaGlzIGVmZmVjdCBzaG91bGQgYmUgc2NoZWR1bGVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gb25Qb3N0Q29tbWl0IGNhbGxiYWNrIGZvciB0aGlzIFByb2ZpbGVyLFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBlZmZlY3QgaXMgYWxzbyB3aGVyZSB0aW1lcyBidWJibGUgdG8gcGFyZW50IFByb2ZpbGVycy5cblxuXG4gICAgICAgICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpbmlzaGVkV29yayk7IC8vIFByb3BhZ2F0ZSBsYXlvdXQgZWZmZWN0IGR1cmF0aW9ucyB0byB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yLlxuICAgICAgICAgICAgICAvLyBEbyBub3QgcmVzZXQgdGhlc2UgdmFsdWVzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBzbyBEZXZUb29scyBoYXMgYSBjaGFuY2UgdG8gcmVhZCB0aGVtIGZpcnN0LlxuXG4gICAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoICFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAge1xuICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFJlZikge1xuICAgICAgICBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlcihub2RlKSB7XG4gIC8vIFR1cm4gb24gbGF5b3V0IGVmZmVjdHMgaW4gYSB0cmVlIHRoYXQgcHJldmlvdXNseSBkaXNhcHBlYXJlZC5cbiAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcbiAgc3dpdGNoIChub2RlLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBub2RlLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQobm9kZSwgbm9kZS5yZXR1cm4sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlBdHRhY2hSZWYobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIC8vIE9ubHkgaGlkZSBvciB1bmhpZGUgdGhlIHRvcC1tb3N0IGhvc3Qgbm9kZXMuXG4gIHZhciBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbm9kZTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UzID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50KSAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZmluaXNoZWRXb3JrKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbm9kZSkge1xuICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJldFZhbDtcblxuICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIHJldFZhbCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJyArICdBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgKyAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4gIC8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuXG5cbiAge1xuICAgIC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gICAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gICAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAgIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG4gICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gICAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgICAvLyBvbmUsIHRvby5cblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuICAgIC8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3RcbiAgICAvLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuICAgIC8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG5cbiAgICB7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgICAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4gICAgICAvLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gVGhlc2UgYXJlIHRyYWNrZWQgb24gdGhlIHN0YWNrIGFzIHdlIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFcbi8vIGRlbGV0ZWQgc3VidHJlZS5cbi8vIFRPRE86IFVwZGF0ZSB0aGVzZSBkdXJpbmcgdGhlIHdob2xlIG11dGF0aW9uIHBoYXNlLCBub3QganVzdCBkdXJpbmdcbi8vIGEgZGVsZXRpb24uXG5cblxudmFyIGhvc3RQYXJlbnQgPSBudWxsO1xudmFyIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcikge1xuICB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQsIGRldGFjaCByZWZzLCBjbGVhblxuICAgIC8vIHVwIG1vdW50ZWQgbGF5b3V0IGVmZmVjdHMsIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIHRvcG1vc3QgaG9zdCBjaGlsZCBpbiBlYWNoIGJyYW5jaC4gQnV0IHRoZW4gd2VcbiAgICAvLyBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhdmVyc2luZyB0byB1bm1vdW50IGVmZmVjdHMsIHJlZnMsIGFuZCBjV1UuIFRPRE86IFdlXG4gICAgLy8gY291bGQgc3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSB0cmF2ZXJzYWxzIGZ1bmN0aW9ucywgd2hlcmUgdGhlIHNlY29uZFxuICAgIC8vIG9uZSBkb2Vzbid0IGluY2x1ZGUgYW55IHJlbW92ZUNoaWxkIGxvZ2ljLiBUaGlzIGlzIG1heWJlIHRoZSBzYW1lXG4gICAgLy8gZnVuY3Rpb24gYXMgXCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzXCIgKG9yIHdoYXRldmVyIHRoYXQgdHVybnMgaW50byBhZnRlclxuICAgIC8vIHRoZSBsYXlvdXQgcGhhc2UgaXMgcmVmYWN0b3JlZCB0byB1c2UgcmVjdXJzaW9uKS5cbiAgICAvLyBCZWZvcmUgc3RhcnRpbmcsIGZpbmQgdGhlIG5lYXJlc3QgaG9zdCBwYXJlbnQgb24gdGhlIHN0YWNrIHNvIHdlIGtub3dcbiAgICAvLyB3aGljaCBpbnN0YW5jZS9jb250YWluZXIgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICAgIC8vIFRPRE86IEluc3RlYWQgb2Ygc2VhcmNoaW5nIHVwIHRoZSBmaWJlciByZXR1cm4gcGF0aCBvbiBldmVyeSBkZWxldGlvbiwgd2VcbiAgICAvLyBjYW4gdHJhY2sgdGhlIG5lYXJlc3QgaG9zdCBjb21wb25lbnQgb24gdGhlIEpTIHN0YWNrIGFzIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHRyZWUgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgd291bGQgbWFrZSBpbnNlcnRpb25zIGZhc3RlciwgdG9vLlxuICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcblxuICAgIGZpbmRQYXJlbnQ6IHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaG9zdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICB9XG5cbiAgZGV0YWNoRmliZXJNdXRhdGlvbihkZWxldGVkRmliZXIpO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSB7XG4gIC8vIFRPRE86IFVzZSBhIHN0YXRpYyBmbGFnIHRvIHNraXAgdHJlZXMgdGhhdCBkb24ndCBoYXZlIHVubW91bnQgZWZmZWN0c1xuICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGNoaWxkKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcikge1xuICBvbkNvbW1pdFVubW91bnQoZGVsZXRlZEZpYmVyKTsgLy8gVGhlIGNhc2VzIGluIHRoaXMgb3V0ZXIgc3dpdGNoIG1vZGlmeSB0aGUgc3RhY2sgYmVmb3JlIHRoZXkgdHJhdmVyc2VcbiAgLy8gaW50byB0aGVpciBzdWJ0cmVlLiBUaGVyZSBhcmUgc2ltcGxlciBjYXNlcyBpbiB0aGUgaW5uZXIgc3dpdGNoXG4gIC8vIHRoYXQgZG9uJ3QgbW9kaWZ5IHRoZSBzdGFjay5cblxuICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoIHRvIG5leHQgYnJhbmNoXG5cbiAgICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIG5lYXJlc3QgaG9zdCBjaGlsZC4gU2V0IHRoZSBob3N0IHBhcmVudFxuICAgICAgICAvLyB0byBgbnVsbGAgb24gdGhlIHN0YWNrIHRvIGluZGljYXRlIHRoYXQgbmVzdGVkIGNoaWxkcmVuIGRvbid0XG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG5cbiAgICAgICAgICBpZiAoaG9zdFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTm93IHRoYXQgYWxsIHRoZSBjaGlsZCBlZmZlY3RzIGhhdmUgdW5tb3VudGVkLCB3ZSBjYW4gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZChob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBhbGwgb2YgaXRzIGNvbnRlbnQuXG5cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBkZWxldGVkRmliZXIudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBfZWZmZWN0ID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdC5kZXN0cm95LFxuICAgICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0LnRhZztcblxuICAgICAgICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWxldGVkRmliZXIubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcbiAgICAgICAgIGRlbGV0ZWRGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIG9mZnNjcmVlbiBjb21wb25lbnQgaXMgaGlkZGVuLCB3ZSBhbHJlYWR5IHVubW91bnRlZCBpdC4gQmVmb3JlXG4gICAgICAgICAgLy8gZGVsZXRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayB0aGF0IGl0J3MgYWxyZWFkeSB1bm1vdW50ZWQgc28gdGhhdCB3ZVxuICAgICAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gdW5tb3VudCB0aGUgZWZmZWN0cyBhZ2Fpbi5cbiAgICAgICAgICAvLyBUT0RPOiBJZiB0aGUgdHJlZSBpcyBoaWRkZW4sIGluIG1vc3QgY2FzZXMgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc2tpcFxuICAgICAgICAgIC8vIG92ZXIgdGhlIG5lc3RlZCBjaGlsZHJlbiBlbnRpcmVseS4gQW4gZXhjZXB0aW9uIGlzIHdlIGhhdmVuJ3QgeWV0IGZvdW5kXG4gICAgICAgICAgLy8gdGhlIHRvcG1vc3QgaG9zdCBub2RlIHRvIGRlbGV0ZSwgd2hpY2ggd2UgYWxyZWFkeSB0cmFjayBvbiB0aGUgc3RhY2suXG4gICAgICAgICAgLy8gQnV0IHRoZSBvdGhlciBjYXNlIGlzIHBvcnRhbHMsIHdoaWNoIG5lZWQgdG8gYmUgZGV0YWNoZWQgbm8gbWF0dGVyIGhvd1xuICAgICAgICAgIC8vIGRlZXBseSB0aGV5IGFyZSBuZXN0ZWQuIFdlIHNob3VsZCB1c2UgYSBzdWJ0cmVlIGZsYWcgdG8gdHJhY2sgd2hldGhlciBhXG4gICAgICAgICAgLy8gc3VidHJlZSBpbmNsdWRlcyBhIG5lc3RlZCBwb3J0YWwuXG4gICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgdGhlbiBpdCB3aWxsIGhhdmUgYSBzZXQgb2Ygd2FrZWFibGVzLlxuICAvLyBGb3IgZWFjaCB3YWtlYWJsZSwgYXR0YWNoIGEgbGlzdGVuZXIgc28gdGhhdCB3aGVuIGl0IHJlc29sdmVzLCBSZWFjdFxuICAvLyBhdHRlbXB0cyB0byByZS1yZW5kZXIgdGhlIGJvdW5kYXJ5IGluIHRoZSBwcmltYXJ5IChwcmUtdGltZW91dCkgc3RhdGUuXG4gIHZhciB3YWtlYWJsZXMgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgaWYgKHdha2VhYmxlcyAhPT0gbnVsbCkge1xuICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgaWYgKHJldHJ5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpO1xuICAgIH1cblxuICAgIHdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWtlYWJsZSkge1xuICAgICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgYm91bmRhcnkgZmliZXIgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcblxuICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGlmIChpblByb2dyZXNzTGFuZXMgIT09IG51bGwgJiYgaW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIGFzc29jaWF0ZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnMgd2l0aCBpdC5cbiAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgZ29lcyBmcm9tIHZpc2libGUgdG8gaGlkZGVuLlxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgc2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KTtcbiAgc2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgbGFuZXMpIHtcbiAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGFlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNoaWxkKTtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoY2hpbGQsIHJvb3QpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnRGaWJlcihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcykge1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFnczsgLy8gVGhlIGVmZmVjdCBmbGFnIHNob3VsZCBiZSBjaGVja2VkICphZnRlciogd2UgcmVmaW5lIHRoZSB0eXBlIG9mIGZpYmVyLFxuICAvLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcbiAgLy8gdG8gcmVjb25jaWxhdGlvbiwgYmVjYXVzZSB0aG9zZSBjYW4gYmUgc2V0IG9uIGFsbCBmaWJlciB0eXBlcy5cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH0gLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgICAgLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG5cblxuICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogQ29udGVudFJlc2V0IGdldHMgY2xlYXJlZCBieSB0aGUgY2hpbGRyZW4gZHVyaW5nIHRoZSBjb21taXRcbiAgICAgICAgICAvLyBwaGFzZS4gVGhpcyBpcyBhIHJlZmFjdG9yIGhhemFyZCBiZWNhdXNlIGl0IG1lYW5zIHdlIG11c3QgcmVhZFxuICAgICAgICAgIC8vIGZsYWdzIHRoZSBmbGFncyBhZnRlciBgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzYCBoYXMgYWxyZWFkeSBydW47XG4gICAgICAgICAgLy8gdGhlIG9yZGVyIG1hdHRlcnMuIFdlIHNob3VsZCByZWZhY3RvciBzbyB0aGF0IENvbnRlbnRSZXNldCBkb2VzIG5vdFxuICAgICAgICAgIC8vIHJlbHkgb24gbXV0YXRpbmcgdGhlIGZsYWcgZHVyaW5nIGNvbW1pdC4gTGlrZSBieSBzZXR0aW5nIGEgZmxhZ1xuICAgICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIGluc3RlYWQuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzZXRUZXh0Q29udGVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2U0ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZTQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRVcGRhdGUoX2luc3RhbmNlNCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2Um9vdFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2Um9vdFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5mbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuSW5zdGFuY2UgPSBvZmZzY3JlZW5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1N0YXRlID0gb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDsgLy8gVHJhY2sgdGhlIGN1cnJlbnQgc3RhdGUgb24gdGhlIE9mZnNjcmVlbiBpbnN0YW5jZSBzbyB3ZSBjYW5cbiAgICAgICAgICAvLyByZWFkIGl0IGR1cmluZyBhbiBldmVudFxuXG4gICAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuaXNIaWRkZW4gPSBpc0hpZGRlbjtcblxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgdmFyIHdhc0hpZGRlbiA9IG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCF3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3dhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmICggLy8gVE9ETzogUmVtb3ZlIHRoaXMgZGVhZCBmbGFnXG4gICAgICAgICBmaW5pc2hlZFdvcmsubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICAgICAgLy8gQmVmb3JlIGNvbW1pdHRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayBvbiB0aGUgc3RhY2sgd2hldGhlciB0aGlzXG4gICAgICAgICAgLy8gb2Zmc2NyZWVuIHN1YnRyZWUgd2FzIGFscmVhZHkgaGlkZGVuLCBzbyB0aGF0IHdlIGRvbid0IHVubW91bnQgdGhlXG4gICAgICAgICAgLy8gZWZmZWN0cyBhZ2Fpbi5cbiAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCBfd2FzSGlkZGVuO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVmlzaWJpbGl0eSkge1xuICAgICAgICAgIHZhciBfb2Zmc2NyZWVuSW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBfbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgIHZhciBfaXNIaWRkZW4gPSBfbmV3U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuQm91bmRhcnkgPSBmaW5pc2hlZFdvcms7IC8vIFRyYWNrIHRoZSBjdXJyZW50IHN0YXRlIG9uIHRoZSBPZmZzY3JlZW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4gICAgICAgICAgLy8gcmVhZCBpdCBkdXJpbmcgYW4gZXZlbnRcblxuICAgICAgICAgIF9vZmZzY3JlZW5JbnN0YW5jZS5pc0hpZGRlbiA9IF9pc0hpZGRlbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChfaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgaWYgKCFfd2FzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvZmZzY3JlZW5Cb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBvZmZzY3JlZW5Cb3VuZGFyeTtcbiAgICAgICAgICAgICAgICAgIHZhciBvZmZzY3JlZW5DaGlsZCA9IG9mZnNjcmVlbkJvdW5kYXJ5LmNoaWxkO1xuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2NyZWVuQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG9mZnNjcmVlbkNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKG9mZnNjcmVlbkNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5DaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuICAgICAgICAgICAgLy8gaW5zaWRlIGEgaGlkZGVuIE9mZnNjcmVlbiB0cmVlLlxuICAgICAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ob2Zmc2NyZWVuQm91bmRhcnksIF9pc0hpZGRlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAvLyBQbGFjZW1lbnQgZWZmZWN0cyAoaW5zZXJ0aW9ucywgcmVvcmRlcnMpIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyXG4gIC8vIHR5cGUuIFRoZXkgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQsIGJ1dFxuICAvLyBiZWZvcmUgdGhlIGVmZmVjdHMgb24gdGhpcyBmaWJlciBoYXZlIGZpcmVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuXG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBIeWRyYXRpbmcpIHtcbiAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG4gIHZhciBpc01vZGVyblJvb3QgPSAoc3VidHJlZVJvb3QubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKCBmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBpc01vZGVyblJvb3QpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuICAgICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cblxuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbiAgICAgICAgICAvLyBiYWNrIG9uLlxuICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwgLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG4gICAgICAgICAgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBjdXJyZW50LCBmaWJlciwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIGZpYmVyLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChmaWJlciwgZmliZXIucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhXG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgLy8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIGFscmVhZHkgaGlkZGVuLiBEb24ndCBkaXNhcHBlYXJcbiAgICAgICAgICAgIC8vIGl0cyBlZmZlY3RzLlxuICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogc3VidHJlZUZsYWdzICYgTGF5b3V0U3RhdGljXG5cblxuICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgLy8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIHN0aWxsIGhpZGRlbi4gRG9uJ3QgcmUtYXBwZWFyIGl0cyBlZmZlY3RzLlxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cbiAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBub2RlIG1heSBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIsIHNvIHdlIGNhbid0XG4gICAgICAvLyBhc3N1bWUgaXRzIHJldHVybiBwb2ludGVyIGlzIGNvcnJlY3QuXG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG5cbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIoZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIG5vZGUgbWF5IGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlciwgc28gd2UgY2FuJ3RcbiAgICAgIC8vIGFzc3VtZSBpdHMgcmV0dXJuIHBvaW50ZXIgaXMgY29ycmVjdC5cbiAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyAmJiBmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmlyc3RDaGlsZCkge1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luKCk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBmaWJlci5kZWxldGlvbnM7XG5cbiAgICAgIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmliZXJUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXJUb0RlbGV0ZTtcbiAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGZpYmVyVG9EZWxldGUsIGZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBBIGZpYmVyIHdhcyBkZWxldGVkIGZyb20gdGhpcyBwYXJlbnQgZmliZXIsIGJ1dCBpdCdzIHN0aWxsIHBhcnQgb2ZcbiAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgKGFsdGVybmF0ZSkgcGFyZW50IGZpYmVyJ3MgbGlzdCBvZiBjaGlsZHJlbi4gQmVjYXVzZVxuICAgICAgICAgIC8vIGNoaWxkcmVuIGFyZSBhIGxpbmtlZCBsaXN0LCBhbiBlYXJsaWVyIHNpYmxpbmcgdGhhdCdzIHN0aWxsIGFsaXZlXG4gICAgICAgICAgLy8gd2lsbCBiZSBjb25uZWN0ZWQgdG8gdGhlIGRlbGV0ZWQgZmliZXIgdmlhIGl0cyBgYWx0ZXJuYXRlYDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgbGl2ZSBmaWJlclxuICAgICAgICAgIC8vICAgLS1hbHRlcm5hdGUtLT4gcHJldmlvdXMgbGl2ZSBmaWJlclxuICAgICAgICAgIC8vICAgLS1zaWJsaW5nLS0+IGRlbGV0ZWQgZmliZXJcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGNhbid0IGRpc2Nvbm5lY3QgYGFsdGVybmF0ZWAgb24gbm9kZXMgdGhhdCBoYXZlbid0IGJlZW4gZGVsZXRlZFxuICAgICAgICAgIC8vIHlldCwgYnV0IHdlIGNhbiBkaXNjb25uZWN0IHRoZSBgc2libGluZ2AgYW5kIGBjaGlsZGAgcG9pbnRlcnMuXG4gICAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRldGFjaGVkQ2hpbGQgPSBwcmV2aW91c0ZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGRldGFjaGVkU2libGluZyA9IGRldGFjaGVkQ2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICBkZXRhY2hlZENoaWxkLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRldGFjaGVkQ2hpbGQgPSBkZXRhY2hlZFNpYmxpbmc7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihkZWxldGVkU3VidHJlZVJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBEZWxldGlvbiBlZmZlY3RzIGZpcmUgaW4gcGFyZW50IC0+IGNoaWxkIG9yZGVyXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZmliZXIgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyAvLyBUT0RPOiBPbmx5IHRyYXZlcnNlIHN1YnRyZWUgaWYgaXQgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnLiAoQnV0LCBpZiB3ZVxuICAgIC8vIGRvIHRoaXMsIHN0aWxsIG5lZWQgdG8gaGFuZGxlIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgY29ycmVjdGx5LilcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB7XG4gICAgICAvLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGUgZW50aXJlIGRlbGV0ZWQgdHJlZSBhbmQgY2xlYW4gdXAgZmliZXIgZmllbGRzLlxuICAgICAgLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpZGVhbCwgYW5kIHRoZSBsb25nIHRlcm0gZ29hbCBpcyB0byBvbmx5XG4gICAgICAvLyBoYXZlIHRvIGRldGFjaCB0aGUgZGVsZXRlZCB0cmVlIGF0IHRoZSByb290LlxuICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpO1xuXG4gICAgICBpZiAoZmliZXIgPT09IGRlbGV0ZWRTdWJ0cmVlUm9vdCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn0gLy8gVE9ETzogUmV1c2UgcmVhcHBlYXJMYXlvdXRFZmZlY3RzIHRyYXZlcnNhbCBoZXJlP1xuXG5cbmZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaWJlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdFVubW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGZpYmVyLCBmaWJlci5yZXR1cm4sIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxudmFyIGNvbW1pdEhvb2tzID0gW107XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QkMSgpIHtcbiAge1xuICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG5mdW5jdGlvbiBpc0xlZ2FjeUFjdEVudmlyb25tZW50KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBMZWdhY3kgbW9kZS4gV2UgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mIFJlYWN0IDE3J3MgYWN0LiBJdCBhc3N1bWVzIGFuXG4gICAgLy8gYWN0IGVudmlyb25tZW50IHdoZW5ldmVyIGBqZXN0YCBpcyBkZWZpbmVkLCBidXQgeW91IGNhbiBzdGlsbCB0dXJuIG9mZlxuICAgIC8vIHNwdXJpb3VzIHdhcm5pbmdzIGJ5IHNldHRpbmcgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGV4cGxpY2l0bHlcbiAgICAvLyB0byBmYWxzZS5cbiAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID0gLy8gJEZsb3dFeHBlY3RlZEVycm9yIOKAkyBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZ2xvYmFsXG4gICAgdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgOiB1bmRlZmluZWQ7IC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IGplc3RcblxuICAgIHZhciBqZXN0SXNEZWZpbmVkID0gdHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnO1xuICAgIHJldHVybiAgamVzdElzRGVmaW5lZCAmJiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgIT09IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSA1MDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG52YXIgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3coKSArIFJFTkRFUl9USU1FT1VUX01TO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTtcbn1cbnZhciBoYXNVbmNhdWdodEVycm9yID0gZmFsc2U7XG52YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbnZhciBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7IC8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlU2NoZWR1bGVkSG9vayBpcyB0cnVlO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xudmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG52YXIgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7IC8vIElmIHR3byB1cGRhdGVzIGFyZSBzY2hlZHVsZWQgd2l0aGluIHRoZSBzYW1lIGV2ZW50LCB3ZSBzaG91bGQgdHJlYXQgdGhlaXJcbi8vIGV2ZW50IHRpbWVzIGFzIHNpbXVsdGFuZW91cywgZXZlbiBpZiB0aGUgYWN0dWFsIGNsb2NrIHRpbWUgaGFzIGFkdmFuY2VkXG4vLyBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG5cbnZhciBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG52YXIgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmVzO1xudmFyIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICggKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaXNUcmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkgIT09IE5vVHJhbnNpdGlvbjtcblxuICBpZiAoaXNUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gICAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAgIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gICAgLy9cbiAgICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbiAgLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuICAvL1xuICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbiAgLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG4gIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSkge1xuICAgIHJldHVybiB1cGRhdGVMYW5lO1xuICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuICAvLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gIC8vXG4gIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxuXG5cbiAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG4gIHJldHVybiBldmVudExhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfVxuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG5cbiAge1xuICAgIGlmIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QpIHtcbiAgICAgIGVycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgfVxuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0xhbmVzICYmIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFRoaXMgdXBkYXRlIHdhcyBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzIGlzIGEgbWlzdGFrZVxuICAgIC8vIGlmIHRoZSB1cGRhdGUgb3JpZ2luYXRlcyBmcm9tIHVzZXIgc3BhY2UgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBsb2NhbFxuICAgIC8vIGhvb2sgdXBkYXRlcywgd2hpY2ggYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IHJlYWNoIHRoaXNcbiAgICAvLyBmdW5jdGlvbiksIGJ1dCB0aGVyZSBhcmUgc29tZSBpbnRlcm5hbCBSZWFjdCBmZWF0dXJlcyB0aGF0IHVzZSB0aGlzIGFzXG4gICAgLy8gYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBsaWtlIHNlbGVjdGl2ZSBoeWRyYXRpb24uXG4gICAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpOyAvLyBUcmFjayBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBub3JtYWwgdXBkYXRlLCBzY2hlZHVsZWQgZnJvbSBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuIEZvclxuICAgIC8vIGV4YW1wbGUsIGR1cmluZyBhbiBpbnB1dCBldmVudC5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpO1xuXG4gICAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAgIC8vIHBoYXNlIHVwZGF0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBkb24ndCB0cmVhdCByZW5kZXIgcGhhc2UgdXBkYXRlcyBhcyBpZlxuICAgICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgICAgaWYgKCAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG59XG5mdW5jdGlvbiBpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIE9ubHkgY2FsbGVkIGJ5IGNsYXNzIGNvbXBvbmVudHMsXG4gIC8vIHdoaWNoIHNwZWNpYWwgKGRlcHJlY2F0ZWQpIGJlaGF2aW9yIGZvciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmUgcHJvcHMuXG4gIHJldHVybiAoLy8gVE9ETzogUmVtb3ZlIG91dGRhdGVkIGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaCBleHBlcmltZW50LiBXZVxuICAgIC8vIGRlY2lkZWQgbm90IHRvIGVuYWJsZSBpdC5cbiAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0XG4gICk7XG59IC8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5cbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBjdXJyZW50VGltZSkge1xuICB2YXIgZXhpc3RpbmdDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTsgLy8gQ2hlY2sgaWYgYW55IGxhbmVzIGFyZSBiZWluZyBzdGFydmVkIGJ5IG90aGVyIHdvcmsuIElmIHNvLCBtYXJrIHRoZW0gYXNcbiAgLy8gZXhwaXJlZCBzbyB3ZSBrbm93IHRvIHdvcmsgb24gdGhvc2UgbmV4dC5cblxuICBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKTsgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIGFuZCB0aGVpciBwcmlvcml0eS5cblxuICB2YXIgbmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG5cbiAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayQxKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgICB9XG5cbiAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSB1c2UgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgbGFuZSB0byByZXByZXNlbnQgdGhlIHByaW9yaXR5IG9mIHRoZSBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja1ByaW9yaXR5ID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShuZXh0TGFuZXMpOyAvLyBDaGVjayBpZiB0aGVyZSdzIGFuIGV4aXN0aW5nIHRhc2suIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIGl0LlxuXG4gIHZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPSByb290LmNhbGxiYWNrUHJpb3JpdHk7XG5cbiAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9PT0gbmV3Q2FsbGJhY2tQcmlvcml0eSAmJiAvLyBTcGVjaWFsIGNhc2UgcmVsYXRlZCB0byBgYWN0YC4gSWYgdGhlIGN1cnJlbnRseSBzY2hlZHVsZWQgdGFzayBpcyBhXG4gIC8vIFNjaGVkdWxlciB0YXNrLCByYXRoZXIgdGhhbiBhbiBgYWN0YCB0YXNrLCBjYW5jZWwgaXQgYW5kIHJlLXNjaGVkdWxlZFxuICAvLyBvbiB0aGUgYGFjdGAgcXVldWUuXG4gICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCAhPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSkpIHtcbiAgICB7XG4gICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byByZS11c2UgYW4gZXhpc3RpbmcgdGFzaywgaXQgbmVlZHMgdG8gZXhpc3QuXG4gICAgICAvLyBBc3N1bWUgdGhhdCBkaXNjcmV0ZSB1cGRhdGUgbWljcm90YXNrcyBhcmUgbm9uLWNhbmNlbGxhYmxlIGFuZCBudWxsLlxuICAgICAgLy8gVE9ETzogVGVtcG9yYXJ5IHVudGlsIHdlIGNvbmZpcm0gdGhpcyB3YXJuaW5nIGlzIG5vdCBmaXJlZC5cbiAgICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSA9PSBudWxsICYmIGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSAhPT0gU3luY0xhbmUpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHNjaGVkdWxlZCBjYWxsYmFjayB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoZSBwcmlvcml0eSBoYXNuJ3QgY2hhbmdlZC4gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyB0YXNrLiBFeGl0LlxuXG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT0gbnVsbCkge1xuICAgIC8vIENhbmNlbCB0aGUgZXhpc3RpbmcgY2FsbGJhY2suIFdlJ2xsIHNjaGVkdWxlIGEgbmV3IG9uZSBiZWxvdy5cbiAgICBjYW5jZWxDYWxsYmFjayQxKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja05vZGU7XG5cbiAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IFN5bmNMYW5lKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBTeW5jIFJlYWN0IGNhbGxiYWNrcyBhcmUgc2NoZWR1bGVkIG9uIGEgc3BlY2lhbFxuICAgIC8vIGludGVybmFsIHF1ZXVlXG4gICAgaWYgKHJvb3QudGFnID09PSBMZWdhY3lSb290KSB7XG4gICAgICBpZiAoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSAhPT0gbnVsbCkge1xuICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gRmx1c2ggdGhlIHF1ZXVlIGluIGEgbWljcm90YXNrLlxuICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSW5zaWRlIGBhY3RgLCB1c2Ugb3VyIGludGVybmFsIGBhY3RgIHF1ZXVlIHNvIHRoYXQgdGhlc2UgZ2V0IGZsdXNoZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY29wZSBldmVuIHdoZW4gdXNpbmcgdGhlIHN5bmMgdmVyc2lvblxuICAgICAgICAvLyBvZiBgYWN0YC5cbiAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50LnB1c2goZmx1c2hTeW5jQ2FsbGJhY2tzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJbiBTYWZhcmksIGFwcGVuZGluZyBhbiBpZnJhbWUgZm9yY2VzIG1pY3JvdGFza3MgdG8gcnVuLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjI0NTlcbiAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJ1bm5pbmcgY2FsbGJhY2tzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyXG4gICAgICAgICAgLy8gb3IgY29tbWl0IHNvIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdCB0aGF0LlxuICAgICAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHN0aWxsIHByZW1hdHVyZWx5IGZsdXNoIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaGFwcGVucyBvdXRzaWRlIHJlbmRlciBvciBjb21taXQgcGhhc2UgKGUuZy4gaW4gYW4gZXZlbnQpLlxuICAgICAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdDYWxsYmFja05vZGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eUxldmVsO1xuXG4gICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShuZXh0TGFuZXMpKSB7XG4gICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayQxKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwsIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfVxuXG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbmV3Q2FsbGJhY2tOb2RlO1xufSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgZXZlcnkgY29uY3VycmVudCB0YXNrLCBpLmUuIGFueXRoaW5nIHRoYXRcbi8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5cblxuZnVuY3Rpb24gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAge1xuICAgIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpO1xuICB9IC8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4gIC8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbiAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmVzO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCB1c2luZyB0aGUgZmllbGRzIHN0b3JlZFxuICAvLyBvbiB0aGUgcm9vdC5cblxuXG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdlIGRpc2FibGUgdGltZS1zbGljaW5nIGluIHNvbWUgY2FzZXM6IGlmIHRoZSB3b3JrIGhhcyBiZWVuIENQVS1ib3VuZFxuICAvLyBmb3IgdG9vIGxvbmcgKFwiZXhwaXJlZFwiIHdvcmssIHRvIHByZXZlbnQgc3RhcnZhdGlvbiksIG9yIHdlJ3JlIGluXG4gIC8vIHN5bmMtdXBkYXRlcy1ieS1kZWZhdWx0IG1vZGUuXG4gIC8vIFRPRE86IFdlIG9ubHkgY2hlY2sgYGRpZFRpbWVvdXRgIGRlZmVuc2l2ZWx5LCB0byBhY2NvdW50IGZvciBhIFNjaGVkdWxlclxuICAvLyBidWcgd2UncmUgc3RpbGwgaW52ZXN0aWdhdGluZy4gT25jZSB0aGUgYnVnIGluIFNjaGVkdWxlciBpcyBmaXhlZCxcbiAgLy8gd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSB0cmFjayBleHBpcmF0aW9uIG91cnNlbHZlcy5cblxuXG4gIHZhciBzaG91bGRUaW1lU2xpY2UgPSAhaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpICYmICFpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsIGxhbmVzKSAmJiAoICFkaWRUaW1lb3V0KTtcbiAgdmFyIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2UgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykgOiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGxcbiAgICAgIC8vIHJlbmRlciBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbFxuICAgICAgLy8gaW5jbHVkZXMgYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyXG4gICAgICAvLyB0aGUgc2Vjb25kIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG5vdCBhIGRpc2NyZXRlIG9yXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUuIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgY2hlY2tlZCBmb3IgdGhpcyB3aGVuIHdlXG4gICAgICAvLyB1bndvdW5kIHRoZSBzdGFjay5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4gICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuICAgICAgLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4gICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAocmVuZGVyV2FzQ29uY3VycmVudCAmJiAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTsgLy8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBzb21ldGhpbmcgdGhyZXdcblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2Vycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICAgICAgaWYgKF9lcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGxhbmVzID0gX2Vycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBfZXJyb3JSZXRyeUxhbmVzKTsgLy8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuICAgICAgICAgICAgLy8gY29uY3VycmVudCBldmVudHMuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2ZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gICAgICAgICAgdGhyb3cgX2ZhdGFsRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIFRoZSBuZXh0IHN0ZXAgaXMgZWl0aGVyIHRvIGNvbW1pdCBpdCxcbiAgICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cbiAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgIC8vIFRoZSB0YXNrIG5vZGUgc2NoZWR1bGVkIGZvciB0aGlzIHJvb3QgaXMgdGhlIHNhbWUgb25lIHRoYXQnc1xuICAgIC8vIGN1cnJlbnRseSBleGVjdXRlZC4gTmVlZCB0byByZXR1cm4gYSBjb250aW51YXRpb24uXG4gICAgcmV0dXJuIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcykge1xuICAvLyBJZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaHlkcmF0aW9uLCBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbFxuICAvLyBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cbiAgLy8gQmVmb3JlIHJlbmRlcmluZyBhZ2Fpbiwgc2F2ZSB0aGUgZXJyb3JzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG4gIHZhciBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycztcblxuICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgIC8vIFRoZSBzaGVsbCBmYWlsZWQgdG8gaHlkcmF0ZS4gU2V0IGEgZmxhZyB0byBmb3JjZSBhIGNsaWVudCByZW5kZXJpbmdcbiAgICAvLyBkdXJpbmcgdGhlIG5leHQgYXR0ZW1wdC4gVG8gZG8gdGhpcywgd2UgY2FsbCBwcmVwYXJlRnJlc2hTdGFjayBub3dcbiAgICAvLyB0byBjcmVhdGUgdGhlIHJvb3Qgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBpbiB0ZXJtc1xuICAgIC8vIG9mIGZhY3RvcmluZywgYmVjYXVzZSBpdCByZWxpZXMgb24gcmVuZGVyUm9vdFN5bmMgbm90IGNhbGxpbmdcbiAgICAvLyBwcmVwYXJlRnJlc2hTdGFjayBhZ2FpbiBpbiB0aGUgY2FsbCBiZWxvdywgd2hpY2ggaGFwcGVucyBiZWNhdXNlIHRoZVxuICAgIC8vIHJvb3QgYW5kIGxhbmVzIGhhdmVuJ3QgY2hhbmdlZC5cbiAgICAvL1xuICAgIC8vIFRPRE86IEkgdGhpbmsgd2hhdCB3ZSBzaG91bGQgZG8gaXMgc2V0IEZvcmNlQ2xpZW50UmVuZGVyIGluc2lkZVxuICAgIC8vIHRocm93RXhjZXB0aW9uLCBsaWtlIHdlIGRvIGZvciBuZXN0ZWQgU3VzcGVuc2UgYm91bmRhcmllcy4gVGhlIHJlYXNvblxuICAgIC8vIGl0J3MgaGVyZSBpbnN0ZWFkIGlzIHNvIHdlIGNhbiBzd2l0Y2ggdG8gdGhlIHN5bmNocm9ub3VzIHdvcmsgbG9vcCwgdG9vLlxuICAgIC8vIFNvbWV0aGluZyB0byBjb25zaWRlciBmb3IgYSBmdXR1cmUgcmVmYWN0b3IuXG4gICAgdmFyIHJvb3RXb3JrSW5Qcm9ncmVzcyA9IHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgcm9vdFdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuXG4gICAge1xuICAgICAgZXJyb3JIeWRyYXRpbmdDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGZpbmlzaGVkIHJlbmRlcmluZyBvbiByZXRyeVxuICAgIC8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgZmFpbGVkIGZpcnN0IGF0dGVtcHQgaGF2ZSBiZWVuIHJlY292ZXJlZC4gQWRkXG4gICAgLy8gdGhlbSB0byB0aGUgY29sbGVjdGlvbiBvZiByZWNvdmVyYWJsZSBlcnJvcnMuIFdlJ2xsIGxvZyB0aGVtIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZS5cbiAgICB2YXIgZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yc0Zyb21GaXJzdEF0dGVtcHQ7IC8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgc2Vjb25kIGF0dGVtcHQgc2hvdWxkIGJlIHF1ZXVlZCBhZnRlciB0aGUgZXJyb3JzXG4gICAgLy8gZnJvbSB0aGUgZmlyc3QgYXR0ZW1wdCwgdG8gcHJlc2VydmUgdGhlIGNhdXNhbCBzZXF1ZW5jZS5cblxuICAgIGlmIChlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCAhPT0gbnVsbCkge1xuICAgICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4aXRTdGF0dXM7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgLy8gRmxvdyBrbm93cyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWlucyBpZiBJIGFkZCBhIGJyZWFrXG4gICAgLy8gc3RhdGVtZW50LCBidXQgZXNsaW50IGRvZXNuJ3Qga25vdyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWluc1xuICAgIC8vIGlmIEkgZG8uIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmV0cnkgdGhpcyB0cmVlLiBJZiB3ZSByZWFjaGVkXG4gICAgICAgIC8vIHRoaXMgcG9pbnQsIGl0IGVycm9yZWQgYWdhaW4uIENvbW1pdCBpdC5cbiAgICAgICAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTsgLy8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiAgICAgICAgIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93KCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyksIG1zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdygpIC0gZXZlbnRUaW1lTXM7XG5cbiAgICAgICAgICB2YXIgX21zVW50aWxUaW1lb3V0ID0gam5kKHRpbWVFbGFwc2VkTXMpIC0gdGltZUVsYXBzZWRNczsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cblxuICAgICAgICAgIGlmIChfbXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFjayBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICAvLyB0byBhcnJpdmUuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKSwgX21zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290Q29tcGxldGVkOlxuICAgICAge1xuICAgICAgICAvLyBUaGUgd29yayBjb21wbGV0ZWQuIFJlYWR5IHRvIGNvbW1pdC5cbiAgICAgICAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAvLyBTZWFyY2ggdGhlIHJlbmRlcmVkIHRyZWUgZm9yIGV4dGVybmFsIHN0b3JlIHJlYWRzLCBhbmQgY2hlY2sgd2hldGhlciB0aGVcbiAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZCBpbiBhIGNvbmN1cnJlbnQgZXZlbnQuIEludGVudGlvbmFsbHkgdXNpbmcgYW4gaXRlcmF0aXZlXG4gIC8vIGxvb3AgaW5zdGVhZCBvZiByZWN1cnNpb24gc28gd2UgY2FuIGV4aXQgZWFybHkuXG4gIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUuZmxhZ3MgJiBTdG9yZUNvbnNpc3RlbmN5KSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBub2RlLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IHVwZGF0ZVF1ZXVlLnN0b3JlcztcblxuICAgICAgICBpZiAoY2hlY2tzICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IGNoZWNrc1tpXTtcbiAgICAgICAgICAgIHZhciBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkVmFsdWUgPSBjaGVjay52YWx1ZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCByZW5kZXJlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGluY29uc2lzdGVudCBzdG9yZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIElmIGBnZXRTbmFwc2hvdGAgdGhyb3dzLCByZXR1cm4gYGZhbHNlYC4gVGhpcyB3aWxsIHNjaGVkdWxlXG4gICAgICAgICAgICAgIC8vIGEgcmUtcmVuZGVyLCBhbmQgdGhlIGVycm9yIHdpbGwgYmUgcmV0aHJvd24gZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiBTdG9yZUNvbnNpc3RlbmN5ICYmIGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIHVucmVhY2hhYmxlLCBidXQgZXNsaW50IGRvZXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBzdXNwZW5kZWRMYW5lcykge1xuICAvLyBXaGVuIHN1c3BlbmRpbmcsIHdlIHNob3VsZCBhbHdheXMgZXhjbHVkZSBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIG9yIChtb3JlXG4gIC8vIHJhcmVseSwgc2luY2Ugd2UgdHJ5IHRvIGF2b2lkIGl0KSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAvLyBUT0RPOiBMb2wgbWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gZmFjdG9yIHRoaXMgYmVzaWRlcyB0aGlzXG4gIC8vIG9ibm94aW91c2x5IG5hbWVkIGZ1bmN0aW9uIDopXG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzKTtcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcyk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KSB7XG4gIHtcbiAgICBzeW5jTmVzdGVkVXBkYXRlRmxhZygpO1xuICB9XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH1cblxuICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUobGFuZXMsIFN5bmNMYW5lKSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gcmVtYWluaW5nIHN5bmMgd29yayBsZWZ0LlxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICBpZiAocm9vdC50YWcgIT09IExlZ2FjeVJvb3QgJiYgZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgaWYgKGVycm9yUmV0cnlMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgaWYgKGxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbWVyZ2VMYW5lcyhsYW5lcywgU3luY0xhbmUpKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcbiAgICAvLyBtb3N0IGJhdGNoZWRVcGRhdGVzLWxpa2UgbWV0aG9kLlxuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZyA9PT0gTGVnYWN5Um9vdCAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgIC8vIHRoZSBzdGFjay5cblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgd3JvbmcgY29udGV4dC5cbiAgcmV0dXJuICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG4gIHB1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBzdWJ0cmVlUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGludGVycnVwdGVkV29yay5hbHRlcm5hdGU7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgdmFyIHJvb3RXb3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzID0gcm9vdFdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IHN1YnRyZWVSZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3RXb3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgZG8ge1xuICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlc2V0IG1vZHVsZS1sZXZlbCBzdGF0ZSB0aGF0IHdhcyBzZXQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NBZnRlclRocm93KCk7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBJIGZvdW5kIGFuZCBhZGRlZCB0aGlzIG1pc3NpbmcgbGluZSB3aGlsZSBpbnZlc3RpZ2F0aW5nIGFcbiAgICAgIC8vIHNlcGFyYXRlIGlzc3VlLiBXcml0ZSBhIHJlZ3Jlc3Npb24gdGVzdCB1c2luZyBzdHJpbmcgcmVmcy5cblxuICAgICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaWYgKGVycm9yZWRXb3JrID09PSBudWxsIHx8IGVycm9yZWRXb3JrLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSB3b3JraW5nIG9uIGEgbm9uLXJvb3QgZmliZXIuIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIGl0OyB0aGUgcm9vdCBpc1xuICAgICAgICAvLyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0IGNhdWdodCBieSBhbiBlcnJvclxuICAgICAgICAvLyBib3VuZGFyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSB0aHJvd25WYWx1ZTsgLy8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuICAgICAgICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4gICAgICAgIC8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbiAgICAgICAgLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuICAgICAgICAvLyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAvLyBzdXNwZW5kZWQgcmVuZGVyLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuXG4gICAgICAgIGlmICh0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHdha2VhYmxlID0gdGhyb3duVmFsdWU7XG4gICAgICAgICAgbWFya0NvbXBvbmVudFN1c3BlbmRlZChlcnJvcmVkV29yaywgd2FrZWFibGUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50RXJyb3JlZChlcnJvcmVkV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvd0V4Y2VwdGlvbihyb290LCBlcnJvcmVkV29yay5yZXR1cm4sIGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgY29tcGxldGVVbml0T2ZXb3JrKGVycm9yZWRXb3JrKTtcbiAgICB9IGNhdGNoICh5ZXRBbm90aGVyVGhyb3duVmFsdWUpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcmV0dXJuIHBhdGggYWxzbyB0aHJldy5cbiAgICAgIHRocm93blZhbHVlID0geWV0QW5vdGhlclRocm93blZhbHVlO1xuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IGVycm9yZWRXb3JrICYmIGVycm9yZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkgaGFzIGFscmVhZHkgZXJyb3JlZCwgdGhlbiB3ZSBoYWQgdHJvdWJsZSBwcm9jZXNzaW5nXG4gICAgICAgIC8vIHRoZSBlcnJvci4gQnViYmxlIGl0IHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICAgICAgICBlcnJvcmVkV29yayA9IGVycm9yZWRXb3JrLnJldHVybjtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBlcnJvcmVkV29yaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gUmV0dXJuIHRvIHRoZSBub3JtYWwgd29yayBsb29wLlxuXG5cbiAgICByZXR1cm47XG4gIH0gd2hpbGUgKHRydWUpO1xufVxuXG5mdW5jdGlvbiBwdXNoRGlzcGF0Y2hlcigpIHtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQ7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIGlmIChwcmV2RGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgIC8vIFRoZSBSZWFjdCBpc29tb3JwaGljIHBhY2thZ2UgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgZGlzcGF0Y2hlci5cbiAgICAvLyBJbnN0ZWFkIHRoZSBmaXJzdCByZW5kZXJlciB3aWxsIGxhemlseSBhdHRhY2ggb25lLCBpbiBvcmRlciB0byBnaXZlXG4gICAgLy8gbmljZXIgZXJyb3IgbWVzc2FnZXMuXG4gICAgcmV0dXJuIENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldkRpc3BhdGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcikge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpKSkge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4gICAgLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbiAgICAvLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuICAgIC8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxuICAgIG1hcmtSb290U3VzcGVuZGVkJDEod29ya0luUHJvZ3Jlc3NSb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKGVycm9yKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gW2Vycm9yXTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59IC8vIENhbGxlZCBkdXJpbmcgcmVuZGVyIHRvIGRldGVybWluZSBpZiBhbnl0aGluZyBoYXMgc3VzcGVuZGVkLlxuLy8gUmV0dXJucyBmYWxzZSBpZiB3ZSdyZSBub3Qgc3VyZS5cblxuZnVuY3Rpb24gcmVuZGVySGFzTm90U3VzcGVuZGVkWWV0KCkge1xuICAvLyBJZiBzb21ldGhpbmcgZXJyb3JlZCBvciBjb21wbGV0ZWQsIHdlIGNhbid0IHJlYWxseSBiZSBzdXJlLFxuICAvLyBzbyB0aG9zZSBhcmUgZmFsc2UuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpOyAvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbiAgLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICAgICAgICBpZiAobWVtb2l6ZWRVcGRhdGVycy5zaXplID4gMCkge1xuICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbiAgICAgICAgLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4gICAgICAgIC8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5cblxuICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO1xuICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIC8vIFN0aWxsIHdvcmsgcmVtYWluaW5nLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJvb3RJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBsZXRlZCB0aGUgdHJlZS5cbiAgICB7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH0gLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGVyZSdzIG5vIGluLXByb2dyZXNzIHJlbmRlci5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICggKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY3VycmVudCwgY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgbGFuZXMuXG5cblxuICAgICAgaWYgKF9uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICAgIF9uZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IF9uZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgc3VidHJlZSBmbGFncy5cbiAgICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcbiAgICAgICAgcmV0dXJuRmliZXIuc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHVud291bmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zKSB7XG4gIC8vIFRPRE86IFRoaXMgbm8gbG9uZ2VyIG1ha2VzIGFueSBzZW5zZS4gV2UgYWxyZWFkeSB3cmFwIHRoZSBtdXRhdGlvbiBhbmRcbiAgLy8gbGF5b3V0IHBoYXNlcy4gU2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlLlxuICB2YXIgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO1xuXG4gIHRyeSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH1cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gIHZhciBsYW5lcyA9IHJvb3QuZmluaXNoZWRMYW5lcztcblxuICB7XG4gICAgbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAge1xuICAgICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAgICAgZXJyb3IoJ3Jvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhICcgKyAnYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcblxuICBpZiAoZmluaXNoZWRXb3JrID09PSByb290LmN1cnJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lOyAvLyBVcGRhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IHBlbmRpbmcgdGltZXMgb24gdGhpcyByb290LiBUaGUgbmV3IGZpcnN0XG4gIC8vIHBlbmRpbmcgdGltZSBpcyB3aGF0ZXZlciBpcyBsZWZ0IG9uIHRoZSByb290IGZpYmVyLlxuXG4gIHZhciByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7XG4gIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBXZSBjYW4gcmVzZXQgdGhlc2Ugbm93IHRoYXQgdGhleSBhcmUgZmluaXNoZWQuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBwcm9jZXNzIHRoZW0uXG4gIC8vIERvIHRoaXMgYXMgZWFybHkgYXMgcG9zc2libGUsIHNvIGl0IGlzIHF1ZXVlZCBiZWZvcmUgYW55dGhpbmcgZWxzZSB0aGF0XG4gIC8vIG1pZ2h0IGdldCBzY2hlZHVsZWQgaW4gdGhlIGNvbW1pdCBwaGFzZS4gKFNlZSAjMTY3MTQuKVxuICAvLyBUT0RPOiBEZWxldGUgYWxsIG90aGVyIHBsYWNlcyB0aGF0IHNjaGVkdWxlIHRoZSBwYXNzaXZlIGVmZmVjdCBjYWxsYmFja1xuICAvLyBUaGV5J3JlIHJlZHVuZGFudC5cblxuXG4gIGlmICgoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyB8fCAoZmluaXNoZWRXb3JrLmZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzKSB7XG4gICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgLy8gdG8gc3RvcmUgaXQgaW4gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyB1bnRpbCB0aGV5IGdldCBwcm9jZXNzZWRcbiAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGlzIHRocm91Z2ggYXMgYW4gYXJndW1lbnQgdG8gY29tbWl0Um9vdFxuICAgICAgLy8gYmVjYXVzZSB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIG1pZ2h0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgcmVuZGVyIGFuZCBjb21taXQgaWYgd2UgdGhyb3R0bGUgdGhlIGNvbW1pdFxuICAgICAgLy8gd2l0aCBzZXRUaW1lb3V0XG5cbiAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7IC8vIFRoaXMgcmVuZGVyIHRyaWdnZXJlZCBwYXNzaXZlIGVmZmVjdHM6IHJlbGVhc2UgdGhlIHJvb3QgY2FjaGUgcG9vbFxuICAgICAgICAvLyAqYWZ0ZXIqIHBhc3NpdmUgZWZmZWN0cyBmaXJlIHRvIGF2b2lkIGZyZWVpbmcgYSBjYWNoZSBwb29sIHRoYXQgbWF5XG4gICAgICAgIC8vIGJlIHJlZmVyZW5jZWQgYnkgYSBub2RlIGluIHRoZSB0cmVlIChIb3N0Um9vdCwgQ2FjaGUgYm91bmRhcnkgZXRjKVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgZWZmZWN0cyBpbiB0aGUgd2hvbGUgdHJlZS5cbiAgLy8gVE9ETzogVGhpcyBpcyBsZWZ0IG92ZXIgZnJvbSB0aGUgZWZmZWN0IGxpc3QgaW1wbGVtZW50YXRpb24sIHdoZXJlIHdlIGhhZFxuICAvLyB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBgZmlyc3RFZmZlY3RgIHRvIHNhdGlzZnkgRmxvdy4gSSB0aGluayB0aGVcbiAgLy8gb25seSBvdGhlciByZWFzb24gdGhpcyBvcHRpbWl6YXRpb24gZXhpc3RzIGlzIGJlY2F1c2UgaXQgYWZmZWN0cyBwcm9maWxpbmcuXG4gIC8vIFJlY29uc2lkZXIgd2hldGhlciB0aGlzIGlzIG5lY2Vzc2FyeS5cblxuXG4gIHZhciBzdWJ0cmVlSGFzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzO1xuICB2YXIgcm9vdEhhc0VmZmVjdCA9IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAoQmVmb3JlTXV0YXRpb25NYXNrIHwgTXV0YXRpb25NYXNrIHwgTGF5b3V0TWFzayB8IFBhc3NpdmVNYXNrKSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKHN1YnRyZWVIYXNFZmZlY3RzIHx8IHJvb3RIYXNFZmZlY3QpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0OyAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDsgLy8gVGhlIGNvbW1pdCBwaGFzZSBpcyBicm9rZW4gaW50byBzZXZlcmFsIHN1Yi1waGFzZXMuIFdlIGRvIGEgc2VwYXJhdGUgcGFzc1xuICAgIC8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG4gICAgLy8gbGF5b3V0IGVmZmVjdHMsIGFuZCBzbyBvbi5cbiAgICAvLyBUaGUgZmlyc3QgcGhhc2UgYSBcImJlZm9yZSBtdXRhdGlvblwiIHBoYXNlLiBXZSB1c2UgdGhpcyBwaGFzZSB0byByZWFkIHRoZVxuICAgIC8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuICAgIC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGlzIGNhbGxlZC5cblxuICAgIHZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgIHtcbiAgICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpc1xuICAgICAgLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuXG5cbiAgICBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gICAgLy8gdGhlIG11dGF0aW9uIHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsIGN1cnJlbnQgZHVyaW5nXG4gICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIGxheW91dCBwaGFzZSwgc28gdGhhdCB0aGUgZmluaXNoZWRcbiAgICAvLyB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cblxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIGxheW91dCBwaGFzZSwgd2hlcmUgd2UgY2FsbCBlZmZlY3RzIHRoYXQgcmVhZFxuXG4gICAge1xuICAgICAgbWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG5cbiAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgbGFuZXMpO1xuXG4gICAge1xuICAgICAgbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7XG4gICAgfVxuICAgIC8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQoKTtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIFJlc2V0IHRoZSBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgbm9uLXN5bmMgdmFsdWUuXG5cbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gZWZmZWN0cy5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIE1lYXN1cmUgdGhlc2UgYW55d2F5IHNvIHRoZSBmbGFtZWdyYXBoIGV4cGxpY2l0bHkgc2hvd3MgdGhhdCB0aGVyZSB3ZXJlXG4gICAgLy8gbm8gZWZmZWN0cy5cbiAgICAvLyBUT0RPOiBNYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byByZXBvcnQgdGhpcy5cblxuICAgIHtcbiAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzO1xuXG4gIGlmIChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFRoaXMgY29tbWl0IGhhcyBwYXNzaXZlIGVmZmVjdHMuIFN0YXNoIGEgcmVmZXJlbmNlIHRvIHRoZW0uIEJ1dCBkb24ndFxuICAgIC8vIHNjaGVkdWxlIGEgY2FsbGJhY2sgdW50aWwgYWZ0ZXIgZmx1c2hpbmcgbGF5b3V0IHdvcmsuXG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IHJvb3Q7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBsYW5lcztcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuICAvLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4gIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4gIC8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4gIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4gIC8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3NcbiAgLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2VcbiAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4gIC8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgLy8gZXJyb3IgYm91bmRhcmllcy5cbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChyZWNvdmVyYWJsZUVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlIHdlcmUgZXJyb3JzIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHJlY292ZXJlZCBmcm9tIHRoZW0gd2l0aG91dFxuICAgIC8vIG5lZWRpbmcgdG8gc3VyZmFjZSBpdCB0byB0aGUgVUkuIFdlIGxvZyB0aGVtIGhlcmUuXG4gICAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSByZWNvdmVyYWJsZUVycm9yc1tpXTtcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHJlY292ZXJhYmxlRXJyb3Iuc3RhY2s7XG4gICAgICB2YXIgZGlnZXN0ID0gcmVjb3ZlcmFibGVFcnJvci5kaWdlc3Q7XG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IocmVjb3ZlcmFibGVFcnJvci52YWx1ZSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGRpZ2VzdDogZGlnZXN0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IkMSA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHRocm93IGVycm9yJDE7XG4gIH0gLy8gSWYgdGhlIHBhc3NpdmUgZWZmZWN0cyBhcmUgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIHJlbmRlciwgZmx1c2ggdGhlbVxuICAvLyBzeW5jaHJvbm91c2x5IGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgdGFzayBzbyB0aGF0IHRoZSByZXN1bHQgaXNcbiAgLy8gaW1tZWRpYXRlbHkgb2JzZXJ2YWJsZS4gT3RoZXJ3aXNlLCB3ZSBhc3N1bWUgdGhhdCB0aGV5IGFyZSBub3RcbiAgLy8gb3JkZXItZGVwZW5kZW50IGFuZCBkbyBub3QgbmVlZCB0byBiZSBvYnNlcnZlZCBieSBleHRlcm5hbCBzeXN0ZW1zLCBzbyB3ZVxuICAvLyBjYW4gd2FpdCB1bnRpbCBhZnRlciBwYWludC5cbiAgLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbm90IHNjaGVkdWxpbmcgdGhlIGNhbGxiYWNrIGVhcmxpZXIuIFNpbmNlIHdlXG4gIC8vIGN1cnJlbnRseSBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgaW4gbXVsdGlwbGUgcGxhY2VzLCB3aWxsIHdhaXQgdW50aWwgdGhvc2VcbiAgLy8gYXJlIGNvbnNvbGlkYXRlZC5cblxuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzLCBTeW5jTGFuZSkgJiYgcm9vdC50YWcgIT09IExlZ2FjeVJvb3QpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhIHBhc3NpdmUgZWZmZWN0IG1pZ2h0IGhhdmUgdXBkYXRlZCBpdFxuXG5cbiAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcblxuICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW1haW5pbmdMYW5lcywgU3luY0xhbmUpKSB7XG4gICAge1xuICAgICAgbWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpO1xuICAgIH0gLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG5cblxuICAgIGlmIChyb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IHJvb3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgfSAvLyBJZiBsYXlvdXQgd29yayB3YXMgc2NoZWR1bGVkLCBmbHVzaCBpdCBub3cuXG5cblxuICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcblxuICB7XG4gICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbiAgLy8gVE9ETzogQ29tYmluZSB0aGlzIGNoZWNrIHdpdGggdGhlIG9uZSBpbiBmbHVzaFBhc3NpdmVFRmZlY3RzSW1wbC4gV2Ugc2hvdWxkXG4gIC8vIHByb2JhYmx5IGp1c3QgY29tYmluZSB0aGUgdHdvIGZ1bmN0aW9ucy4gSSBiZWxpZXZlIHRoZXkgd2VyZSBvbmx5IHNlcGFyYXRlXG4gIC8vIGluIHRoZSBmaXJzdCBwbGFjZSBiZWNhdXNlIHdlIHVzZWQgdG8gd3JhcCBpdCB3aXRoXG4gIC8vIGBTY2hlZHVsZXIucnVuV2l0aFByaW9yaXR5YCwgd2hpY2ggYWNjZXB0cyBhIGZ1bmN0aW9uLiBCdXQgbm93IHdlIHRyYWNrIHRoZVxuICAvLyBwcmlvcml0eSB3aXRoaW4gUmVhY3QgaXRzZWxmLCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSB2YXJpYWJsZSBkaXJlY3RseS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG4gICAgdmFyIHJlbmRlclByaW9yaXR5ID0gbGFuZXNUb0V2ZW50UHJpb3JpdHkocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpO1xuICAgIHZhciBwcmlvcml0eSA9IGxvd2VyRXZlbnRQcmlvcml0eShEZWZhdWx0RXZlbnRQcmlvcml0eSwgcmVuZGVyUHJpb3JpdHkpO1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgICAgcmV0dXJuIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uOyAvLyBPbmNlIHBhc3NpdmUgZWZmZWN0cyBoYXZlIHJ1biBmb3IgdGhlIHRyZWUgLSBnaXZpbmcgY29tcG9uZW50cyBhXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QoZmliZXIpIHtcbiAge1xuICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzLnB1c2goZmliZXIpO1xuXG4gICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKSB7XG4gIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDYWNoZSBhbmQgY2xlYXIgdGhlIHRyYW5zaXRpb25zIGZsYWdcblxuXG4gIHZhciB0cmFuc2l0aW9ucyA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzO1xuICB2YXIgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsOyAvLyBUT0RPOiBUaGlzIGlzIHNvbWV0aW1lcyBvdXQgb2Ygc3luYyB3aXRoIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLlxuICAvLyBGaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBJdCdzIG5vdCBjYXVzaW5nIGFueSBrbm93biBpc3N1ZXMgKHByb2JhYmx5XG4gIC8vIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgZm9yIHByb2ZpbGluZyksIGJ1dCBpdCdzIGEgcmVmYWN0b3IgaGF6YXJkLlxuXG4gIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMocm9vdC5jdXJyZW50KTtcbiAgY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCByb290LmN1cnJlbnQsIGxhbmVzLCB0cmFuc2l0aW9ucyk7IC8vIFRPRE86IE1vdmUgdG8gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c1xuXG4gIHtcbiAgICB2YXIgcHJvZmlsZXJFZmZlY3RzID0gcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHM7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZmlsZXJFZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2ZpYmVyID0gcHJvZmlsZXJFZmZlY3RzW2ldO1xuICAgICAgY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhyb290LCBfZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gIH1cblxuICB7XG4gICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QuY3VycmVudCwgdHJ1ZSk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG4gIHtcbiAgICAvLyBJZiBhZGRpdGlvbmFsIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIHNjaGVkdWxlZCwgaW5jcmVtZW50IGEgY291bnRlci4gSWYgdGhpc1xuICAgIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cbiAgICBpZiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH0gLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cblxuICBvblBvc3RDb21taXRSb290KHJvb3QpO1xuXG4gIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gcm9vdC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcihlcnJvcikge1xuICBpZiAoIWhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gdHJ1ZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG52YXIgb25VbmNhdWdodEVycm9yID0gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yO1xuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIsIGVycm9ySW5mbywgU3luY0xhbmUpO1xuICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkMSkge1xuICB7XG4gICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yJDEpO1xuICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmliZXIgPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLCBzb3VyY2VGaWJlcik7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcbiAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBUT0RPOiBVbnRpbCB3ZSByZS1sYW5kIHNraXBVbm1vdW50ZWRCb3VuZGFyaWVzIChzZWUgIzIwMTQ3KSwgdGhpcyB3YXJuaW5nXG4gICAgLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG4gICAgLy8gdHJlZXMuIFdoYXQgaXQgc2hvdWxkIGluc3RlYWQgZG8gaXMgcHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IG9mXG4gICAgLy8gdGhlIGRlbGV0ZWQgdHJlZS4gSW4gdGhlIG1lYW50aW1lLCBkbyBub3QgYWRkIHRoaXMgd2FybmluZyB0byB0aGVcbiAgICAvLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIExpa2VseSAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuICB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93KCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBsYW5lcy5cbiAgaWYgKHJldHJ5TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgLy8gVE9ETzogQXNzaWduIHRoaXMgdG8gYHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lYD8gdG8gYXZvaWRcbiAgICAvLyB1bm5lY2Vzc2FyeSBlbnRhbmdsZW1lbnQ/XG4gICAgcmV0cnlMYW5lID0gcmVxdWVzdFJldHJ5TGFuZShib3VuZGFyeUZpYmVyKTtcbiAgfSAvLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cblxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoYm91bmRhcnlGaWJlcikge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTtcblxuICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAgc3dpdGNoIChib3VuZGFyeUZpYmVyLnRhZykge1xuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpbmdlZCB1bmtub3duIHN1c3BlbnNlIGJvdW5kYXJ5IHR5cGUuICcgKyAnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKGZpYmVyLCBoYXNQYXNzaXZlRWZmZWN0cykge1xuICB7XG4gICAgLy8gVE9ETyAoU3RyaWN0RWZmZWN0cykgU2hvdWxkIHdlIHNldCBhIG1hcmtlciBvbiB0aGUgcm9vdCBpZiBpdCBjb250YWlucyBzdHJpY3QgZWZmZWN0c1xuICAgIC8vIHNvIHdlIGRvbid0IHRyYXZlcnNlIHVubmVjZXNzYXJpbHk/IHNpbWlsYXIgdG8gc3VidHJlZUZsYWdzIGJ1dCBqdXN0IGF0IHRoZSByb290IGxldmVsLlxuICAgIC8vIE1heWJlIG5vdCBhIGJpZyBkZWFsIHNpbmNlIHRoaXMgaXMgREVWIG9ubHkgYmVoYXZpb3IuXG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50TGF5b3V0RGV2LCBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYpO1xuXG4gICAgaWYgKGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFVik7XG4gICAgfVxuXG4gICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudExheW91dERldiwgaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFVik7XG5cbiAgICBpZiAoaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRQYXNzaXZlRGV2LCBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VFZmZlY3RzSW5EZXYoZmlyc3RDaGlsZCwgZmliZXJGbGFncywgaW52b2tlRWZmZWN0Rm4pIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHZhciBjdXJyZW50ID0gZmlyc3RDaGlsZDtcbiAgICB2YXIgc3VidHJlZVJvb3QgPSBudWxsO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmltYXJ5U3VidHJlZUZsYWcgPSBjdXJyZW50LnN1YnRyZWVGbGFncyAmIGZpYmVyRmxhZ3M7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBzdWJ0cmVlUm9vdCAmJiBjdXJyZW50LmNoaWxkICE9PSBudWxsICYmIHByaW1hcnlTdWJ0cmVlRmxhZyAhPT0gTm9GbGFncykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoY3VycmVudC5mbGFncyAmIGZpYmVyRmxhZ3MpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgaW52b2tlRWZmZWN0Rm4oY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gc3VidHJlZVJvb3QgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCAmJiB0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgYmVnaW5Xb3JrJDE7XG5cbntcbiAgdmFyIGR1bW15RmliZXIgPSBudWxsO1xuXG4gIGJlZ2luV29yayQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHVuaXRPZldvcmssIGxhbmVzKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgdGhyb3dzIGFuIGVycm9yLCB3ZSByZXBsYXkgaXQgYWdhaW4gaW4gYSBzeW5jaHJvbm91c2x5XG4gICAgLy8gZGlzcGF0Y2hlZCBldmVudCwgc28gdGhhdCB0aGUgZGVidWdnZXIgd2lsbCB0cmVhdCBpdCBhcyBhbiB1bmNhdWdodFxuICAgIC8vIGVycm9yIFNlZSBSZWFjdEVycm9yVXRpbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY29weSB0aGUgd29yay1pbi1wcm9ncmVzcyBvbnRvIGEgZHVtbXlcbiAgICAvLyBmaWJlci4gSWYgYmVnaW5Xb3JrIHRocm93cywgd2UnbGwgdXNlIHRoaXMgdG8gcmVzZXQgdGhlIHN0YXRlLlxuICAgIHZhciBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSA9IGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKGR1bW15RmliZXIsIHVuaXRPZldvcmspO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuICAgIH0gY2F0Y2ggKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgIGlmIChkaWRTdXNwZW5kT3JFcnJvcldoaWxlSHlkcmF0aW5nREVWKCkgfHwgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuXG4gICAgICAgIC8vIERvbid0IHJlcGxheSBlcnJvcnMgaWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgaGF2ZSBhbHJlYWR5IHN1c3BlbmRlZCBvciBoYW5kbGVkIGFuIGVycm9yXG4gICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICB9IC8vIEtlZXAgdGhpcyBjb2RlIGluIHN5bmMgd2l0aCBoYW5kbGVFcnJvcjsgYW55IGNoYW5nZXMgaGVyZSBtdXN0IGhhdmVcbiAgICAgIC8vIGNvcnJlc3BvbmRpbmcgY2hhbmdlcyB0aGVyZS5cblxuXG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NBZnRlclRocm93KCk7IC8vIERvbid0IHJlc2V0IGN1cnJlbnQgZGVidWcgZmliZXIsIHNpbmNlIHdlJ3JlIGFib3V0IHRvIHdvcmsgb24gdGhlXG4gICAgICAvLyBzYW1lIGZpYmVyIGFnYWluLlxuICAgICAgLy8gVW53aW5kIHRoZSBmYWlsZWQgc3RhY2sgZnJhbWVcblxuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspOyAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0aWVzIG9mIHRoZSBmaWJlci5cblxuICAgICAgYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodW5pdE9mV29yaywgb3JpZ2luYWxXb3JrSW5Qcm9ncmVzc0NvcHkpO1xuXG4gICAgICBpZiAoIHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBwcm9maWxlciB0aW1lci5cbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgICAgfSAvLyBSdW4gYmVnaW5Xb3JrIGFnYWluLlxuXG5cbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBiZWdpbldvcmssIG51bGwsIGN1cnJlbnQsIHVuaXRPZldvcmssIGxhbmVzKTtcblxuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgdmFyIHJlcGxheUVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGF5RXJyb3IgPT09ICdvYmplY3QnICYmIHJlcGxheUVycm9yICE9PSBudWxsICYmIHJlcGxheUVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgIW9yaWdpbmFsRXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgIC8vIElmIHN1cHByZXNzZWQsIGxldCB0aGUgZmxhZyBjYXJyeSBvdmVyIHRvIHRoZSBvcmlnaW5hbCBlcnJvciB3aGljaCBpcyB0aGUgb25lIHdlJ2xsIHJldGhyb3cuXG4gICAgICAgICAgb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBhbHdheXMgdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yIGluIGNhc2UgdGhlIHNlY29uZCByZW5kZXIgcGFzcyBpcyBub3QgaWRlbXBvdGVudC5cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBhIG1lbW9pemVkIGZ1bmN0aW9uIG9yIENvbW1vbkpTIG1vZHVsZSBkb2Vzbid0IHRocm93IGFmdGVyIGZpcnN0IGludm9jYXRpb24uXG5cblxuICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICB9XG4gIH07XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudDtcblxue1xuICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaXNSZW5kZXJpbmcgJiYgIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJzsgLy8gRGVkdXBlIGJ5IHRoZSByZW5kZXJpbmcgY29tcG9uZW50IGJlY2F1c2UgaXQncyB0aGUgb25lIHRoYXQgbmVlZHMgdG8gYmUgZml4ZWQuXG5cbiAgICAgICAgICAgIHZhciBkZWR1cGVLZXkgPSByZW5kZXJpbmdDb21wb25lbnROYW1lO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMoZGVkdXBlS2V5KSkge1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKGRlZHVwZUtleSk7XG4gICAgICAgICAgICAgIHZhciBzZXRTdGF0ZUNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhICcgKyAnZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgJyArICdmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJywgc2V0U3RhdGVDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcikge1xuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJyArICdmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxpbmdGaWJlcikge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGNsZWFyIG1lbW9pemVkIHVwZGF0ZXJzLlxuICAgICAgLy8gVGhvc2UgbWF5IHN0aWxsIGJlIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGNvbW1pdFxuICAgICAgLy8gYW5kIGEgZnV0dXJlIG9uZSAoZS5nLiBTdXNwZW5zZSkuXG4gICAgfVxuICB9XG59XG52YXIgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrJDEocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ5cGFzcyBTY2hlZHVsZXIgYW5kIHB1c2ggdG9cbiAgICAvLyB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZC5cbiAgICB2YXIgYWN0UXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQ7XG5cbiAgICBpZiAoYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAgIGFjdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIGZha2VBY3RDYWxsYmFja05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2skMShjYWxsYmFja05vZGUpIHtcbiAgaWYgKCBjYWxsYmFja05vZGUgPT09IGZha2VBY3RDYWxsYmFja05vZGUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gSW4gcHJvZHVjdGlvbiwgYWx3YXlzIGNhbGwgU2NoZWR1bGVyLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgc3RyaXBwZWQgb3V0LlxuXG5cbiAgcmV0dXJuIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpIHtcbiAgLy8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbiAgcmV0dXJuICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcikge1xuICB7XG4gICAgaWYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgaWYgKCFpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZWdhY3kgbW9kZSBoYXMgYWRkaXRpb25hbCBjYXNlcyB3aGVyZSB3ZSBzdXBwcmVzcyBhIHdhcm5pbmcuXG4gICAgICBpZiAoIWlzTGVnYWN5QWN0RW52aXJvbm1lbnQoKSkge1xuICAgICAgICAvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgIT09IE5vQ29udGV4dCkge1xuICAgICAgICAvLyBMZWdhY3kgbW9kZSBkb2Vzbid0IHdhcm4gaWYgdGhlIHVwZGF0ZSBpcyBiYXRjaGVkLCBpLmUuXG4gICAgICAgIC8vIGJhdGNoZWRVcGRhdGVzIG9yIGZsdXNoU3luYy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmliZXIudGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiBmaWJlci50YWcgIT09IEZvcndhcmRSZWYgJiYgZmliZXIudGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHByZS1ob29rcyBjb2RlLCBsZWdhY3kgbW9kZSBvbmx5XG4gICAgICAgIC8vIHdhcm5zIGZvciB1cGRhdGVzIHRoYXQgb3JpZ2luYXRlIGZyb20gYSBob29rLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3QpIHtcbiAge1xuICAgIGlmIChyb290LnRhZyAhPT0gTGVnYWN5Um9vdCAmJiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0Egc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCAnICsgJ3dhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IHJlc29sdmVzIHN1c3BlbmRlZCBkYXRhIHNob3VsZCBiZSB3cmFwcGVkICcgKyAnaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpbmlzaCBsb2FkaW5nIHN1c3BlbmRlZCBkYXRhICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChpc1J1bm5pbmcpIHtcbiAge1xuICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9IGlzUnVubmluZztcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzICovXG52YXIgcmVzb2x2ZUZhbWlseSA9IG51bGw7IC8vICRGbG93Rml4TWUgRmxvdyBnZXRzIGNvbmZ1c2VkIGJ5IGEgV2Vha1NldCBmZWF0dXJlIGNoZWNrIGJlbG93LlxuXG52YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG52YXIgc2V0UmVmcmVzaEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICB7XG4gICAgcmVzb2x2ZUZhbWlseSA9IGhhbmRsZXI7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSAvLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cblxuXG4gICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAvLyBObyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcy5cbiAgcmV0dXJuIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHJlYWwgZm9yd2FyZFJlZi4gRG9uJ3Qgd2FudCB0byBjcmFzaCBlYXJseS5cbiAgICAgIGlmICh0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRm9yd2FyZFJlZiBpcyBzcGVjaWFsIGJlY2F1c2UgaXRzIHJlc29sdmVkIC50eXBlIGlzIGFuIG9iamVjdCxcbiAgICAgICAgLy8gYnV0IGl0J3MgcG9zc2libGUgdGhhdCB3ZSBvbmx5IGhhdmUgaXRzIGlubmVyIHJlbmRlciBmdW5jdGlvbiBpbiB0aGUgbWFwLlxuICAgICAgICAvLyBJZiB0aGF0IGlubmVyIHJlbmRlciBmdW5jdGlvbiBpcyBkaWZmZXJlbnQsIHdlJ2xsIGJ1aWxkIGEgbmV3IGZvcndhcmRSZWYgdHlwZS5cbiAgICAgICAgdmFyIGN1cnJlbnRSZW5kZXIgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpO1xuXG4gICAgICAgIGlmICh0eXBlLnJlbmRlciAhPT0gY3VycmVudFJlbmRlcikge1xuICAgICAgICAgIHZhciBzeW50aGV0aWNUeXBlID0ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgICAgICAgICByZW5kZXI6IGN1cnJlbnRSZW5kZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3ludGhldGljVHlwZS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN5bnRoZXRpY1R5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSAvLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cblxuXG4gICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgIHZhciBuZXh0VHlwZSA9IGVsZW1lbnQudHlwZTsgLy8gSWYgd2UgZ290IGhlcmUsIHdlIGtub3cgdHlwZXMgYXJlbid0ID09PSBlcXVhbC5cblxuICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IGZhbHNlO1xuICAgIHZhciAkJHR5cGVvZk5leHRUeXBlID0gdHlwZW9mIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBuZXh0VHlwZSAhPT0gbnVsbCA/IG5leHRUeXBlLiQkdHlwZW9mIDogbnVsbDtcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgdGhlIGlubmVyIHR5cGUgeWV0LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoYXQgdGhlIGxhenkgaW5uZXIgdHlwZSBpcyBzdGFibGUsXG4gICAgICAgICAgICAvLyBhbmQgc28gaXQgaXMgc3VmZmljaWVudCB0byBhdm9pZCByZWNvbmNpbGluZyBpdCBhd2F5LlxuICAgICAgICAgICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHVud3JhcCBvciBhY3R1YWxseSB1c2UgdGhlIG5ldyBsYXp5IHR5cGUuXG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGlmIGl0IHdhcyBidXQgY2FuIG5vIGxvbmdlciBiZSBzaW1wbGUsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3Qgc2V0IHRoaXMuXG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBDaGVjayBpZiBib3RoIHR5cGVzIGhhdmUgYSBmYW1pbHkgYW5kIGl0J3MgdGhlIHNhbWUgb25lLlxuXG5cbiAgICBpZiAobmVlZHNDb21wYXJlRmFtaWxpZXMpIHtcbiAgICAgIC8vIE5vdGU6IG1lbW8oKSBhbmQgZm9yd2FyZFJlZigpIHdlJ2xsIGNvbXBhcmUgb3V0ZXIgcmF0aGVyIHRoYW4gaW5uZXIgdHlwZS5cbiAgICAgIC8vIFRoaXMgbWVhbnMgYm90aCBvZiB0aGVtIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCB0byBwcmVzZXJ2ZSBzdGF0ZS5cbiAgICAgIC8vIElmIHdlIHVud3JhcHBlZCBhbmQgY29tcGFyZWQgdGhlIGlubmVyIHR5cGVzIGZvciB3cmFwcGVycyBpbnN0ZWFkLFxuICAgICAgLy8gdGhlbiB3ZSB3b3VsZCByaXNrIGZhbHNlbHkgc2F5aW5nIHR3byBzZXBhcmF0ZSBtZW1vKEZvbylcbiAgICAgIC8vIGNhbGxzIGFyZSBlcXVpdmFsZW50IGJlY2F1c2UgdGhleSB3cmFwIHRoZSBzYW1lIEZvbyBmdW5jdGlvbi5cbiAgICAgIHZhciBwcmV2RmFtaWx5ID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSk7XG5cbiAgICAgIGlmIChwcmV2RmFtaWx5ICE9PSB1bmRlZmluZWQgJiYgcHJldkZhbWlseSA9PT0gcmVzb2x2ZUZhbWlseShuZXh0VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcikge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBXZWFrU2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpO1xuICAgIH1cblxuICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGZpYmVyKTtcbiAgfVxufVxudmFyIHNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCB1cGRhdGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXMsXG4gICAgICAgIHVwZGF0ZWRGYW1pbGllcyA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBzY2hlZHVsZVJvb3QgPSBmdW5jdGlvbiAocm9vdCwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJvb3QuY29udGV4dCAhPT0gZW1wdHlDb250ZXh0T2JqZWN0KSB7XG4gICAgICAvLyBTdXBlciBlZGdlIGNhc2U6IHJvb3QgaGFzIGEgbGVnYWN5IF9yZW5kZXJTdWJ0cmVlIGNvbnRleHRcbiAgICAgIC8vIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSBwYXJlbnRDb21wb25lbnQgc28gd2UgY2FuJ3QgcGFzcyBpdC5cbiAgICAgIC8vIEp1c3QgaWdub3JlLiBXZSdsbCBkZWxldGUgdGhpcyB3aXRoIF9yZW5kZXJTdWJ0cmVlIGNvZGUgcGF0aCBsYXRlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCByb290LCBudWxsLCBudWxsKTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShmaWJlciwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcbiAgICB2YXIgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlc29sdmVGYW1pbHkgdG8gYmUgc2V0IGR1cmluZyBob3QgcmVsb2FkLicpO1xuICAgIH1cblxuICAgIHZhciBuZWVkc1JlbmRlciA9IGZhbHNlO1xuICAgIHZhciBuZWVkc1JlbW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKTtcblxuICAgICAgaWYgKGZhbWlseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzdGFsZUZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGVkRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBpZiAodGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZHNSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzICE9PSBudWxsKSB7XG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCkge1xuICAgICAgZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50IHx8IG5lZWRzUmVuZGVyKSB7XG4gICAgICB2YXIgX3Jvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKF9yb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihfcm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsICYmICFuZWVkc1JlbW91bnQpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoY2hpbGQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoc2libGluZywgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCBmYW1pbGllcykge1xuICB7XG4gICAgdmFyIGhvc3RJbnN0YW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHR5cGVzID0gbmV3IFNldChmYW1pbGllcy5tYXAoZnVuY3Rpb24gKGZhbWlseSkge1xuICAgICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICAgIH0pKTtcbiAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgcmV0dXJuIGhvc3RJbnN0YW5jZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShmaWJlciwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcbiAgICB2YXIgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBkaWRNYXRjaCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlcy5oYXMoY2FuZGlkYXRlVHlwZSkpIHtcbiAgICAgICAgZGlkTWF0Y2ggPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRNYXRjaCkge1xuICAgICAgLy8gV2UgaGF2ZSBhIG1hdGNoLiBUaGlzIG9ubHkgZHJpbGxzIGRvd24gdG8gdGhlIGNsb3Nlc3QgaG9zdCBjb21wb25lbnRzLlxuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaCBkZWVwZXIgYmVjYXVzZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZ2l2aW5nXG4gICAgICAvLyB2aXN1YWwgZmVlZGJhY2ssIFwiZmxhc2hpbmdcIiBvdXRlcm1vc3QgcGFyZW50IHJlY3RhbmdsZXMgaXMgc3VmZmljaWVudC5cbiAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoLCBtYXliZSB0aGVyZSB3aWxsIGJlIG9uZSBmdXJ0aGVyIGRvd24gaW4gdGhlIGNoaWxkIHRyZWUuXG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGNoaWxkLCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShzaWJsaW5nLCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpO1xuXG4gICAgaWYgKGZvdW5kSG9zdEluc3RhbmNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGhvc3QgY2hpbGRyZW4sIGZhbGxiYWNrIHRvIGNsb3Nlc3QgaG9zdCBwYXJlbnQuXG5cblxuICAgIHZhciBub2RlID0gZmliZXI7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byByZWFjaCByb290IGZpcnN0LicpO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIG1hdGNoLlxuICAgICAgICBmb3VuZEhvc3RJbnN0YW5jZXMgPSB0cnVlO1xuICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7IC8vIFRoZXJlIG1heSBzdGlsbCBiZSBtb3JlLCBzbyBrZWVwIHNlYXJjaGluZy5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzQmFkTWFwUG9seWZpbGw7XG5cbntcbiAgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG5cblxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0JDEodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnQgOiBGdW5jdGlvbkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgIHJldHVybiBGb3J3YXJkUmVmO1xuICAgIH1cblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICByZXR1cm4gTWVtb0NvbXBvbmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXM7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wczsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IE5vRmxhZ3M7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfSAvLyBSZXNldCBhbGwgZWZmZWN0cyBleGNlcHQgc3RhdGljIG9uZXMuXG4gIC8vIFN0YXRpYyBlZmZlY3RzIGFyZSBub3Qgc3BlY2lmaWMgdG8gYSByZW5kZXIuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiBTdGF0aWNNYXNrO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgZmxhZ3MgYnV0IGtlZXAgYW55IFBsYWNlbWVudCB0YWdzLCBzaW5jZSB0aGF0J3Mgc29tZXRoaW5nXG4gIC8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gU3RhdGljTWFzayB8IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRvIGNyZWF0ZUZpYmVyJ3MgaW5pdGlhbCB2YWx1ZXMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHRvIHRoZSBjbG9uZWQgdmFsdWVzIHRoYXQgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGQndmUuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlKSB7XG4gIHZhciBtb2RlO1xuXG4gIGlmICh0YWcgPT09IENvbmN1cnJlbnRSb290KSB7XG4gICAgbW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuXG4gICAgaWYgKGlzU3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlO1xuXG4gICAgICB7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1vZGUgPSBOb01vZGU7XG4gIH1cblxuICBpZiAoIGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgLy8gQWx3YXlzIGNvbGxlY3QgcHJvZmlsZSB0aW1pbmdzIHdoZW4gRGV2VG9vbHMgYXJlIHByZXNlbnQuXG4gICAgLy8gVGhpcyBlbmFibGVzIERldlRvb2xzIHRvIHN0YXJ0IGNhcHR1cmluZyB0aW1pbmcgYXQgYW55IHBvaW504oCTXG4gICAgLy8gV2l0aG91dCBzb21lIG5vZGVzIGluIHRoZSB0cmVlIGhhdmluZyBlbXB0eSBiYXNlIHRpbWVzLlxuICAgIG1vZGUgfD0gUHJvZmlsZU1vZGU7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIG51bGwsIG1vZGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIC8vIFJlYWN0JEVsZW1lbnRUeXBlXG5rZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlclRhZyA9IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7IC8vIFRoZSByZXNvbHZlZCB0eXBlIGlzIHNldCBpZiB3ZSBrbm93IHdoYXQgdGhlIGZpbmFsIHR5cGUgd2lsbCBiZS4gSS5lLiBpdCdzIG5vdCBsYXp5LlxuXG4gIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSkge1xuICAgICAgZmliZXJUYWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGdldFRhZzogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlO1xuXG4gICAgICAgIGlmICggKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIC8vIFN0cmljdCBlZmZlY3RzIHNob3VsZCBuZXZlciBydW4gb24gbGVnYWN5IHJvb3RzXG4gICAgICAgICAgbW9kZSB8PSBTdHJpY3RFZmZlY3RzTW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBNZW1vQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IExhenlDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcikgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcgKyAnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnICsgKFwiYnV0IGdvdDogXCIgKyAodHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbykpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJywgdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUxpc3RDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICBpc0hpZGRlbjogZmFsc2VcbiAgfTtcbiAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5zdWJ0cmVlRmxhZ3MgPSBzb3VyY2Uuc3VidHJlZUZsYWdzO1xuICB0YXJnZXQuZGVsZXRpb25zID0gc291cmNlLmRlbGV0aW9ucztcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdOZWVkc1JlbW91bnQgPSBzb3VyY2UuX2RlYnVnTmVlZHNSZW1vdW50O1xuICB0YXJnZXQuX2RlYnVnSG9va1R5cGVzID0gc291cmNlLl9kZWJ1Z0hvb2tUeXBlcztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHRoaXMuZXZlbnRUaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG4gIHRoaXMucGVuZGluZ0xhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmV4cGlyZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMubXV0YWJsZVJlYWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICB7XG4gICAgdGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5tZW1vaXplZFVwZGF0ZXJzID0gbmV3IFNldCgpO1xuICAgIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgVG90YWxMYW5lczsgX2krKykge1xuICAgICAgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcC5wdXNoKG5ldyBTZXQoKSk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIENvbmN1cnJlbnRSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/ICdoeWRyYXRlUm9vdCgpJyA6ICdjcmVhdGVSb290KCknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWdhY3lSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/ICdoeWRyYXRlKCknIDogJ3JlbmRlcigpJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIC8vIFRPRE86IFdlIGhhdmUgc2V2ZXJhbCBvZiB0aGVzZSBhcmd1bWVudHMgdGhhdCBhcmUgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlXG4vLyBob3N0IGNvbmZpZywgYnV0IGJlY2F1c2UgdGhleSBhcmUgcGFzc2VkIGluIGF0IHJ1bnRpbWUsIHdlIGhhdmUgdG8gdGhyZWFkXG4vLyB0aGVtIHRocm91Z2ggdGhlIHJvb3QgY29uc3RydWN0b3IuIFBlcmhhcHMgd2Ugc2hvdWxkIHB1dCB0aGVtIGFsbCBpbnRvIGFcbi8vIHNpbmdsZSB0eXBlLCBsaWtlIGEgRHluYW1pY0hvc3RDb25maWcgdGhhdCBpcyBkZWZpbmVkIGJ5IHRoZSByZW5kZXJlci5cbmlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgcm9vdCA9IG5ldyBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZywgaXNTdHJpY3RNb2RlKTtcbiAgcm9vdC5jdXJyZW50ID0gdW5pbml0aWFsaXplZEZpYmVyO1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcblxuICB7XG4gICAgdmFyIF9pbml0aWFsU3RhdGUgPSB7XG4gICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgICBjYWNoZTogbnVsbCxcbiAgICAgIC8vIG5vdCBlbmFibGVkIHlldFxuICAgICAgdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICBwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOiBudWxsXG4gICAgfTtcbiAgICB1bmluaXRpYWxpemVkRmliZXIubWVtb2l6ZWRTdGF0ZSA9IF9pbml0aWFsU3RhdGU7XG4gIH1cblxuICBpbml0aWFsaXplVXBkYXRlUXVldWUodW5pbml0aWFsaXplZEZpYmVyKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4xJztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCAvLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB7XG4gICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbnZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzO1xudmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlO1xuXG57XG4gIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBDb21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICAgIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbignLCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGtleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaG9zdEZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGhvc3RGaWJlcik7XG5cbiAgICAgICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIHJlc2V0IHRvIHByZXZpb3VzIGJ1dCB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaW5cbiAgICAgICAgICAvLyByZW5kZXIgYW5kIHRoZXJlJ3MgYW5vdGhlciB3YXJuaW5nIGZvciB0aGF0IGFueXdheS5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgICAgc2V0Q3VycmVudEZpYmVyKHByZXZpb3VzRmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MpIHtcbiAgdmFyIGh5ZHJhdGUgPSBmYWxzZTtcbiAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgLy8gVE9ETzogUmVtb3ZlIGBjYWxsYmFja2Agd2hlbiB3ZSBkZWxldGUgbGVnYWN5IG1vZGUuXG5jYWxsYmFjaywgY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gdHJ1ZTtcbiAgdmFyIHJvb3QgPSBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpOyAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gRmliZXJSb290IGNvbnN0cnVjdG9yXG5cbiAgcm9vdC5jb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7IC8vIFNjaGVkdWxlIHRoZSBpbml0aWFsIHJlbmRlci4gSW4gYSBoeWRyYXRpb24gcm9vdCwgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICAvLyBhIHJlZ3VsYXIgdXBkYXRlIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3QgbWF0Y2ggd2FzIHdhcyByZW5kZXJlZFxuICAvLyBvbiB0aGUgc2VydmVyLlxuICAvLyBOT1RFOiBUaGlzIHVwZGF0ZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgaGF2ZSBhIHBheWxvYWQuIFdlJ3JlIG9ubHkgdXNpbmdcbiAgLy8gdGhlIHVwZGF0ZSB0byBzY2hlZHVsZSB3b3JrIG9uIHRoZSByb290IGZpYmVyIChhbmQsIGZvciBsZWdhY3kgcm9vdHMsIHRvXG4gIC8vIGVucXVldWUgdGhlIGNhbGxiYWNrIGlmIG9uZSBpcyBwcm92aWRlZCkuXG5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCA/IGNhbGxiYWNrIDogbnVsbDtcbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50LCB1cGRhdGUsIGxhbmUpO1xuICBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBvblNjaGVkdWxlUm9vdChjb250YWluZXIsIGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGN1cnJlbnQkMSwgdXBkYXRlLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG4gICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBjdXJyZW50JDEsIGxhbmUpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB2YXIgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7XG4gICAgICAgICAgZmx1c2hSb290KHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIElmIHdlJ3JlIHN0aWxsIGJsb2NrZWQgYWZ0ZXIgdGhpcywgd2UgbmVlZCB0byBpbmNyZWFzZVxuICAgICAgICAvLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuICAgICAgICAvLyBib3VuZGFyeSBzbyB0aGF0IHRoZXkgbmV4dCBhdHRlbXB0IGFsc28gaGFzIGhpZ2hlciBwcmkuXG5cbiAgICAgICAgdmFyIHJldHJ5TGFuZSA9IFN5bmNMYW5lO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVuYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgbWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBhbmQgdGhleSBzaG91bGQgbm90IHN1c3BlbmQgb24gSS9PLFxuICAgIC8vIHNpbmNlIHlvdSBoYXZlIHRvIHdyYXAgYW55dGhpbmcgdGhhdCBtaWdodCBzdXNwZW5kIGluXG4gICAgLy8gU3VzcGVuc2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhbmUgPSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfVxuXG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSQxKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBvdGhlciB0aGFuIHN5bmNocm9ub3VzbHkgZmx1c2ggaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICB9XG5cbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbnZhciBzaG91bGRFcnJvckltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRFcnJvcihmaWJlcikge1xuICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbn1cblxudmFyIHNob3VsZFN1c3BlbmRJbXBsID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFN1c3BlbmQoZmliZXIpIHtcbiAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbn1cbnZhciBvdmVycmlkZUhvb2tTdGF0ZSA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHMgPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgc2NoZWR1bGVVcGRhdGUgPSBudWxsO1xudmFyIHNldEVycm9ySGFuZGxlciA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhEZWxldGUgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZUltcGwgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgICB1cGRhdGVkW25ld0tleV0gPSB1cGRhdGVkW29sZEtleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtvbGRLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIG9ialtvbGRLZXldLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZSA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBpZiAob2xkUGF0aC5sZW5ndGggIT09IG5ld1BhdGgubGVuZ3RoKSB7XG4gICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldEltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhSZW5hbWUoaG9vay5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuICAgIGJ1bmRsZVR5cGU6IGRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsXG4gICAgdmVyc2lvbjogZGV2VG9vbHNDb25maWcudmVyc2lvbixcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgIHJlbmRlcmVyQ29uZmlnOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZTogb3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wczogb3ZlcnJpZGVQcm9wcyxcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgIHNldEVycm9ySGFuZGxlcjogc2V0RXJyb3JIYW5kbGVyLFxuICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIHx8IGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgLy8gUmVhY3QgUmVmcmVzaFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSZWZyZXNoOiAgc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6ICBzY2hlZHVsZVJvb3QgLFxuICAgIHNldFJlZnJlc2hIYW5kbGVyOiAgc2V0UmVmcmVzaEhhbmRsZXIgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbiAgICBnZXRDdXJyZW50RmliZXI6ICBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cbiAgICAvLyB3aGljaCBtYXkgbm90IG1hdGNoIGZvciB0aGlyZCBwYXJ0eSByZW5kZXJlcnMuXG4gICAgcmVjb25jaWxlclZlcnNpb246IFJlYWN0VmVyc2lvblxuICB9KTtcbn1cblxuLyogZ2xvYmFsIHJlcG9ydEVycm9yICovXG5cbnZhciBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG5yZXBvcnRFcnJvciA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7XG59O1xuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoaW50ZXJuYWxSb290KSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGludGVybmFsUm9vdDtcbn1cblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBhbiB1bm1vdW50ZWQgcm9vdC4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuICcgKyAnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkQ29udGFpbmVyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIGVycm9yKCdZb3UgcGFzc2VkIGEgY29udGFpbmVyIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQgb2Ygcm9vdC5yZW5kZXIoLi4uKS4gJyArIFwiWW91IGRvbid0IG5lZWQgdG8gcGFzcyBpdCBhZ2FpbiBzaW5jZSB5b3UgYWxyZWFkeSBwYXNzZWQgaXQgdG8gY3JlYXRlIHRoZSByb290LlwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignWW91IHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCB0byByb290LnJlbmRlciguLi4pIGJ1dCBpdCBvbmx5IGFjY2VwdHMgJyArICdvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKHJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhlICcgKyAncm9vdCBjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyBcInJvb3QudW5tb3VudCgpIHRvIGVtcHR5IGEgcm9vdCdzIGNvbnRhaW5lci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIG51bGwpO1xufTtcblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bm1vdW50ID0gUmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHRoaXMuX2ludGVybmFsUm9vdCA9IG51bGw7XG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIHtcbiAgICAgIGlmIChpc0FscmVhZHlSZW5kZXJpbmcoKSkge1xuICAgICAgICBlcnJvcignQXR0ZW1wdGVkIHRvIHN5bmNocm9ub3VzbHkgdW5tb3VudCBhIHJvb3Qgd2hpbGUgUmVhY3Qgd2FzIGFscmVhZHkgJyArICdyZW5kZXJpbmcuIFJlYWN0IGNhbm5vdCBmaW5pc2ggdW5tb3VudGluZyB0aGUgcm9vdCB1bnRpbCB0aGUgJyArICdjdXJyZW50IHJlbmRlciBoYXMgY29tcGxldGVkLCB3aGljaCBtYXkgbGVhZCB0byBhIHJhY2UgY29uZGl0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gICAgdW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICB3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7XG4gIHZhciBpc1N0cmljdE1vZGUgPSBmYWxzZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUgPSBmYWxzZTtcbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSAnJztcbiAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG4gIHZhciB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbDtcblxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgIHdhcm4oJ2h5ZHJhdGUgdGhyb3VnaCBjcmVhdGVSb290IGlzIGRlcHJlY2F0ZWQuIFVzZSBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIDxBcHAgLz4pIGluc3RlYWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucy4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgZXJyb3IoJ1lvdSBwYXNzZWQgYSBKU1ggZWxlbWVudCB0byBjcmVhdGVSb290LiBZb3UgcHJvYmFibHkgbWVhbnQgdG8gJyArICdjYWxsIHJvb3QucmVuZGVyIGluc3RlYWQuICcgKyAnRXhhbXBsZSB1c2FnZTpcXG5cXG4nICsgJyAgbGV0IHJvb3QgPSBjcmVhdGVSb290KGRvbUNvbnRhaW5lcik7XFxuJyArICcgIHJvb3QucmVuZGVyKDxBcHAgLz4pOycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgaXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb25DYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMudHJhbnNpdGlvbkNhbGxiYWNrcztcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIENvbmN1cnJlbnRSb290LCBudWxsLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgcm9vdENvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyO1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHJldHVybiBuZXcgUmVhY3RET01Sb290KHJvb3QpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW50ZXJuYWxSb290KSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGludGVybmFsUm9vdDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVIeWRyYXRpb24odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBxdWV1ZUV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7XG4gIH1cbn1cblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbiA9IHNjaGVkdWxlSHlkcmF0aW9uO1xuZnVuY3Rpb24gaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2h5ZHJhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICB3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7XG5cbiAge1xuICAgIGlmIChpbml0aWFsQ2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ011c3QgcHJvdmlkZSBpbml0aWFsIGNoaWxkcmVuIGFzIHNlY29uZCBhcmd1bWVudCB0byBoeWRyYXRlUm9vdC4gJyArICdFeGFtcGxlIHVzYWdlOiBoeWRyYXRlUm9vdChkb21Db250YWluZXIsIDxBcHAgLz4pJyk7XG4gICAgfVxuICB9IC8vIEZvciBub3cgd2UgcmV1c2UgdGhlIHdob2xlIGJhZyBvZiBvcHRpb25zIHNpbmNlIHRoZXkgY29udGFpblxuICAvLyB0aGUgaHlkcmF0aW9uIGNhbGxiYWNrcy5cblxuXG4gIHZhciBoeWRyYXRpb25DYWxsYmFja3MgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDogbnVsbDsgLy8gVE9ETzogRGVsZXRlIHRoaXMgb3B0aW9uXG5cbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZWRTb3VyY2VzIHx8IG51bGw7XG4gIHZhciBpc1N0cmljdE1vZGUgPSBmYWxzZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUgPSBmYWxzZTtcbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSAnJztcbiAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgaXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290ID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgbnVsbCwgY29udGFpbmVyLCBDb25jdXJyZW50Um9vdCwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpOyAvLyBUaGlzIGNhbid0IGJlIGEgY29tbWVudCBub2RlIHNpbmNlIGh5ZHJhdGlvbiBkb2Vzbid0IHdvcmsgb24gY29tbWVudCBub2RlcyBhbnl3YXkuXG5cbiAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoY29udGFpbmVyKTtcblxuICBpZiAobXV0YWJsZVNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGFibGVTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IG11dGFibGVTb3VyY2VzW2ldO1xuICAgICAgcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhY3RET01IeWRyYXRpb25Sb290KHJvb3QpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8ICFkaXNhYmxlQ29tbWVudHNBc0RPTUNvbnRhaW5lcnMgICkpO1xufSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiB3aGljaCBhbHNvIGluY2x1ZGVzIGNvbW1lbnQgbm9kZXMuXG4vLyBXZSBvbmx5IHVzZSBpdCBpbiBwbGFjZXMgdGhhdCBhcmUgY3VycmVudGx5IG1vcmUgcmVsYXhlZC5cblxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lckxlZ2FjeShub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKSB7XG4gIHtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgY29udGFpbmVyLnRhZ05hbWUgJiYgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0JPRFknKSB7XG4gICAgICBlcnJvcignY3JlYXRlUm9vdCgpOiBDcmVhdGluZyByb290cyBkaXJlY3RseSB3aXRoIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSB1c2luZyBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLnJlbmRlcigpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0ICcgKyAnaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gY3JlYXRlUm9vdCgpIGJlZm9yZS4gSW5zdGVhZCwgY2FsbCAnICsgJ3Jvb3QucmVuZGVyKCkgb24gdGhlIGV4aXN0aW5nIHJvb3QgaW5zdGVhZCBpZiB5b3Ugd2FudCB0byB1cGRhdGUgaXQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncztcblxue1xuICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wT25SZWNvdmVyYWJsZUVycm9yKCkgey8vIFRoaXMgaXNuJ3QgcmVhY2hhYmxlIGJlY2F1c2Ugb25SZWNvdmVyYWJsZUVycm9yIGlzbid0IGNhbGxlZCBpbiB0aGVcbiAgLy8gbGVnYWN5IEFQSS5cbn1cblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2ssIGlzSHlkcmF0aW9uQ29udGFpbmVyKSB7XG4gIGlmIChpc0h5ZHJhdGlvbkNvbnRhaW5lcikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByb290ID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgY2FsbGJhY2ssIGNvbnRhaW5lciwgTGVnYWN5Um9vdCwgbnVsbCwgLy8gaHlkcmF0aW9uQ2FsbGJhY2tzXG4gICAgZmFsc2UsIC8vIGlzU3RyaWN0TW9kZVxuICAgIGZhbHNlLCAvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICcnLCAvLyBpZGVudGlmaWVyUHJlZml4XG4gICAgbm9vcE9uUmVjb3ZlcmFibGVFcnJvcik7XG4gICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xuICAgIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICAgIGZsdXNoU3luYygpO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9vcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2UoX3Jvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX3Jvb3QgPSBjcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBMZWdhY3lSb290LCBudWxsLCAvLyBoeWRyYXRpb25DYWxsYmFja3NcbiAgICBmYWxzZSwgLy8gaXNTdHJpY3RNb2RlXG4gICAgZmFsc2UsIC8vIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgJycsIC8vIGlkZW50aWZpZXJQcmVmaXhcbiAgICBub29wT25SZWNvdmVyYWJsZUVycm9yKTtcblxuICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gX3Jvb3Q7XG4gICAgbWFya0NvbnRhaW5lckFzUm9vdChfcm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuXG4gICAgdmFyIF9yb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG5cbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhfcm9vdENvbnRhaW5lckVsZW1lbnQpOyAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cblxuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoaW5pdGlhbENoaWxkcmVuLCBfcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yb290O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG5cbiAgdmFyIG1heWJlUm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgcm9vdDtcblxuICBpZiAoIW1heWJlUm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaywgZm9yY2VIeWRyYXRlKTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gbWF5YmVSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfSAvLyBVcGRhdGVcblxuXG4gICAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRGaW5kRE9NTm9kZSA9IGZhbHNlO1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmRET01Ob2RlKSB7XG4gICAgICBkaWRXYXJuQWJvdXRGaW5kRE9NTm9kZSA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdmaW5kRE9NTm9kZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgJyArICdyZWxlYXNlLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgJyArICd0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJyk7XG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHtcbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwgJ2ZpbmRET01Ob2RlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICB7XG4gICAgZXJyb3IoJ1JlYWN0RE9NLmh5ZHJhdGUgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBpbiBSZWFjdCAxOC4gVXNlIGh5ZHJhdGVSb290ICcgKyAnaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byB0aGUgbmV3IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgJyArIFwiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIiArICdtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGh5ZHJhdGVSb290KGNvbnRhaW5lciwgZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9IC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cblxuXG4gIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIHRydWUsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBlcnJvcignUmVhY3RET00ucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290ICcgKyAnaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byB0aGUgbmV3IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgJyArIFwiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIiArICdtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIGVycm9yKCdSZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgJyArICdpbiBSZWFjdCAxOC4gQ29uc2lkZXIgdXNpbmcgYSBwb3J0YWwgaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byAnICsgXCJ0aGUgY3JlYXRlUm9vdCBBUEksIHlvdXIgYXBwIHdpbGwgYmVoYXZlIGFzIGlmIGl0J3MgcnVubmluZyBSZWFjdCBcIiArICcxNy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7XG4gIH1cblxuICBpZiAoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICBpZiAocGFyZW50Q29tcG9uZW50ID09IG51bGwgfHwgIWhhcyhwYXJlbnRDb21wb25lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpO1xuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbnZhciBkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlID0gZmFsc2U7XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ3VubW91bnRDb21wb25lbnRBdE5vZGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSAnICsgJ25leHQgbWFqb3IgcmVsZWFzZS4gU3dpdGNoIHRvIHRoZSBjcmVhdGVSb290IEFQSS4gTGVhcm4gJyArICdtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBEaWQgeW91IG1lYW4gdG8gY2FsbCByb290LnVubW91bnQoKT8nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICB7XG4gICAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG5cbiAgICAgIGlmIChyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9IC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuXG5cbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOyAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cblxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc2V0QXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiQxKTtcbnNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSQxKTtcbnNldEdldEN1cnJlbnRVcGRhdGVQcmlvcml0eShnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5KTtcblxue1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIE1hcCBoYXMgbm8gcHJvdG90eXBlXG4gIE1hcC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBTZXQgaGFzIG5vIHByb3RvdHlwZVxuICBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yKCdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5zZXRSZXN0b3JlSW1wbGVtZW50YXRpb24ocmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKTtcbnNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oYmF0Y2hlZFVwZGF0ZXMkMSwgZGlzY3JldGVVcGRhdGVzLCBmbHVzaFN5bmMpO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH0gLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgLy8gJEZsb3dGaXhNZSBUaGUgRmxvdyB0eXBlIGlzIG9wYXF1ZSBidXQgdGhlcmUncyBubyB3YXkgdG8gYWN0dWFsbHkgY3JlYXRlIGl0LlxuXG5cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKTtcbn1cblxudmFyIEludGVybmFscyA9IHtcbiAgdXNpbmdDbGllbnRFbnRyeVBvaW50OiBmYWxzZSxcbiAgLy8gS2VlcCBpbiBzeW5jIHdpdGggUmVhY3RUZXN0VXRpbHMuanMuXG4gIC8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gIEV2ZW50czogW2dldEluc3RhbmNlRnJvbU5vZGUsIGdldE5vZGVGcm9tSW5zdGFuY2UsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsIGVucXVldWVTdGF0ZVJlc3RvcmUsIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLCBiYXRjaGVkVXBkYXRlcyQxXVxufTtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdCQxKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKCFJbnRlcm5hbHMudXNpbmdDbGllbnRFbnRyeVBvaW50ICYmICFmYWxzZSkge1xuICAgICAgZXJyb3IoJ1lvdSBhcmUgaW1wb3J0aW5nIGNyZWF0ZVJvb3QgZnJvbSBcInJlYWN0LWRvbVwiIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHNob3VsZCBpbnN0ZWFkIGltcG9ydCBpdCBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVSb290KGNvbnRhaW5lciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVSb290JDEoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAge1xuICAgIGlmICghSW50ZXJuYWxzLnVzaW5nQ2xpZW50RW50cnlQb2ludCAmJiAhZmFsc2UpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGltcG9ydGluZyBoeWRyYXRlUm9vdCBmcm9tIFwicmVhY3QtZG9tXCIgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGh5ZHJhdGVSb290KGNvbnRhaW5lciwgaW5pdGlhbENoaWxkcmVuLCBvcHRpb25zKTtcbn0gLy8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBmbHVzaFN5bmMkMShmbikge1xuICB7XG4gICAgaWYgKGlzQWxyZWFkeVJlbmRlcmluZygpKSB7XG4gICAgICBlcnJvcignZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBSZWFjdCBjYW5ub3QgJyArICdmbHVzaCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBjYWxsIHRvICcgKyAnYSBzY2hlZHVsZXIgdGFzayBvciBtaWNybyB0YXNrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbHVzaFN5bmMoZm4pO1xufVxudmFyIGZvdW5kRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6ICAxICxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtZG9tJ1xufSk7XG5cbntcbiAgaWYgKCFmb3VuZERldlRvb2xzICYmIGNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDsgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbiAgICAgICAgY29uc29sZS5pbmZvKCclY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBJbnRlcm5hbHM7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbCQxO1xuZXhwb3J0cy5jcmVhdGVSb290ID0gY3JlYXRlUm9vdCQxO1xuZXhwb3J0cy5maW5kRE9NTm9kZSA9IGZpbmRET01Ob2RlO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmMkMTtcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLmh5ZHJhdGVSb290ID0gaHlkcmF0ZVJvb3QkMTtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBiYXRjaGVkVXBkYXRlcyQxO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBtLmNyZWF0ZVJvb3Q7XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBtLmh5ZHJhdGVSb290O1xufSBlbHNlIHtcbiAgdmFyIGkgPSBtLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbihjLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5jcmVhdGVSb290KGMsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uKGMsIGgsIG8pIHtcbiAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmh5ZHJhdGVSb290KGMsIGgsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IElSdW50aW1lIH0gZnJvbSAnQHJlZmx5L2NvbW1vbi10eXBlcyc7XG5cbmV4cG9ydCBlbnVtIElFTlYge1xuICBQUk9EVUNUSU9OID0gJ3Byb2R1Y3Rpb24nLFxuICBTVEFHSU5HID0gJ3N0YWdpbmcnLFxuICBURVNUID0gJ3Rlc3QnLFxuICBERVZFTE9QTUVOVCA9ICdkZXZlbG9wbWVudCcsXG59XG5cbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gIGNvbnN0IGVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG4gIHJldHVybiBlbnY7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T3NUeXBlID0gKCkgPT4ge1xuICBjb25zdCB0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgY29uc3QgbiA9IG5hdmlnYXRvci5wbGF0Zm9ybTtcbiAgY29uc3QgYSA9IFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnLCAnbWFjT1MnXTtcbiAgY29uc3QgaSA9IFsnV2luMzInLCAnV2luNjQnLCAnV2luZG93cycsICdXaW5DRSddO1xuICBjb25zdCBzID0gWydpUGhvbmUnLCAnaVBhZCcsICdpUG9kJ107XG4gIHJldHVybiBhLmluZGV4T2YobikgIT09IC0xXG4gICAgPyAnT1NYJ1xuICAgIDogcy5pbmRleE9mKG4pICE9PSAtMVxuICAgICAgPyAnSU9TJ1xuICAgICAgOiBpLmluZGV4T2YobikgIT09IC0xXG4gICAgICAgID8gJ1dpbmRvd3MnXG4gICAgICAgIDogL0FuZHJvaWQvLnRlc3QodClcbiAgICAgICAgICA/ICdBbmRyb2lkJ1xuICAgICAgICAgIDogL0xpbnV4Ly50ZXN0KG4pXG4gICAgICAgICAgICA/ICdMaW51eCdcbiAgICAgICAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd1bmFibGUgdG8gZGV0ZWN0IG9zIHR5cGUsIHVzZSBXaW5kb3dzIGFzIGRlZmF1bHQnLCBuLCB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICAgICAgICB9KSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQ2hyb21lID0gKCkgPT4ge1xuICBjb25zdCB0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgY29uc3QgbiA9IHQuaW5jbHVkZXMoJ0Nocm9tZScpICYmIHQuaW5jbHVkZXMoJ1NhZmFyaScpO1xuICBjb25zdCBhID0gdC5pbmNsdWRlcygnRWRnJyk7XG4gIGNvbnN0IGkgPSB0LmluY2x1ZGVzKCdPUFInKTtcbiAgcmV0dXJuIG4gJiYgIWEgJiYgIWk7XG59O1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIEVOVj86IHtcbiAgICAgIEFQSV9VUkw/OiBzdHJpbmc7XG4gICAgICBDT0xMQUJfVVJMPzogc3RyaW5nO1xuICAgICAgU1RBVElDX1BVQkxJQ19FTkRQT0lOVD86IHN0cmluZztcbiAgICAgIFNUQVRJQ19QUklWQVRFX0VORFBPSU5UPzogc3RyaW5nO1xuICAgICAgU1VCU0NSSVBUSU9OX0VOQUJMRUQ/OiBib29sZWFuO1xuICAgICAgQ0FOVkFTX1RFTVBMQVRFX0VOQUJMRUQ/OiBib29sZWFuO1xuICAgICAgU0VOVFJZX0VOQUJMRUQ/OiBib29sZWFuO1xuICAgIH07XG5cbiAgICBpcGNSZW5kZXJlcj86IHtcbiAgICAgIGludm9rZTogKGNoYW5uZWw6IHN0cmluZywgYXJnczogYW55KSA9PiBQcm9taXNlPGFueT47XG4gICAgfTtcblxuICAgIGVsZWN0cm9uRW52Pzoge1xuICAgICAgZ2V0QXBpQmFzZVVybDogKCkgPT4gc3RyaW5nO1xuICAgICAgZ2V0Q29sbGFiVXJsOiAoKSA9PiBzdHJpbmc7XG4gICAgICBnZXRQdWJsaWNTdGF0aWNFbmRwb2ludDogKCkgPT4gc3RyaW5nO1xuICAgICAgZ2V0UHJpdmF0ZVN0YXRpY0VuZHBvaW50OiAoKSA9PiBzdHJpbmc7XG4gICAgfTtcbiAgfVxufVxuXG5sZXQgcnVudGltZTogSVJ1bnRpbWU7XG5cbmV4cG9ydCBjb25zdCBnZXRSdW50aW1lID0gKCkgPT4ge1xuICByZXR1cm4gcnVudGltZTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRSdW50aW1lID0gKHI6IElSdW50aW1lKSA9PiB7XG4gIHJ1bnRpbWUgPSByO1xufTtcblxuZXhwb3J0IGNsYXNzIFJlZmx5RW52IHtcbiAgZ2V0T3NUeXBlKCkge1xuICAgIGNvbnN0IHQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGNvbnN0IG4gPSBuYXZpZ2F0b3IucGxhdGZvcm07XG4gICAgY29uc3QgYSA9IFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnLCAnbWFjT1MnXTtcbiAgICBjb25zdCBpID0gWydXaW4zMicsICdXaW42NCcsICdXaW5kb3dzJywgJ1dpbkNFJ107XG4gICAgY29uc3QgcyA9IFsnaVBob25lJywgJ2lQYWQnLCAnaVBvZCddO1xuICAgIHJldHVybiBhLmluZGV4T2YobikgIT09IC0xXG4gICAgICA/ICdPU1gnXG4gICAgICA6IHMuaW5kZXhPZihuKSAhPT0gLTFcbiAgICAgICAgPyAnSU9TJ1xuICAgICAgICA6IGkuaW5kZXhPZihuKSAhPT0gLTFcbiAgICAgICAgICA/ICdXaW5kb3dzJ1xuICAgICAgICAgIDogL0FuZHJvaWQvLnRlc3QodClcbiAgICAgICAgICAgID8gJ0FuZHJvaWQnXG4gICAgICAgICAgICA6IC9MaW51eC8udGVzdChuKVxuICAgICAgICAgICAgICA/ICdMaW51eCdcbiAgICAgICAgICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndW5hYmxlIHRvIGRldGVjdCBvcyB0eXBlLCB1c2UgV2luZG93cyBhcyBkZWZhdWx0JywgbiwgdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gIH1cbiAgaXNDaHJvbWUoKSB7XG4gICAgY29uc3QgdCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgbiA9IHQuaW5jbHVkZXMoJ0Nocm9tZScpICYmIHQuaW5jbHVkZXMoJ1NhZmFyaScpO1xuICAgIGNvbnN0IGEgPSB0LmluY2x1ZGVzKCdFZGcnKTtcbiAgICBjb25zdCBpID0gdC5pbmNsdWRlcygnT1BSJyk7XG4gICAgcmV0dXJuIG4gJiYgIWEgJiYgIWk7XG4gIH1cblxuICBnZXREZWZhdWx0U2hvcnRjdXRLZXkoKSB7XG4gICAgcmV0dXJuICdiJztcbiAgfVxuXG4gIGdldERlZmF1bHRTZW5kU2hvcnRjdXRLZXkoKSB7XG4gICAgcmV0dXJuICdlbnRlcic7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlZmx5RW52ID0gbmV3IFJlZmx5RW52KCk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIiwgW1wibW9kdWxlXCJdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGZhY3RvcnkobW9kdWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kKTtcbiAgICBnbG9iYWwuYnJvd3NlciA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gIC8qIHdlYmV4dGVuc2lvbi1wb2x5ZmlsbCAtIHYwLjEwLjAgLSBGcmkgQXVnIDEyIDIwMjIgMTk6NDI6NDQgKi9cblxuICAvKiAtKi0gTW9kZTogaW5kZW50LXRhYnMtbW9kZTogbmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG5cbiAgLyogdmltOiBzZXQgc3RzPTIgc3c9MiBldCB0dz04MDogKi9cblxuICAvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gICAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAgICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKCFnbG9iYWxUaGlzLmNocm9tZT8ucnVudGltZT8uaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNjcmlwdCBzaG91bGQgb25seSBiZSBsb2FkZWQgaW4gYSBicm93c2VyIGV4dGVuc2lvbi5cIik7XG4gIH1cblxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuYnJvd3NlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsVGhpcy5icm93c2VyKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGNvbnN0IENIUk9NRV9TRU5EX01FU1NBR0VfQ0FMTEJBQ0tfTk9fUkVTUE9OU0VfTUVTU0FHRSA9IFwiVGhlIG1lc3NhZ2UgcG9ydCBjbG9zZWQgYmVmb3JlIGEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLlwiOyAvLyBXcmFwcGluZyB0aGUgYnVsayBvZiB0aGlzIHBvbHlmaWxsIGluIGEgb25lLXRpbWUtdXNlIGZ1bmN0aW9uIGlzIGEgbWlub3JcbiAgICAvLyBvcHRpbWl6YXRpb24gZm9yIEZpcmVmb3guIFNpbmNlIFNwaWRlcm1vbmtleSBkb2VzIG5vdCBmdWxseSBwYXJzZSB0aGVcbiAgICAvLyBjb250ZW50cyBvZiBhIGZ1bmN0aW9uIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgc2luY2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGFjdHVhbGx5IG5lZWQgdG8gYmUgY2FsbGVkLCB0aGlzIGFsbG93cyB0aGUgcG9seWZpbGwgdG8gYmUgaW5jbHVkZWRcbiAgICAvLyBpbiBGaXJlZm94IG5lYXJseSBmb3IgZnJlZS5cblxuICAgIGNvbnN0IHdyYXBBUElzID0gZXh0ZW5zaW9uQVBJcyA9PiB7XG4gICAgICAvLyBOT1RFOiBhcGlNZXRhZGF0YSBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZW50IG9mIHRoZSBhcGktbWV0YWRhdGEuanNvbiBmaWxlXG4gICAgICAvLyBhdCBidWlsZCB0aW1lIGJ5IHJlcGxhY2luZyB0aGUgZm9sbG93aW5nIFwiaW5jbHVkZVwiIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICAvLyBKU09OIGZpbGUuXG4gICAgICBjb25zdCBhcGlNZXRhZGF0YSA9IHtcbiAgICAgICAgXCJhbGFybXNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjbGVhckFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJvb2ttYXJrc1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDaGlsZHJlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFN1YlRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2VyQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImRpc2FibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlbmFibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuUG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NpbmdEYXRhXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNhY2hlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ29va2llc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZURvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZvcm1EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlSGlzdG9yeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUxvY2FsU3RvcmFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBhc3N3b3Jkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBsdWdpbkRhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbW1hbmRzXCI6IHtcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbnRleHRNZW51c1wiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb29raWVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbENvb2tpZVN0b3Jlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRldnRvb2xzXCI6IHtcbiAgICAgICAgICBcImluc3BlY3RlZFdpbmRvd1wiOiB7XG4gICAgICAgICAgICBcImV2YWxcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDIsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGFuZWxzXCI6IHtcbiAgICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJjcmVhdGVTaWRlYmFyUGFuZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkb3dubG9hZHNcIjoge1xuICAgICAgICAgIFwiY2FuY2VsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZG93bmxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlcmFzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZpbGVJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhdXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRmlsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3VtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgIFwiaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImlzQWxsb3dlZEluY29nbml0b0FjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImhpc3RvcnlcIjoge1xuICAgICAgICAgIFwiYWRkVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRWaXNpdHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpMThuXCI6IHtcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWNjZXB0TGFuZ3VhZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlcIjoge1xuICAgICAgICAgIFwibGF1bmNoV2ViQXV0aEZsb3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGxlXCI6IHtcbiAgICAgICAgICBcInF1ZXJ5U3RhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYW5hZ2VtZW50XCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidW5pbnN0YWxsU2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm5vdGlmaWNhdGlvbnNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQZXJtaXNzaW9uTGV2ZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYWdlQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGVybWlzc2lvbnNcIjoge1xuICAgICAgICAgIFwiY29udGFpbnNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicnVudGltZVwiOiB7XG4gICAgICAgICAgXCJnZXRCYWNrZ3JvdW5kUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBsYXRmb3JtSW5mb1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5PcHRpb25zUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RVcGRhdGVDaGVja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE5hdGl2ZU1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRVbmluc3RhbGxVUkxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJnZXREZXZpY2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50bHlDbG9zZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3RvcmFnZVwiOiB7XG4gICAgICAgICAgXCJsb2NhbFwiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1hbmFnZWRcIjoge1xuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3luY1wiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRhYnNcIjoge1xuICAgICAgICAgIFwiY2FwdHVyZVZpc2libGVUYWJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRpc2NhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkdXBsaWNhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJleGVjdXRlU2NyaXB0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0JhY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0ZvcndhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWdobGlnaHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbnNlcnRDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicXVlcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3BTaXRlc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJOYXZpZ2F0aW9uXCI6IHtcbiAgICAgICAgICBcImdldEFsbEZyYW1lc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZyYW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViUmVxdWVzdFwiOiB7XG4gICAgICAgICAgXCJoYW5kbGVyQmVoYXZpb3JDaGFuZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2luZG93c1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0TGFzdEZvY3VzZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGFwaU1ldGFkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBpLW1ldGFkYXRhLmpzb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIGluIGJyb3dzZXItcG9seWZpbGxcIik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEEgV2Vha01hcCBzdWJjbGFzcyB3aGljaCBjcmVhdGVzIGFuZCBzdG9yZXMgYSB2YWx1ZSBmb3IgYW55IGtleSB3aGljaCBkb2VzXG4gICAgICAgKiBub3QgZXhpc3Qgd2hlbiBhY2Nlc3NlZCwgYnV0IGJlaGF2ZXMgZXhhY3RseSBhcyBhbiBvcmRpbmFyeSBXZWFrTWFwXG4gICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY3JlYXRlSXRlbVxuICAgICAgICogICAgICAgIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSB2YWx1ZSBmb3IgYW55XG4gICAgICAgKiAgICAgICAga2V5IHdoaWNoIGRvZXMgbm90IGV4aXN0LCB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZC4gVGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZXMsIGFzIGl0cyBvbmx5IGFyZ3VtZW50LCB0aGUga2V5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzcyBEZWZhdWx0V2Vha01hcCBleHRlbmRzIFdlYWtNYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihjcmVhdGVJdGVtLCBpdGVtcyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB0aGlzLmNyZWF0ZUl0ZW0oa2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdpdGggYSBgdGhlbmAgbWV0aG9kLCBhbmQgY2FuXG4gICAgICAgKiB0aGVyZWZvcmUgYmUgYXNzdW1lZCB0byBiZWhhdmUgYXMgYSBQcm9taXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdGhlbmFibGUuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBpc1RoZW5hYmxlID0gdmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0XG4gICAgICAgKiB0aGUgZ2l2ZW4gcHJvbWlzZSBiYXNlZCBvbiBob3cgaXQgaXMgY2FsbGVkOlxuICAgICAgICpcbiAgICAgICAqIC0gSWYsIHdoZW4gY2FsbGVkLCBgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yYCBjb250YWlucyBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAqICAgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAgICogLSBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZXhhY3RseSBvbmUgYXJndW1lbnQsIHRoZSBwcm9taXNlIGlzXG4gICAgICAgKiAgIHJlc29sdmVkIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgdG8gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gICAgICAgKiAgIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9taXNlXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBmdW5jdGlvbnMgb2YgYVxuICAgICAgICogICAgICAgIHByb21pc2UuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlc29sdmVcbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlamVjdFxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVqZWN0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIHdyYXBwZWQgbWV0aG9kIHdoaWNoIGhhcyBjcmVhdGVkIHRoZSBjYWxsYmFjay5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmdcbiAgICAgICAqICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIG9ubHkgdGhlIGZpcnN0XG4gICAgICAgKiAgICAgICAgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrLCBhbHRlcm5hdGl2ZWx5IGFuIGFycmF5IG9mIGFsbCB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBhcmd1bWVudHMgaXMgcmVzb2x2ZWQuIEJ5IGRlZmF1bHQsIGlmIHRoZSBjYWxsYmFja1xuICAgICAgICogICAgICAgIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBvbmx5IGEgc2luZ2xlIGFyZ3VtZW50LCB0aGF0IHdpbGwgYmVcbiAgICAgICAqICAgICAgICByZXNvbHZlZCB0byB0aGUgcHJvbWlzZSwgd2hpbGUgYWxsIGFyZ3VtZW50cyB3aWxsIGJlIHJlc29sdmVkIGFzXG4gICAgICAgKiAgICAgICAgYW4gYXJyYXkgaWYgbXVsdGlwbGUgYXJlIGdpdmVuLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgICAqICAgICAgICBUaGUgZ2VuZXJhdGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgbWFrZUNhbGxiYWNrID0gKHByb21pc2UsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uY2FsbGJhY2tBcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnIHx8IGNhbGxiYWNrQXJncy5sZW5ndGggPD0gMSAmJiBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3NbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwbHVyYWxpemVBcmd1bWVudHMgPSBudW1BcmdzID0+IG51bUFyZ3MgPT0gMSA/IFwiYXJndW1lbnRcIiA6IFwiYXJndW1lbnRzXCI7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2Qgd2hpY2ggaXMgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICAgICAgICogICAgICAgIE1ldGFkYXRhIGFib3V0IHRoZSBtZXRob2QgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWluQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIGZld2VyIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5tYXhBcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uLiBJZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKG9iamVjdCwgLi4uKil9XG4gICAgICAgKiAgICAgICBUaGUgZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwQXN5bmNGdW5jdGlvbiA9IChuYW1lLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNGdW5jdGlvbldyYXBwZXIodGFyZ2V0LCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICAvLyBUaGlzIEFQSSBtZXRob2QgaGFzIGN1cnJlbnRseSBubyBjYWxsYmFjayBvbiBDaHJvbWUsIGJ1dCBpdCByZXR1cm4gYSBwcm9taXNlIG9uIEZpcmVmb3gsXG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGUgcG9seWZpbGwgd2lsbCB0cnkgdG8gY2FsbCBpdCB3aXRoIGEgY2FsbGJhY2sgZmlyc3QsIGFuZCBpdCB3aWxsIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIHRvIG5vdCBwYXNzaW5nIHRoZSBjYWxsYmFjayBpZiB0aGUgZmlyc3QgY2FsbCBmYWlscy5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChjYkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IEFQSSBtZXRob2QgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciwgYCArIFwiZmFsbGluZyBiYWNrIHRvIGNhbGwgaXQgd2l0aG91dCBhIGNhbGxiYWNrOiBcIiwgY2JFcnJvcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpOyAvLyBVcGRhdGUgdGhlIEFQSSBtZXRob2QgbWV0YWRhdGEsIHNvIHRoYXQgdGhlIG5leHQgQVBJIGNhbGxzIHdpbGwgbm90IHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdW5zdXBwb3J0ZWQgY2FsbGJhY2sgYW55bW9yZS5cblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubm9DYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLm5vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gZXhpc3RpbmcgbWV0aG9kIG9mIHRoZSB0YXJnZXQgb2JqZWN0LCBzbyB0aGF0IGNhbGxzIHRvIGl0IGFyZVxuICAgICAgICogaW50ZXJjZXB0ZWQgYnkgdGhlIGdpdmVuIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHJlY2VpdmVzLFxuICAgICAgICogYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCB0aGUgb3JpZ2luYWwgYHRhcmdldGAgb2JqZWN0LCBmb2xsb3dlZCBieSBlYWNoIG9mXG4gICAgICAgKiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdCB0aGF0IHRoZSB3cmFwcGVkIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kXG4gICAgICAgKiAgICAgICAgVGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLiBUaGlzIGlzIHVzZWQgYXMgdGhlIHRhcmdldCBvZiB0aGUgUHJveHlcbiAgICAgICAqICAgICAgICBvYmplY3Qgd2hpY2ggaXMgY3JlYXRlZCB0byB3cmFwIHRoZSBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgVGhlIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGluIHBsYWNlIG9mIGEgZGlyZWN0IGludm9jYXRpb25cbiAgICAgICAqICAgICAgICBvZiB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PGZ1bmN0aW9uPn1cbiAgICAgICAqICAgICAgICBBIFByb3h5IG9iamVjdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2hpY2ggaW52b2tlcyB0aGUgZ2l2ZW4gd3JhcHBlclxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwTWV0aG9kID0gKHRhcmdldCwgbWV0aG9kLCB3cmFwcGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkobWV0aG9kLCB7XG4gICAgICAgICAgYXBwbHkodGFyZ2V0TWV0aG9kLCB0aGlzT2JqLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5jYWxsKHRoaXNPYmosIHRhcmdldCwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGhhc093blByb3BlcnR5ID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBvYmplY3QgaW4gYSBQcm94eSB3aGljaCBpbnRlcmNlcHRzIGFuZCB3cmFwcyBjZXJ0YWluIG1ldGhvZHNcbiAgICAgICAqIGJhc2VkIG9uIHRoZSBnaXZlbiBgd3JhcHBlcnNgIGFuZCBgbWV0YWRhdGFgIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0IHRvIHdyYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFt3cmFwcGVycyA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgd3JhcHBlciBmdW5jdGlvbnMgZm9yIHNwZWNpYWwgY2FzZXMuIEFueVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHByZXNlbnQgaW4gdGhpcyBvYmplY3QgdHJlZSBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgdGhlXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZS4gVGhlc2VcbiAgICAgICAqICAgICAgICB3cmFwcGVyIG1ldGhvZHMgYXJlIGludm9rZWQgYXMgZGVzY3JpYmVkIGluIHtAc2VlIHdyYXBNZXRob2R9LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbbWV0YWRhdGEgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIG1ldGFkYXRhIHVzZWQgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZVxuICAgICAgICogICAgICAgIFByb21pc2UtYmFzZWQgd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFzeW5jaHJvbm91cy4gQW55IGZ1bmN0aW9uIGluXG4gICAgICAgKiAgICAgICAgdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlIHdoaWNoIGhhcyBhIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiAgICAgICAgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGBtZXRhZGF0YWAgdHJlZSBpcyByZXBsYWNlZCB3aXRoIGFuXG4gICAgICAgKiAgICAgICAgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbiwgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgKiAgICAgICAge0BzZWUgd3JhcEFzeW5jRnVuY3Rpb259XG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PG9iamVjdD59XG4gICAgICAgKi9cblxuICAgICAgY29uc3Qgd3JhcE9iamVjdCA9ICh0YXJnZXQsIHdyYXBwZXJzID0ge30sIG1ldGFkYXRhID0ge30pID0+IHtcbiAgICAgICAgbGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0ge1xuICAgICAgICAgIGhhcyhwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gY2FjaGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldChwcm94eVRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZVtwcm9wXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2Qgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LiBDaGVjayBpZiB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAgIC8vIGFueSB3cmFwcGluZy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVyc1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNwZWNpYWwtY2FzZSB3cmFwcGVyIGZvciB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXJzW3Byb3BdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIG1ldGhvZCB0aGF0IHdlIGhhdmUgbWV0YWRhdGEgZm9yLiBDcmVhdGUgYVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2Ugd3JhcHBlciBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSB3cmFwQXN5bmNGdW5jdGlvbihwcm9wLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHRoYXQgd2UgZG9uJ3Qga25vdyBvciBjYXJlIGFib3V0LiBSZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgbWV0aG9kLCBib3VuZCB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIChoYXNPd25Qcm9wZXJ0eSh3cmFwcGVycywgcHJvcCkgfHwgaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IHdlIG5lZWQgdG8gZG8gc29tZSB3cmFwcGluZyBmb3IgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgIC8vIG9mLiBDcmVhdGUgYSBzdWItb2JqZWN0IHdyYXBwZXIgZm9yIGl0IHdpdGggdGhlIGFwcHJvcHJpYXRlIGNoaWxkXG4gICAgICAgICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBcIipcIikpIHtcbiAgICAgICAgICAgICAgLy8gV3JhcCBhbGwgcHJvcGVydGllcyBpbiAqIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbXCIqXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55IHdyYXBwaW5nIGZvciB0aGlzIHByb3BlcnR5LFxuICAgICAgICAgICAgICAvLyBzbyBqdXN0IGZvcndhcmQgYWxsIGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2V0KHByb3h5VGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wLCBkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwgZGVzYyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShjYWNoZSwgcHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07IC8vIFBlciBjb250cmFjdCBvZiB0aGUgUHJveHkgQVBJLCB0aGUgXCJnZXRcIiBwcm94eSBoYW5kbGVyIG11c3QgcmV0dXJuIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IGlmIHRoYXQgdmFsdWUgaXMgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZFxuICAgICAgICAvLyBub24tY29uZmlndXJhYmxlLiBGb3IgdGhpcyByZWFzb24sIHdlIGNyZWF0ZSBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBlIHNldCB0byBgdGFyZ2V0YCBpbnN0ZWFkIG9mIHVzaW5nIGB0YXJnZXRgIGRpcmVjdGx5LlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2Fubm90IHJldHVybiBhIGN1c3RvbSBvYmplY3QgZm9yIEFQSXMgdGhhdFxuICAgICAgICAvLyBhcmUgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZCBub24tY29uZmlndXJhYmxlLCBzdWNoIGFzIGBjaHJvbWUuZGV2dG9vbHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcHJveHkgaGFuZGxlcnMgdGhlbXNlbHZlcyB3aWxsIHN0aWxsIHVzZSB0aGUgb3JpZ2luYWwgYHRhcmdldGBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgYHByb3h5VGFyZ2V0YCwgc28gdGhhdCB0aGUgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcmVcbiAgICAgICAgLy8gZGVyZWZlcmVuY2VkIHZpYSB0aGUgb3JpZ2luYWwgdGFyZ2V0cy5cblxuICAgICAgICBsZXQgcHJveHlUYXJnZXQgPSBPYmplY3QuY3JlYXRlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIGhhbmRsZXJzKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzZXQgb2Ygd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IG9iamVjdCwgd2hpY2ggaGFuZGxlc1xuICAgICAgICogd3JhcHBpbmcgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgdGhvc2UgbWVzc2FnZXMgYXJlIHBhc3NlZC5cbiAgICAgICAqXG4gICAgICAgKiBBIHNpbmdsZSB3cmFwcGVyIGlzIGNyZWF0ZWQgZm9yIGVhY2ggbGlzdGVuZXIgZnVuY3Rpb24sIGFuZCBzdG9yZWQgaW4gYVxuICAgICAgICogbWFwLiBTdWJzZXF1ZW50IGNhbGxzIHRvIGBhZGRMaXN0ZW5lcmAsIGBoYXNMaXN0ZW5lcmAsIG9yIGByZW1vdmVMaXN0ZW5lcmBcbiAgICAgICAqIHJldHJpZXZlIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBzbyB0aGF0ICBhdHRlbXB0cyB0byByZW1vdmUgYVxuICAgICAgICogcHJldmlvdXNseS1hZGRlZCBsaXN0ZW5lciB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RGVmYXVsdFdlYWtNYXA8ZnVuY3Rpb24sIGZ1bmN0aW9uPn0gd3JhcHBlck1hcFxuICAgICAgICogICAgICAgIEEgRGVmYXVsdFdlYWtNYXAgb2JqZWN0IHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgZm9yIGEgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24gd2hlbiBvbmUgZG9lcyBub3QgZXhpc3QsIGFuZCByZXRyaWV2ZVxuICAgICAgICogICAgICAgIGFuIGV4aXN0aW5nIG9uZSB3aGVuIGl0IGRvZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBFdmVudCA9IHdyYXBwZXJNYXAgPT4gKHtcbiAgICAgICAgYWRkTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lciwgLi4uYXJncykge1xuICAgICAgICAgIHRhcmdldC5hZGRMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lciksIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0xpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmhhc0xpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvblJlcXVlc3RGaW5pc2hlZFdyYXBwZXJzID0gbmV3IERlZmF1bHRXZWFrTWFwKGxpc3RlbmVyID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBhbiBvblJlcXVlc3RGaW5pc2hlZCBsaXN0ZW5lciBmdW5jdGlvbiBzbyB0aGF0IGl0IHdpbGwgcmV0dXJuIGFcbiAgICAgICAgICogYGdldENvbnRlbnQoKWAgcHJvcGVydHkgd2hpY2ggcmV0dXJucyBhIGBQcm9taXNlYCByYXRoZXIgdGhhbiB1c2luZyBhXG4gICAgICAgICAqIGNhbGxiYWNrIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICAgICAgICAgKiAgICAgICAgVGhlIEhBUiBlbnRyeSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uUmVxdWVzdEZpbmlzaGVkKHJlcSkge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRSZXEgPSB3cmFwT2JqZWN0KHJlcSwge31cbiAgICAgICAgICAvKiB3cmFwcGVycyAqL1xuICAgICAgICAgICwge1xuICAgICAgICAgICAgZ2V0Q29udGVudDoge1xuICAgICAgICAgICAgICBtaW5BcmdzOiAwLFxuICAgICAgICAgICAgICBtYXhBcmdzOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGlzdGVuZXIod3JhcHBlZFJlcSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9uTWVzc2FnZVdyYXBwZXJzID0gbmV3IERlZmF1bHRXZWFrTWFwKGxpc3RlbmVyID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBhIG1lc3NhZ2UgbGlzdGVuZXIgZnVuY3Rpb24gc28gdGhhdCBpdCBtYXkgc2VuZCByZXNwb25zZXMgYmFzZWQgb25cbiAgICAgICAgICogaXRzIHJldHVybiB2YWx1ZSwgcmF0aGVyIHRoYW4gYnkgcmV0dXJuaW5nIGEgc2VudGluZWwgdmFsdWUgYW5kIGNhbGxpbmcgYVxuICAgICAgICAgKiBjYWxsYmFjay4gSWYgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlLCB0aGUgcmVzcG9uc2UgaXNcbiAgICAgICAgICogc2VudCB3aGVuIHRoZSBwcm9taXNlIGVpdGhlciByZXNvbHZlcyBvciByZWplY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICAgICAgICogICAgICAgIFRoZSBtZXNzYWdlIHNlbnQgYnkgdGhlIG90aGVyIGVuZCBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNlbmRlclxuICAgICAgICAgKiAgICAgICAgRGV0YWlscyBhYm91dCB0aGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBzZW5kUmVzcG9uc2VcbiAgICAgICAgICogICAgICAgIEEgY2FsbGJhY2sgd2hpY2gsIHdoZW4gY2FsbGVkIHdpdGggYW4gYXJiaXRyYXJ5IGFyZ3VtZW50LCBzZW5kc1xuICAgICAgICAgKiAgICAgICAgdGhhdCB2YWx1ZSBhcyBhIHJlc3BvbnNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogICAgICAgIFRydWUgaWYgdGhlIHdyYXBwZWQgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCB3aGljaCB3aWxsIGxhdGVyXG4gICAgICAgICAqICAgICAgICB5aWVsZCBhIHJlc3BvbnNlLiBGYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTWVzc2FnZShtZXNzYWdlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkge1xuICAgICAgICAgIGxldCBkaWRDYWxsU2VuZFJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgbGV0IHdyYXBwZWRTZW5kUmVzcG9uc2U7XG4gICAgICAgICAgbGV0IHNlbmRSZXNwb25zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHdyYXBwZWRTZW5kUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyKG1lc3NhZ2UsIHNlbmRlciwgd3JhcHBlZFNlbmRSZXNwb25zZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGlzUmVzdWx0VGhlbmFibGUgPSByZXN1bHQgIT09IHRydWUgJiYgaXNUaGVuYWJsZShyZXN1bHQpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZGlkbid0IHJldHVybmVkIHRydWUgb3IgYSBQcm9taXNlLCBvciBjYWxsZWRcbiAgICAgICAgICAvLyB3cmFwcGVkU2VuZFJlc3BvbnNlIHN5bmNocm9ub3VzbHksIHdlIGNhbiBleGl0IGVhcmxpZXJcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgbm8gcmVzcG9uc2Ugc2VudCBmcm9tIHRoaXMgbGlzdGVuZXIuXG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlICYmICFpc1Jlc3VsdFRoZW5hYmxlICYmICFkaWRDYWxsU2VuZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBBIHNtYWxsIGhlbHBlciB0byBzZW5kIHRoZSBtZXNzYWdlIGlmIHRoZSBwcm9taXNlIHJlc29sdmVzXG4gICAgICAgICAgLy8gYW5kIGFuIGVycm9yIGlmIHRoZSBwcm9taXNlIHJlamVjdHMgKGEgd3JhcHBlZCBzZW5kTWVzc2FnZSBoYXNcbiAgICAgICAgICAvLyB0byB0cmFuc2xhdGUgdGhlIG1lc3NhZ2UgaW50byBhIHJlc29sdmVkIHByb21pc2Ugb3IgYSByZWplY3RlZFxuICAgICAgICAgIC8vIHByb21pc2UpLlxuXG5cbiAgICAgICAgICBjb25zdCBzZW5kUHJvbWlzZWRSZXN1bHQgPSBwcm9taXNlID0+IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihtc2cgPT4ge1xuICAgICAgICAgICAgICAvLyBzZW5kIHRoZSBtZXNzYWdlIHZhbHVlLlxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobXNnKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgLy8gU2VuZCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIGlmIHRoZSByZWplY3RlZCB2YWx1ZVxuICAgICAgICAgICAgICAvLyBpcyBhbiBpbnN0YW5jZSBvZiBlcnJvciwgb3IgdGhlIG9iamVjdCBpdHNlbGYgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBfX21veldlYkV4dGVuc2lvblBvbHlmaWxsUmVqZWN0X186IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIC8vIFByaW50IGFuIGVycm9yIG9uIHRoZSBjb25zb2xlIGlmIHVuYWJsZSB0byBzZW5kIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZW5kIG9uTWVzc2FnZSByZWplY3RlZCByZXBseVwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8gSWYgdGhlIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgc2VuZCB0aGUgcmVzb2x2ZWQgdmFsdWUgYXMgYVxuICAgICAgICAgIC8vIHJlc3VsdCwgb3RoZXJ3aXNlIHdhaXQgdGhlIHByb21pc2UgcmVsYXRlZCB0byB0aGUgd3JhcHBlZFNlbmRSZXNwb25zZVxuICAgICAgICAgIC8vIGNhbGxiYWNrIHRvIHJlc29sdmUgYW5kIHNlbmQgaXQgYXMgYSByZXNwb25zZS5cblxuXG4gICAgICAgICAgaWYgKGlzUmVzdWx0VGhlbmFibGUpIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kUHJvbWlzZWRSZXN1bHQoc2VuZFJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgfSAvLyBMZXQgQ2hyb21lIGtub3cgdGhhdCB0aGUgbGlzdGVuZXIgaXMgcmVwbHlpbmcuXG5cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrID0gKHtcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICByZXNvbHZlXG4gICAgICB9LCByZXBseSkgPT4ge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgIC8vIERldGVjdCB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlbmVycyByZXBsaWVkIHRvIHRoZSBzZW5kTWVzc2FnZSBjYWxsIGFuZCByZXNvbHZlXG4gICAgICAgICAgLy8gdGhlIHByb21pc2UgdG8gdW5kZWZpbmVkIGFzIGluIEZpcmVmb3guXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9pc3N1ZXMvMTMwXG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSA9PT0gQ0hST01FX1NFTkRfTUVTU0FHRV9DQUxMQkFDS19OT19SRVNQT05TRV9NRVNTQUdFKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcGx5ICYmIHJlcGx5Ll9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXykge1xuICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaW50b1xuICAgICAgICAgIC8vIGFuIEVycm9yIGluc3RhbmNlLlxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVwbHkubWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB3cmFwcGVkU2VuZE1lc3NhZ2UgPSAobmFtZSwgbWV0YWRhdGEsIGFwaU5hbWVzcGFjZU9iaiwgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYiA9IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrLmJpbmQobnVsbCwge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkQ2IpO1xuICAgICAgICAgIGFwaU5hbWVzcGFjZU9iai5zZW5kTWVzc2FnZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGF0aWNXcmFwcGVycyA9IHtcbiAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgICBvblJlcXVlc3RGaW5pc2hlZDogd3JhcEV2ZW50KG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgb25NZXNzYWdlOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIG9uTWVzc2FnZUV4dGVybmFsOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgdGFiczoge1xuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDIsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHRpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgY2xlYXI6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHNldDoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXBpTWV0YWRhdGEucHJpdmFjeSA9IHtcbiAgICAgICAgbmV0d29yazoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgc2VydmljZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHdlYnNpdGVzOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdyYXBPYmplY3QoZXh0ZW5zaW9uQVBJcywgc3RhdGljV3JhcHBlcnMsIGFwaU1ldGFkYXRhKTtcbiAgICB9OyAvLyBUaGUgYnVpbGQgcHJvY2VzcyBhZGRzIGEgVU1EIHdyYXBwZXIgYXJvdW5kIHRoaXMgZmlsZSwgd2hpY2ggbWFrZXMgdGhlXG4gICAgLy8gYG1vZHVsZWAgdmFyaWFibGUgYXZhaWxhYmxlLlxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdyYXBBUElzKGNocm9tZSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxUaGlzLmJyb3dzZXI7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1wb2x5ZmlsbC5qcy5tYXBcbiIsIi8vIHNyYy9icm93c2VyLnRzXG5pbXBvcnQgb3JpZ2luYWxCcm93c2VyIGZyb20gXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIjtcbnZhciBicm93c2VyID0gb3JpZ2luYWxCcm93c2VyO1xuXG5leHBvcnQge1xuICBicm93c2VyXG59O1xuIiwiLy8gR2VuZXJhdGVkIHVzaW5nIGBucG0gcnVuIGJ1aWxkYC4gRG8gbm90IGVkaXQuXG5cbnZhciByZWdleCA9IC9eW2Etel0oPzpbXFwuMC05X2EtelxceEI3XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXXxbXFx1RDgwMC1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdKSotKD86W1xceDJEXFwuMC05X2EtelxceEI3XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXXxbXFx1RDgwMC1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdKSokLztcblxudmFyIGlzUG90ZW50aWFsQ3VzdG9tRWxlbWVudE5hbWUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0cmV0dXJuIHJlZ2V4LnRlc3Qoc3RyaW5nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3RlbnRpYWxDdXN0b21FbGVtZW50TmFtZTtcbiIsInZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IGlzUG90ZW50aWFsQ3VzdG9tRWxlbWVudE5hbWUgZnJvbSBcImlzLXBvdGVudGlhbC1jdXN0b20tZWxlbWVudC1uYW1lXCI7XG5mdW5jdGlvbiBjcmVhdGVJc29sYXRlZEVsZW1lbnQob3B0aW9ucykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHsgbmFtZSwgbW9kZSA9IFwiY2xvc2VkXCIsIGNzcywgaXNvbGF0ZUV2ZW50cyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghaXNQb3RlbnRpYWxDdXN0b21FbGVtZW50TmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBcIiR7bmFtZX1cIiBpcyBub3QgYSB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lLiBJdCBtdXN0IGJlIHR3byB3b3JkcyBhbmQga2ViYWItY2FzZSwgd2l0aCBhIGZldyBleGNlcHRpb25zLiBTZWUgc3BlYyBmb3IgbW9yZSBkZXRhaWxzOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jdXN0b20tZWxlbWVudHMuaHRtbCN2YWxpZC1jdXN0b20tZWxlbWVudC1uYW1lYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgY29uc3Qgc2hhZG93ID0gcGFyZW50RWxlbWVudC5hdHRhY2hTaGFkb3coeyBtb2RlIH0pO1xuICAgIGNvbnN0IGlzb2xhdGVkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpO1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImhlYWRcIik7XG4gICAgaWYgKGNzcykge1xuICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAoXCJ1cmxcIiBpbiBjc3MpIHtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB5aWVsZCBmZXRjaChjc3MudXJsKS50aGVuKChyZXMpID0+IHJlcy50ZXh0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3MudGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgaXNvbGF0ZWRFbGVtZW50LmFwcGVuZENoaWxkKGhlYWQpO1xuICAgIGlzb2xhdGVkRWxlbWVudC5hcHBlbmRDaGlsZChib2R5KTtcbiAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoaXNvbGF0ZWRFbGVtZW50KTtcbiAgICBpZiAoaXNvbGF0ZUV2ZW50cykge1xuICAgICAgY29uc3QgZXZlbnRUeXBlcyA9IEFycmF5LmlzQXJyYXkoaXNvbGF0ZUV2ZW50cykgPyBpc29sYXRlRXZlbnRzIDogW1wia2V5ZG93blwiLCBcImtleXVwXCIsIFwia2V5cHJlc3NcIl07XG4gICAgICBldmVudFR5cGVzLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQsXG4gICAgICBzaGFkb3csXG4gICAgICBpc29sYXRlZEVsZW1lbnQ6IGJvZHlcbiAgICB9O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUlzb2xhdGVkRWxlbWVudFxufTtcbiIsImltcG9ydCB7XG4gIGJyb3dzZXJcbn0gZnJvbSBcIi4vY2h1bmstRk5URTJMMjcuanNcIjtcblxuLy8gc3JjL3NhbmRib3gvdXRpbHMvbG9nZ2VyLnRzXG5mdW5jdGlvbiBwcmludChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgaWYgKGltcG9ydC5tZXRhLmVudi5NT0RFID09PSBcInByb2R1Y3Rpb25cIikgcmV0dXJuO1xuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYXJncy5zaGlmdCgpO1xuICAgIG1ldGhvZChgW3d4dF0gJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZChcIlt3eHRdXCIsIC4uLmFyZ3MpO1xuICB9XG59XG52YXIgbG9nZ2VyID0ge1xuICBkZWJ1ZzogKC4uLmFyZ3MpID0+IHByaW50KGNvbnNvbGUuZGVidWcsIC4uLmFyZ3MpLFxuICBsb2c6ICguLi5hcmdzKSA9PiBwcmludChjb25zb2xlLmxvZywgLi4uYXJncyksXG4gIHdhcm46ICguLi5hcmdzKSA9PiBwcmludChjb25zb2xlLndhcm4sIC4uLmFyZ3MpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IHByaW50KGNvbnNvbGUuZXJyb3IsIC4uLmFyZ3MpXG59O1xuXG4vLyBzcmMvY2xpZW50L2NvbnRlbnQtc2NyaXB0cy9jdXN0b20tZXZlbnRzLnRzXG52YXIgV3h0TG9jYXRpb25DaGFuZ2VFdmVudCA9IGNsYXNzIF9XeHRMb2NhdGlvbkNoYW5nZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZXdVcmwsIG9sZFVybCkge1xuICAgIHN1cGVyKF9XeHRMb2NhdGlvbkNoYW5nZUV2ZW50LkVWRU5UX05BTUUsIHt9KTtcbiAgICB0aGlzLm5ld1VybCA9IG5ld1VybDtcbiAgICB0aGlzLm9sZFVybCA9IG9sZFVybDtcbiAgfVxuICBzdGF0aWMgRVZFTlRfTkFNRSA9IGdldFVuaXF1ZUV2ZW50TmFtZShcInd4dDpsb2NhdGlvbmNoYW5nZVwiKTtcbn07XG5mdW5jdGlvbiBnZXRVbmlxdWVFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGNvbnN0IGVudHJ5cG9pbnROYW1lID0gdHlwZW9mIGltcG9ydC5tZXRhLmVudiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiYnVpbGRcIiA6IGltcG9ydC5tZXRhLmVudi5FTlRSWVBPSU5UO1xuICByZXR1cm4gYCR7YnJvd3Nlci5ydW50aW1lLmlkfToke2VudHJ5cG9pbnROYW1lfToke2V2ZW50TmFtZX1gO1xufVxuXG4vLyBzcmMvY2xpZW50L2NvbnRlbnQtc2NyaXB0cy9sb2NhdGlvbi13YXRjaGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbldhdGNoZXIoY3R4KSB7XG4gIGxldCBpbnRlcnZhbDtcbiAgbGV0IG9sZFVybDtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIGxvY2F0aW9uIHdhdGNoZXIgaXMgYWN0aXZlbHkgbG9va2luZyBmb3IgVVJMIGNoYW5nZXMuIElmIGl0J3MgYWxyZWFkeSB3YXRjaGluZyxcbiAgICAgKiB0aGlzIGlzIGEgbm9vcC5cbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgb2xkVXJsID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKTtcbiAgICAgIGludGVydmFsID0gY3R4LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbGV0IG5ld1VybCA9IG5ldyBVUkwobG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChuZXdVcmwuaHJlZiAhPT0gb2xkVXJsLmhyZWYpIHtcbiAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgV3h0TG9jYXRpb25DaGFuZ2VFdmVudChuZXdVcmwsIG9sZFVybCkpO1xuICAgICAgICAgIG9sZFVybCA9IG5ld1VybDtcbiAgICAgICAgfVxuICAgICAgfSwgMWUzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9jbGllbnQvY29udGVudC1zY3JpcHRzL2NvbnRlbnQtc2NyaXB0LWNvbnRleHQudHNcbnZhciBDb250ZW50U2NyaXB0Q29udGV4dCA9IGNsYXNzIF9Db250ZW50U2NyaXB0Q29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnRTY3JpcHROYW1lLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb250ZW50U2NyaXB0TmFtZSA9IGNvbnRlbnRTY3JpcHROYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmICh0aGlzLiNpc1RvcEZyYW1lKSB7XG4gICAgICB0aGlzLiNzdG9wT2xkU2NyaXB0cygpO1xuICAgIH1cbiAgICB0aGlzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jbGlzdGVuRm9yTmV3ZXJTY3JpcHRzKCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIFNDUklQVF9TVEFSVEVEX01FU1NBR0VfVFlQRSA9IFwid3h0OmNvbnRlbnQtc2NyaXB0LXN0YXJ0ZWRcIjtcbiAgI2lzVG9wRnJhbWUgPSB3aW5kb3cuc2VsZiA9PT0gd2luZG93LnRvcDtcbiAgI2Fib3J0Q29udHJvbGxlcjtcbiAgI2xvY2F0aW9uV2F0Y2hlciA9IGNyZWF0ZUxvY2F0aW9uV2F0Y2hlcih0aGlzKTtcbiAgZ2V0IHNpZ25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuICBhYm9ydChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy4jYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XG4gIH1cbiAgZ2V0IGlzSW52YWxpZCgpIHtcbiAgICBpZiAoYnJvd3Nlci5ydW50aW1lLmlkID09IG51bGwpIHtcbiAgICAgIHRoaXMubm90aWZ5SW52YWxpZGF0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnbmFsLmFib3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzSW52YWxpZDtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY29udGVudCBzY3JpcHQncyBjb250ZXh0IGlzIGludmFsaWRhdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoY2IpO1xuICAgKiBjb25zdCByZW1vdmVJbnZhbGlkYXRlZExpc3RlbmVyID0gY3R4Lm9uSW52YWxpZGF0ZWQoKCkgPT4ge1xuICAgKiAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoY2IpO1xuICAgKiB9KVxuICAgKiAvLyAuLi5cbiAgICogcmVtb3ZlSW52YWxpZGF0ZWRMaXN0ZW5lcigpO1xuICAgKi9cbiAgb25JbnZhbGlkYXRlZChjYikge1xuICAgIHRoaXMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlcy4gVXNlZnVsIGlmIHlvdSBoYXZlIGFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgc2hvdWxkbid0IHJ1blxuICAgKiBhZnRlciB0aGUgY29udGV4dCBpcyBleHBpcmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBnZXRWYWx1ZUZyb21TdG9yYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgKiAgIGlmIChjdHguaXNJbnZhbGlkKSByZXR1cm4gY3R4LmJsb2NrKCk7XG4gICAqXG4gICAqICAgLy8gLi4uXG4gICAqIH1cbiAgICovXG4gIGJsb2NrKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0SW50ZXJ2YWxgIHRoYXQgYXV0b21hdGljYWxseSBjbGVhcnMgdGhlIGludGVydmFsIHdoZW4gaW52YWxpZGF0ZWQuXG4gICAqL1xuICBzZXRJbnRlcnZhbChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSBoYW5kbGVyKCk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgdGhpcy5vbkludmFsaWRhdGVkKCgpID0+IGNsZWFySW50ZXJ2YWwoaWQpKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0VGltZW91dGAgdGhhdCBhdXRvbWF0aWNhbGx5IGNsZWFycyB0aGUgaW50ZXJ2YWwgd2hlbiBpbnZhbGlkYXRlZC5cbiAgICovXG4gIHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSBoYW5kbGVyKCk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgdGhpcy5vbkludmFsaWRhdGVkKCgpID0+IGNsZWFyVGltZW91dChpZCkpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRoYXQgYXV0b21hdGljYWxseSBjYW5jZWxzIHRoZSByZXF1ZXN0IHdoZW5cbiAgICogaW52YWxpZGF0ZWQuXG4gICAqL1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZCkgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkludmFsaWRhdGVkKCgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcGVyIGFyb3VuZCBgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRoYXQgYXV0b21hdGljYWxseSBjYW5jZWxzIHRoZSByZXF1ZXN0IHdoZW5cbiAgICogaW52YWxpZGF0ZWQuXG4gICAqL1xuICByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKCguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc2lnbmFsLmFib3J0ZWQpIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMub25JbnZhbGlkYXRlZCgoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYHRhcmdldC5hZGRFdmVudExpc3RlbmVyYCBhbmQgcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lciB3aGVuIHRoZSBjb250ZXh0IGlzIGludmFsaWRhdGVkLlxuICAgKlxuICAgKiBJbmNsdWRlcyBhZGRpdGlvbmFsIGV2ZW50cyB1c2VmdWwgZm9yIGNvbnRlbnQgc2NyaXB0czpcbiAgICpcbiAgICogLSBgXCJ3eHQ6bG9jYXRpb25jaGFuZ2VcImAgLSBUcmlnZ2VyZWQgd2hlbiBIVE1MNSBoaXN0b3J5IG1vZGUgaXMgdXNlZCB0byBjaGFuZ2UgVVJMLiBDb250ZW50XG4gICAqICAgc2NyaXB0cyBhcmUgbm90IHJlbG9hZGVkIHdoZW4gbmF2aWdhdGluZyB0aGlzIHdheSwgc28gdGhpcyBjYW4gYmUgdXNlZCB0byByZXNldCB0aGUgY29udGVudFxuICAgKiAgIHNjcmlwdCBzdGF0ZSBvbiBVUkwgY2hhbmdlLCBvciBydW4gY3VzdG9tIGNvZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGN0eC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInZpc2liaWxpdHljaGFuZ2VcIiwgKCkgPT4ge1xuICAgKiAgIC8vIC4uLlxuICAgKiB9KTtcbiAgICogY3R4LmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwid3h0OmxvY2F0aW9uY2hhbmdlXCIsICgpID0+IHtcbiAgICogICAvLyAuLi5cbiAgICogfSk7XG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlID09PSBcInd4dDpsb2NhdGlvbmNoYW5nZVwiKSB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSB0aGlzLiNsb2NhdGlvbldhdGNoZXIucnVuKCk7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyPy4oXG4gICAgICB0eXBlLnN0YXJ0c1dpdGgoXCJ3eHQ6XCIpID8gZ2V0VW5pcXVlRXZlbnROYW1lKHR5cGUpIDogdHlwZSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEV2ZW50IGRvbid0IG1hdGNoLCBidXQgdGhhdCdzIE9LLCBFdmVudFRhcmdldCBkb2Vzbid0IGFsbG93IGN1c3RvbSB0eXBlcyBpbiB0aGUgY2FsbGJhY2tcbiAgICAgIGhhbmRsZXIsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQWJvcnQgdGhlIGFib3J0IGNvbnRyb2xsZXIgYW5kIGV4ZWN1dGUgYWxsIGBvbkludmFsaWRhdGVkYCBsaXN0ZW5lcnMuXG4gICAqL1xuICBub3RpZnlJbnZhbGlkYXRlZCgpIHtcbiAgICB0aGlzLmFib3J0KFwiQ29udGVudCBzY3JpcHQgY29udGV4dCBpbnZhbGlkYXRlZFwiKTtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgQ29udGVudCBzY3JpcHQgXCIke3RoaXMuY29udGVudFNjcmlwdE5hbWV9XCIgY29udGV4dCBpbnZhbGlkYXRlZGBcbiAgICApO1xuICB9XG4gICNzdG9wT2xkU2NyaXB0cygpIHtcbiAgICB3aW5kb3cucG9zdE1lc3NhZ2UoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IF9Db250ZW50U2NyaXB0Q29udGV4dC5TQ1JJUFRfU1RBUlRFRF9NRVNTQUdFX1RZUEUsXG4gICAgICAgIGNvbnRlbnRTY3JpcHROYW1lOiB0aGlzLmNvbnRlbnRTY3JpcHROYW1lXG4gICAgICB9LFxuICAgICAgXCIqXCJcbiAgICApO1xuICB9XG4gICNsaXN0ZW5Gb3JOZXdlclNjcmlwdHMoKSB7XG4gICAgY29uc3QgY2IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBfQ29udGVudFNjcmlwdENvbnRleHQuU0NSSVBUX1NUQVJURURfTUVTU0FHRV9UWVBFICYmIGV2ZW50LmRhdGE/LmNvbnRlbnRTY3JpcHROYW1lID09PSB0aGlzLmNvbnRlbnRTY3JpcHROYW1lKSB7XG4gICAgICAgIHRoaXMubm90aWZ5SW52YWxpZGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGNiKTtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZWQoKCkgPT4gcmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2IpKTtcbiAgfVxufTtcblxuLy8gc3JjL2NsaWVudC9jb250ZW50LXNjcmlwdHMvdWkvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZUlzb2xhdGVkRWxlbWVudCB9IGZyb20gXCJAd2ViZXh0LWNvcmUvaXNvbGF0ZWQtZWxlbWVudFwiO1xuZnVuY3Rpb24gY3JlYXRlSW50ZWdyYXRlZFVpKGN0eCwgb3B0aW9ucykge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvcHRpb25zLnRhZyB8fCBcImRpdlwiKTtcbiAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXd4dC1pbnRlZ3JhdGVkXCIsIFwiXCIpO1xuICBsZXQgbW91bnRlZCA9IHZvaWQgMDtcbiAgY29uc3QgbW91bnQgPSAoKSA9PiB7XG4gICAgYXBwbHlQb3NpdGlvbih3cmFwcGVyLCB2b2lkIDAsIG9wdGlvbnMpO1xuICAgIG1vdW50VWkod3JhcHBlciwgb3B0aW9ucyk7XG4gICAgbW91bnRlZCA9IG9wdGlvbnMub25Nb3VudD8uKHdyYXBwZXIpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSAoKSA9PiB7XG4gICAgb3B0aW9ucy5vblJlbW92ZT8uKG1vdW50ZWQpO1xuICAgIHdyYXBwZXIucmVtb3ZlKCk7XG4gICAgbW91bnRlZCA9IHZvaWQgMDtcbiAgfTtcbiAgY3R4Lm9uSW52YWxpZGF0ZWQocmVtb3ZlKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbW91bnRlZCgpIHtcbiAgICAgIHJldHVybiBtb3VudGVkO1xuICAgIH0sXG4gICAgd3JhcHBlcixcbiAgICBtb3VudCxcbiAgICByZW1vdmVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZVVpKGN0eCwgb3B0aW9ucykge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXd4dC1pZnJhbWVcIiwgXCJcIik7XG4gIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gIGlmcmFtZS5zcmMgPSBicm93c2VyLnJ1bnRpbWUuZ2V0VVJMKG9wdGlvbnMucGFnZSk7XG4gIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgbGV0IG1vdW50ZWQgPSB2b2lkIDA7XG4gIGNvbnN0IG1vdW50ID0gKCkgPT4ge1xuICAgIGFwcGx5UG9zaXRpb24od3JhcHBlciwgaWZyYW1lLCBvcHRpb25zKTtcbiAgICBtb3VudFVpKHdyYXBwZXIsIG9wdGlvbnMpO1xuICAgIG1vdW50ZWQgPSBvcHRpb25zLm9uTW91bnQ/Lih3cmFwcGVyLCBpZnJhbWUpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSAoKSA9PiB7XG4gICAgb3B0aW9ucy5vblJlbW92ZT8uKG1vdW50ZWQpO1xuICAgIHdyYXBwZXIucmVtb3ZlKCk7XG4gICAgbW91bnRlZCA9IHZvaWQgMDtcbiAgfTtcbiAgY3R4Lm9uSW52YWxpZGF0ZWQocmVtb3ZlKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbW91bnRlZCgpIHtcbiAgICAgIHJldHVybiBtb3VudGVkO1xuICAgIH0sXG4gICAgaWZyYW1lLFxuICAgIHdyYXBwZXIsXG4gICAgbW91bnQsXG4gICAgcmVtb3ZlXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTaGFkb3dSb290VWkoY3R4LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNzcyA9IFtvcHRpb25zLmNzcyA/PyBcIlwiXTtcbiAgaWYgKGN0eC5vcHRpb25zPy5jc3NJbmplY3Rpb25Nb2RlID09PSBcInVpXCIpIHtcbiAgICBjb25zdCBlbnRyeUNzcyA9IGF3YWl0IGxvYWRDc3MoKTtcbiAgICBjc3MucHVzaChlbnRyeUNzcy5yZXBsYWNlQWxsKFwiOnJvb3RcIiwgXCI6aG9zdFwiKSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzb2xhdGVkRWxlbWVudDogdWlDb250YWluZXIsXG4gICAgcGFyZW50RWxlbWVudDogc2hhZG93SG9zdCxcbiAgICBzaGFkb3dcbiAgfSA9IGF3YWl0IGNyZWF0ZUlzb2xhdGVkRWxlbWVudCh7XG4gICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgIGNzczoge1xuICAgICAgdGV4dENvbnRlbnQ6IGNzcy5qb2luKFwiXFxuXCIpLnRyaW0oKVxuICAgIH0sXG4gICAgbW9kZTogb3B0aW9ucy5tb2RlID8/IFwib3BlblwiLFxuICAgIGlzb2xhdGVFdmVudHM6IG9wdGlvbnMuaXNvbGF0ZUV2ZW50c1xuICB9KTtcbiAgc2hhZG93SG9zdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXd4dC1zaGFkb3ctcm9vdFwiLCBcIlwiKTtcbiAgbGV0IG1vdW50ZWQ7XG4gIGNvbnN0IG1vdW50ID0gKCkgPT4ge1xuICAgIG1vdW50VWkoc2hhZG93SG9zdCwgb3B0aW9ucyk7XG4gICAgYXBwbHlQb3NpdGlvbihzaGFkb3dIb3N0LCBzaGFkb3cucXVlcnlTZWxlY3RvcihcImh0bWxcIiksIG9wdGlvbnMpO1xuICAgIG1vdW50ZWQgPSBvcHRpb25zLm9uTW91bnQodWlDb250YWluZXIsIHNoYWRvdywgc2hhZG93SG9zdCk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICgpID0+IHtcbiAgICBvcHRpb25zLm9uUmVtb3ZlPy4obW91bnRlZCk7XG4gICAgc2hhZG93SG9zdC5yZW1vdmUoKTtcbiAgICB3aGlsZSAodWlDb250YWluZXIubGFzdENoaWxkKVxuICAgICAgdWlDb250YWluZXIucmVtb3ZlQ2hpbGQodWlDb250YWluZXIubGFzdENoaWxkKTtcbiAgICBtb3VudGVkID0gdm9pZCAwO1xuICB9O1xuICBjdHgub25JbnZhbGlkYXRlZChyZW1vdmUpO1xuICByZXR1cm4ge1xuICAgIHNoYWRvdyxcbiAgICBzaGFkb3dIb3N0LFxuICAgIHVpQ29udGFpbmVyLFxuICAgIG1vdW50LFxuICAgIHJlbW92ZSxcbiAgICBnZXQgbW91bnRlZCgpIHtcbiAgICAgIHJldHVybiBtb3VudGVkO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5UG9zaXRpb24ocm9vdCwgcG9zaXRpb25lZEVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09IFwiaW5saW5lXCIpIHJldHVybjtcbiAgaWYgKG9wdGlvbnMuekluZGV4ICE9IG51bGwpIHJvb3Quc3R5bGUuekluZGV4ID0gU3RyaW5nKG9wdGlvbnMuekluZGV4KTtcbiAgcm9vdC5zdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICByb290LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICByb290LnN0eWxlLndpZHRoID0gXCIwXCI7XG4gIHJvb3Quc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gIHJvb3Quc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgaWYgKHBvc2l0aW9uZWRFbGVtZW50KSB7XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09IFwib3ZlcmxheVwiKSB7XG4gICAgICBwb3NpdGlvbmVkRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudD8uc3RhcnRzV2l0aChcImJvdHRvbS1cIikpXG4gICAgICAgIHBvc2l0aW9uZWRFbGVtZW50LnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgICAgZWxzZSBwb3NpdGlvbmVkRWxlbWVudC5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudD8uZW5kc1dpdGgoXCItcmlnaHRcIikpXG4gICAgICAgIHBvc2l0aW9uZWRFbGVtZW50LnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICBlbHNlIHBvc2l0aW9uZWRFbGVtZW50LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb25lZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBwb3NpdGlvbmVkRWxlbWVudC5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgIHBvc2l0aW9uZWRFbGVtZW50LnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgICAgcG9zaXRpb25lZEVsZW1lbnQuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgcG9zaXRpb25lZEVsZW1lbnQuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFuY2hvcihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmFuY2hvciA9PSBudWxsKSByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgbGV0IHJlc29sdmVkID0gdHlwZW9mIG9wdGlvbnMuYW5jaG9yID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmFuY2hvcigpIDogb3B0aW9ucy5hbmNob3I7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmVzb2x2ZWQpID8/IHZvaWQgMDtcbiAgcmV0dXJuIHJlc29sdmVkID8/IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1vdW50VWkocm9vdCwgb3B0aW9ucykge1xuICBjb25zdCBhbmNob3IgPSBnZXRBbmNob3Iob3B0aW9ucyk7XG4gIGlmIChhbmNob3IgPT0gbnVsbClcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiRmFpbGVkIHRvIG1vdW50IGNvbnRlbnQgc2NyaXB0IFVJOiBjb3VsZCBub3QgZmluZCBhbmNob3IgZWxlbWVudFwiXG4gICAgKTtcbiAgc3dpdGNoIChvcHRpb25zLmFwcGVuZCkge1xuICAgIGNhc2Ugdm9pZCAwOlxuICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICBhbmNob3IuYXBwZW5kKHJvb3QpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpcnN0XCI6XG4gICAgICBhbmNob3IucHJlcGVuZChyb290KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICBhbmNob3IucmVwbGFjZVdpdGgocm9vdCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYWZ0ZXJcIjpcbiAgICAgIGFuY2hvci5wYXJlbnRFbGVtZW50Py5pbnNlcnRCZWZvcmUocm9vdCwgYW5jaG9yLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmVmb3JlXCI6XG4gICAgICBhbmNob3IucGFyZW50RWxlbWVudD8uaW5zZXJ0QmVmb3JlKHJvb3QsIGFuY2hvcik7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgb3B0aW9ucy5hcHBlbmQoYW5jaG9yLCByb290KTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkQ3NzKCkge1xuICBjb25zdCB1cmwgPSBicm93c2VyLnJ1bnRpbWUuZ2V0VVJMKFxuICAgIGAvY29udGVudC1zY3JpcHRzLyR7aW1wb3J0Lm1ldGEuZW52LkVOVFJZUE9JTlR9LmNzc2BcbiAgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIHJldHVybiBhd2FpdCByZXMudGV4dCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIud2FybihcbiAgICAgIGBGYWlsZWQgdG8gbG9hZCBzdHlsZXMgQCAke3VybH0uIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCB0aGUgc3R5bGVzaGVldCBpbiB5b3VyIGVudHJ5cG9pbnQ/YCxcbiAgICAgIGVyclxuICAgICk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIENvbnRlbnRTY3JpcHRDb250ZXh0LFxuICBjcmVhdGVJZnJhbWVVaSxcbiAgY3JlYXRlSW50ZWdyYXRlZFVpLFxuICBjcmVhdGVTaGFkb3dSb290VWlcbn07XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCJpbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoLnRocm90dGxlJztcbmltcG9ydCB7IEJhY2tncm91bmRNZXNzYWdlLCBJUnVudGltZSB9IGZyb20gJ0ByZWZseS9jb21tb24tdHlwZXMnO1xuXG5leHBvcnQgY29uc3Qgc2VuZFRvQmFja2dyb3VuZCA9IGFzeW5jIChtZXNzYWdlOiBCYWNrZ3JvdW5kTWVzc2FnZSwgbmVlZFJlc3BvbnNlID0gdHJ1ZSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgYnJvd3NlciB9ID0gYXdhaXQgaW1wb3J0KCd3eHQvYnJvd3NlcicpO1xuICAgIGNvbnN0IHdhaXRGb3JSZXNwb25zZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZT8ubmFtZSA9PT0gbWVzc2FnZT8ubmFtZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZW5kVG9CYWNrZ3JvdW5kIHJlc3BvbnNlJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZT8uYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIGF3YWl0IGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZShtZXNzYWdlKTtcblxuICAgIGlmIChuZWVkUmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHdhaXRGb3JSZXNwb25zZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZygnc2VuZFRvQmFja2dyb3VuZCBlcnJvcicsIGVycik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzZW5kVG9TaWRlUGFuZWwgPSBzZW5kVG9CYWNrZ3JvdW5kO1xuXG4vLyBmcm9tIHNpZGVQYW5lbC9iYWNrZ3JvdW5kL2NvbnRlbnQgc2NyaXB0IHRvIHdlYnBhZ2UvY29udGVudCBzY3JpcHRcbmV4cG9ydCBjb25zdCBzZW5kVG9XZWJwYWdlTWFpbldvcmxkID0gYXN5bmMgKFxuICBtZXNzYWdlOiBCYWNrZ3JvdW5kTWVzc2FnZSxcbiAgZnJvbVJ1bnRpbWU6IElSdW50aW1lLFxuICBuZWVkUmVzcG9uc2UgPSB0cnVlLFxuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBicm93c2VyIH0gPSBhd2FpdCBpbXBvcnQoJ3d4dC9icm93c2VyJyk7XG4gICAgY29uc3Qgd2FpdEZvclJlc3BvbnNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NlbmRUb0JhY2tncm91bmQgcmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgICAgIGlmIChyZXNwb25zZT8ubmFtZSA9PT0gbWVzc2FnZT8ubmFtZSkge1xuICAgICAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZT8uYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH0pO1xuXG4gICAgaWYgKFsnZXh0ZW5zaW9uLXNpZGVwYW5lbCcsICdleHRlbnNpb24tYmFja2dyb3VuZCddLmluY2x1ZGVzKGZyb21SdW50aW1lKSkge1xuICAgICAgY29uc3QgdGFicyA9IGF3YWl0IGJyb3dzZXIudGFicy5xdWVyeSh7IGFjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IGFjdGl2ZVRhYklkID0gdGFicz8uWzBdPy5pZDtcbiAgICAgIGlmIChhY3RpdmVUYWJJZCkge1xuICAgICAgICBhd2FpdCBicm93c2VyLnRhYnMuc2VuZE1lc3NhZ2UoYWN0aXZlVGFiSWQsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbVJ1bnRpbWUgPT09ICdleHRlbnNpb24tY3N1aScpIHtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xuICAgIH1cblxuICAgIGlmIChuZWVkUmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHdhaXRGb3JSZXNwb25zZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZygnc2VuZFRvV2VicGFnZU1haW5Xb3JsZCBlcnJvcicsIGVycik7XG4gIH1cbn07XG5cbi8vIGZyb20gd2VicGFnZS9iYWNrZ3JvdW5kL3NpZGUgcGFuZWwvY29udGVudCBzY3JpcHQgdG8gY29udGVudCBzY3JpcHRcbmV4cG9ydCBjb25zdCBzZW5kVG9Db250ZW50U2NyaXB0ID0gc2VuZFRvV2VicGFnZU1haW5Xb3JsZDtcblxuZXhwb3J0IGNvbnN0IHNlbmRNZXNzYWdlOiAobWVzc2FnZTogQmFja2dyb3VuZE1lc3NhZ2UsIG5lZWRSZXNwb25zZT86IGJvb2xlYW4pID0+IFByb21pc2U8YW55PiA9XG4gIHRocm90dGxlKGFzeW5jIChtZXNzYWdlOiBCYWNrZ3JvdW5kTWVzc2FnZSwgbmVlZFJlc3BvbnNlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGZyb21SdW50aW1lID0gbWVzc2FnZT8uc291cmNlO1xuICAgIGxldCBicm93c2VyOiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmcm9tUnVudGltZSAhPT0gJ3dlYicpIHtcbiAgICAgICAgY29uc3QgeyBicm93c2VyOiBfYnJvd3NlciB9ID0gYXdhaXQgaW1wb3J0KCd3eHQvYnJvd3NlcicpO1xuICAgICAgICBicm93c2VyID0gX2Jyb3dzZXI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhaXRGb3JSZXNwb25zZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2VuZFRvQmFja2dyb3VuZCByZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgICBpZiAocmVzcG9uc2U/Lm5hbWUgPT09IG1lc3NhZ2U/Lm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChicm93c2VyPy5ydW50aW1lPy5vbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tUnVudGltZSAhPT0gJ2V4dGVuc2lvbi1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgICBpZiAod2luZG93Py5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZT8uY3VycmVudFRhcmdldCA/IHJlc3BvbnNlPy5kYXRhPy5ib2R5IDogcmVzcG9uc2U/LmJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYnJvd3Nlcj8ucnVudGltZT8ub25NZXNzYWdlKSB7XG4gICAgICAgICAgYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbVJ1bnRpbWUgIT09ICdleHRlbnNpb24tYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICBpZiAod2luZG93Py5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXG4gICAgICAgIFsnZXh0ZW5zaW9uLXNpZGVwYW5lbCcsICdleHRlbnNpb24tYmFja2dyb3VuZCcsICdleHRlbnNpb24tcG9wdXAnXS5pbmNsdWRlcyhmcm9tUnVudGltZSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgYnJvd3Nlci50YWJzLnF1ZXJ5KHsgYWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBhY3RpdmVUYWJJZCA9IHRhYnM/LlswXT8uaWQ7XG4gICAgICAgIGlmIChhY3RpdmVUYWJJZCkge1xuICAgICAgICAgIGF3YWl0IGJyb3dzZXIudGFicy5zZW5kTWVzc2FnZShhY3RpdmVUYWJJZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDov5nph4zlhbzlrrkgc2lkZXBhbmVsIOe7mSBiYWNrZ3JvdW5kIOWPkea2iOaBr1xuICAgICAgICBpZiAoYnJvd3Nlcj8ucnVudGltZT8uc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgICBhd2FpdCBicm93c2VyLnJ1bnRpbWUuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZnJvbVJ1bnRpbWUgPT09ICdleHRlbnNpb24tY3N1aScpIHtcbiAgICAgICAgaWYgKHdpbmRvdz8ucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicm93c2VyPy5ydW50aW1lPy5zZW5kTWVzc2FnZSkge1xuICAgICAgICAgIGF3YWl0IGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmcm9tUnVudGltZSA9PT0gJ3dlYicpIHtcbiAgICAgICAgaWYgKHdpbmRvdz8ucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmVlZFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHdhaXRGb3JSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdzZW5kTWVzc2FnZSBlcnJvcicsIGVycik7XG4gICAgfVxuICB9LCAzMDApO1xuXG5leHBvcnQgY29uc3Qgb25NZXNzYWdlID0gYXN5bmMgKF9jYWxsYmFjazogKG1lc3NhZ2U6IGFueSkgPT4gdm9pZCwgZnJvbVJ1bnRpbWU6IElSdW50aW1lKSA9PiB7XG4gIGNvbnN0IGNhbGxiYWNrID0gX2NhbGxiYWNrO1xuICBjb25zdCB3aW5kb3dDYWxsYmFjayA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgY2FsbGJhY2soZXZlbnQ/LmRhdGEpO1xuICB9O1xuICBsZXQgYnJvd3NlcjogYW55O1xuICBpZiAoZnJvbVJ1bnRpbWUgIT09ICd3ZWInKSB7XG4gICAgY29uc3QgeyBicm93c2VyOiBfYnJvd3NlciB9ID0gYXdhaXQgaW1wb3J0KCd3eHQvYnJvd3NlcicpO1xuICAgIGJyb3dzZXIgPSBfYnJvd3NlcjtcbiAgfVxuXG4gIGlmIChbJ2V4dGVuc2lvbi1zaWRlcGFuZWwnLCAnZXh0ZW5zaW9uLWJhY2tncm91bmQnLCAnZXh0ZW5zaW9uLXBvcHVwJ10uaW5jbHVkZXMoZnJvbVJ1bnRpbWUpKSB7XG4gICAgYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoZnJvbVJ1bnRpbWUgPT09ICdleHRlbnNpb24tY3N1aScpIHtcbiAgICAvLyAxLiBjc3VpIC0+IGNzdWkgMi4gYmFja2dyb3VuZC9zaWRlcGFuZWwgLT4gY3N1aVxuICAgIGlmICh3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd2luZG93Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmIChicm93c2VyPy5ydW50aW1lPy5vbk1lc3NhZ2UpIHtcbiAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmcm9tUnVudGltZSA9PT0gJ3dlYicpIHtcbiAgICBpZiAod2luZG93Py5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHdpbmRvd0NhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChbJ2V4dGVuc2lvbi1zaWRlcGFuZWwnLCAnZXh0ZW5zaW9uLWJhY2tncm91bmQnLCAnZXh0ZW5zaW9uLXBvcHVwJ10uaW5jbHVkZXMoZnJvbVJ1bnRpbWUpKSB7XG4gICAgICBicm93c2VyLnJ1bnRpbWUub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGZyb21SdW50aW1lID09PSAnZXh0ZW5zaW9uLWNzdWknKSB7XG4gICAgICBpZiAod2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd2luZG93Q2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJvd3Nlcj8ucnVudGltZT8ub25NZXNzYWdlKSB7XG4gICAgICAgIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbVJ1bnRpbWUgPT09ICd3ZWInKSB7XG4gICAgICBpZiAod2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd2luZG93Q2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIEFyYzkwIEluY1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKlxuICogVGhpcyBjb2RlIGlzIGhlYXZpbHkgYmFzZWQgb24gQXJjOTAncyByZWFkYWJpbGl0eS5qcyAoMS43LjEpIHNjcmlwdFxuICogYXZhaWxhYmxlIGF0OiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXJjOTBsYWJzLXJlYWRhYmlsaXR5XG4gKi9cblxuLyoqXG4gKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge0hUTUxEb2N1bWVudH0gZG9jICAgICBUaGUgZG9jdW1lbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFJlYWRhYmlsaXR5KGRvYywgb3B0aW9ucykge1xuICAvLyBJbiBzb21lIG9sZGVyIHZlcnNpb25zLCBwZW9wbGUgcGFzc2VkIGEgVVJJIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gQ29wZTpcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBkb2MgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gIH0gZWxzZSBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHRvIFJlYWRhYmlsaXR5IGNvbnN0cnVjdG9yIHNob3VsZCBiZSBhIGRvY3VtZW50IG9iamVjdC5cIik7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fZG9jID0gZG9jO1xuICB0aGlzLl9kb2NKU0RPTVBhcnNlciA9IHRoaXMuX2RvYy5maXJzdENoaWxkLl9fSlNET01QYXJzZXJfXztcbiAgdGhpcy5fYXJ0aWNsZVRpdGxlID0gbnVsbDtcbiAgdGhpcy5fYXJ0aWNsZUJ5bGluZSA9IG51bGw7XG4gIHRoaXMuX2FydGljbGVEaXIgPSBudWxsO1xuICB0aGlzLl9hcnRpY2xlU2l0ZU5hbWUgPSBudWxsO1xuICB0aGlzLl9hdHRlbXB0cyA9IFtdO1xuXG4gIC8vIENvbmZpZ3VyYWJsZSBvcHRpb25zXG4gIHRoaXMuX2RlYnVnID0gISFvcHRpb25zLmRlYnVnO1xuICB0aGlzLl9tYXhFbGVtc1RvUGFyc2UgPSBvcHRpb25zLm1heEVsZW1zVG9QYXJzZSB8fCB0aGlzLkRFRkFVTFRfTUFYX0VMRU1TX1RPX1BBUlNFO1xuICB0aGlzLl9uYlRvcENhbmRpZGF0ZXMgPSBvcHRpb25zLm5iVG9wQ2FuZGlkYXRlcyB8fCB0aGlzLkRFRkFVTFRfTl9UT1BfQ0FORElEQVRFUztcbiAgdGhpcy5fY2hhclRocmVzaG9sZCA9IG9wdGlvbnMuY2hhclRocmVzaG9sZCB8fCB0aGlzLkRFRkFVTFRfQ0hBUl9USFJFU0hPTEQ7XG4gIHRoaXMuX2NsYXNzZXNUb1ByZXNlcnZlID0gdGhpcy5DTEFTU0VTX1RPX1BSRVNFUlZFLmNvbmNhdChvcHRpb25zLmNsYXNzZXNUb1ByZXNlcnZlIHx8IFtdKTtcbiAgdGhpcy5fa2VlcENsYXNzZXMgPSAhIW9wdGlvbnMua2VlcENsYXNzZXM7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBvcHRpb25zLnNlcmlhbGl6ZXIgfHwgZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICB9O1xuICB0aGlzLl9kaXNhYmxlSlNPTkxEID0gISFvcHRpb25zLmRpc2FibGVKU09OTEQ7XG4gIHRoaXMuX2FsbG93ZWRWaWRlb1JlZ2V4ID0gb3B0aW9ucy5hbGxvd2VkVmlkZW9SZWdleCB8fCB0aGlzLlJFR0VYUFMudmlkZW9zO1xuXG4gIC8vIFN0YXJ0IHdpdGggYWxsIGZsYWdzIHNldFxuICB0aGlzLl9mbGFncyA9IHRoaXMuRkxBR19TVFJJUF9VTkxJS0VMWVMgfFxuICAgICAgICAgICAgICAgIHRoaXMuRkxBR19XRUlHSFRfQ0xBU1NFUyB8XG4gICAgICAgICAgICAgICAgdGhpcy5GTEFHX0NMRUFOX0NPTkRJVElPTkFMTFk7XG5cblxuICAvLyBDb250cm9sIHdoZXRoZXIgbG9nIG1lc3NhZ2VzIGFyZSBzZW50IHRvIHRoZSBjb25zb2xlXG4gIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgIGxldCBsb2dOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gbm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgcmV0dXJuIGAke25vZGUubm9kZU5hbWV9IChcIiR7bm9kZS50ZXh0Q29udGVudH1cIilgO1xuICAgICAgfVxuICAgICAgbGV0IGF0dHJQYWlycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzIHx8IFtdLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHJldHVybiBgJHthdHRyLm5hbWV9PVwiJHthdHRyLnZhbHVlfVwiYDtcbiAgICAgIH0pLmpvaW4oXCIgXCIpO1xuICAgICAgcmV0dXJuIGA8JHtub2RlLmxvY2FsTmFtZX0gJHthdHRyUGFpcnN9PmA7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsZXQgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzLCBhcmcgPT4ge1xuICAgICAgICAgIGlmIChhcmcgJiYgYXJnLm5vZGVUeXBlID09IHRoaXMuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nTm9kZShhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJncy51bnNoaWZ0KFwiUmVhZGVyOiAoUmVhZGFiaWxpdHkpXCIpO1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1bXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLyogZ2xvYmFsIGR1bXAgKi9cbiAgICAgICAgdmFyIG1zZyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gKHggJiYgeC5ub2RlTmFtZSkgPyBsb2dOb2RlKHgpIDogeDtcbiAgICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgICAgIGR1bXAoXCJSZWFkZXI6IChSZWFkYWJpbGl0eSkgXCIgKyBtc2cgKyBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMubG9nID0gZnVuY3Rpb24gKCkge307XG4gIH1cbn1cblxuUmVhZGFiaWxpdHkucHJvdG90eXBlID0ge1xuICBGTEFHX1NUUklQX1VOTElLRUxZUzogMHgxLFxuICBGTEFHX1dFSUdIVF9DTEFTU0VTOiAweDIsXG4gIEZMQUdfQ0xFQU5fQ09ORElUSU9OQUxMWTogMHg0LFxuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlXG4gIEVMRU1FTlRfTk9ERTogMSxcbiAgVEVYVF9OT0RFOiAzLFxuXG4gIC8vIE1heCBudW1iZXIgb2Ygbm9kZXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGFyc2VyLiBEZWZhdWx0OiAwIChubyBsaW1pdClcbiAgREVGQVVMVF9NQVhfRUxFTVNfVE9fUEFSU0U6IDAsXG5cbiAgLy8gVGhlIG51bWJlciBvZiB0b3AgY2FuZGlkYXRlcyB0byBjb25zaWRlciB3aGVuIGFuYWx5c2luZyBob3dcbiAgLy8gdGlnaHQgdGhlIGNvbXBldGl0aW9uIGlzIGFtb25nIGNhbmRpZGF0ZXMuXG4gIERFRkFVTFRfTl9UT1BfQ0FORElEQVRFUzogNSxcblxuICAvLyBFbGVtZW50IHRhZ3MgdG8gc2NvcmUgYnkgZGVmYXVsdC5cbiAgREVGQVVMVF9UQUdTX1RPX1NDT1JFOiBcInNlY3Rpb24saDIsaDMsaDQsaDUsaDYscCx0ZCxwcmVcIi50b1VwcGVyQ2FzZSgpLnNwbGl0KFwiLFwiKSxcblxuICAvLyBUaGUgZGVmYXVsdCBudW1iZXIgb2YgY2hhcnMgYW4gYXJ0aWNsZSBtdXN0IGhhdmUgaW4gb3JkZXIgdG8gcmV0dXJuIGEgcmVzdWx0XG4gIERFRkFVTFRfQ0hBUl9USFJFU0hPTEQ6IDUwMCxcblxuICAvLyBBbGwgb2YgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgaW4gdXNlIHdpdGhpbiByZWFkYWJpbGl0eS5cbiAgLy8gRGVmaW5lZCB1cCBoZXJlIHNvIHdlIGRvbid0IGluc3RhbnRpYXRlIHRoZW0gcmVwZWF0ZWRseSBpbiBsb29wcy5cbiAgUkVHRVhQUzoge1xuICAgIC8vIE5PVEU6IFRoZXNlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBkdXBsaWNhdGVkIGluXG4gICAgLy8gUmVhZGFiaWxpdHktcmVhZGVyYWJsZS5qcy4gUGxlYXNlIGtlZXAgYm90aCBjb3BpZXMgaW4gc3luYy5cbiAgICB1bmxpa2VseUNhbmRpZGF0ZXM6IC8tYWQtfGFpMmh0bWx8YmFubmVyfGJyZWFkY3J1bWJzfGNvbWJ4fGNvbW1lbnR8Y29tbXVuaXR5fGNvdmVyLXdyYXB8ZGlzcXVzfGV4dHJhfGZvb3RlcnxnZHByfGhlYWRlcnxsZWdlbmRzfG1lbnV8cmVsYXRlZHxyZW1hcmt8cmVwbGllc3xyc3N8c2hvdXRib3h8c2lkZWJhcnxza3lzY3JhcGVyfHNvY2lhbHxzcG9uc29yfHN1cHBsZW1lbnRhbHxhZC1icmVha3xhZ2VnYXRlfHBhZ2luYXRpb258cGFnZXJ8cG9wdXB8eW9tLXJlbW90ZS9pLFxuICAgIG9rTWF5YmVJdHNBQ2FuZGlkYXRlOiAvYW5kfGFydGljbGV8Ym9keXxjb2x1bW58Y29udGVudHxtYWlufHNoYWRvdy9pLFxuXG4gICAgcG9zaXRpdmU6IC9hcnRpY2xlfGJvZHl8Y29udGVudHxlbnRyeXxoZW50cnl8aC1lbnRyeXxtYWlufHBhZ2V8cGFnaW5hdGlvbnxwb3N0fHRleHR8YmxvZ3xzdG9yeS9pLFxuICAgIG5lZ2F0aXZlOiAvLWFkLXxoaWRkZW58XmhpZCR8IGhpZCR8IGhpZCB8XmhpZCB8YmFubmVyfGNvbWJ4fGNvbW1lbnR8Y29tLXxjb250YWN0fGZvb3R8Zm9vdGVyfGZvb3Rub3RlfGdkcHJ8bWFzdGhlYWR8bWVkaWF8bWV0YXxvdXRicmFpbnxwcm9tb3xyZWxhdGVkfHNjcm9sbHxzaGFyZXxzaG91dGJveHxzaWRlYmFyfHNreXNjcmFwZXJ8c3BvbnNvcnxzaG9wcGluZ3x0YWdzfHRvb2x8d2lkZ2V0L2ksXG4gICAgZXh0cmFuZW91czogL3ByaW50fGFyY2hpdmV8Y29tbWVudHxkaXNjdXNzfGVbXFwtXT9tYWlsfHNoYXJlfHJlcGx5fGFsbHxsb2dpbnxzaWdufHNpbmdsZXx1dGlsaXR5L2ksXG4gICAgYnlsaW5lOiAvYnlsaW5lfGF1dGhvcnxkYXRlbGluZXx3cml0dGVuYnl8cC1hdXRob3IvaSxcbiAgICByZXBsYWNlRm9udHM6IC88KFxcLz8pZm9udFtePl0qPi9naSxcbiAgICBub3JtYWxpemU6IC9cXHN7Mix9L2csXG4gICAgdmlkZW9zOiAvXFwvXFwvKHd3d1xcLik/KChkYWlseW1vdGlvbnx5b3V0dWJlfHlvdXR1YmUtbm9jb29raWV8cGxheWVyXFwudmltZW98dlxcLnFxKVxcLmNvbXwoYXJjaGl2ZXx1cGxvYWRcXC53aWtpbWVkaWEpXFwub3JnfHBsYXllclxcLnR3aXRjaFxcLnR2KS9pLFxuICAgIHNoYXJlRWxlbWVudHM6IC8oXFxifF8pKHNoYXJlfHNoYXJlZGFkZHkpKFxcYnxfKS9pLFxuICAgIG5leHRMaW5rOiAvKG5leHR8d2VpdGVyfGNvbnRpbnVlfD4oW15cXHxdfCQpfMK7KFteXFx8XXwkKSkvaSxcbiAgICBwcmV2TGluazogLyhwcmV2fGVhcmx8b2xkfG5ld3w8fMKrKS9pLFxuICAgIHRva2VuaXplOiAvXFxXKy9nLFxuICAgIHdoaXRlc3BhY2U6IC9eXFxzKiQvLFxuICAgIGhhc0NvbnRlbnQ6IC9cXFMkLyxcbiAgICBoYXNoVXJsOiAvXiMuKy8sXG4gICAgc3Jjc2V0VXJsOiAvKFxcUyspKFxccytbXFxkLl0rW3h3XSk/KFxccyooPzosfCQpKS9nLFxuICAgIGI2NERhdGFVcmw6IC9eZGF0YTpcXHMqKFteXFxzOyxdKylcXHMqO1xccypiYXNlNjRcXHMqLC9pLFxuICAgIC8vIENvbW1hcyBhcyB1c2VkIGluIExhdGluLCBTaW5kaGksIENoaW5lc2UgYW5kIHZhcmlvdXMgb3RoZXIgc2NyaXB0cy5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbW1hI0NvbW1hX3ZhcmlhbnRzXG4gICAgY29tbWFzOiAvXFx1MDAyQ3xcXHUwNjBDfFxcdUZFNTB8XFx1RkUxMHxcXHVGRTExfFxcdTJFNDF8XFx1MkUzNHxcXHUyRTMyfFxcdUZGMEMvZyxcbiAgICAvLyBTZWU6IGh0dHBzOi8vc2NoZW1hLm9yZy9BcnRpY2xlXG4gICAganNvbkxkQXJ0aWNsZVR5cGVzOiAvXkFydGljbGV8QWR2ZXJ0aXNlckNvbnRlbnRBcnRpY2xlfE5ld3NBcnRpY2xlfEFuYWx5c2lzTmV3c0FydGljbGV8QXNrUHVibGljTmV3c0FydGljbGV8QmFja2dyb3VuZE5ld3NBcnRpY2xlfE9waW5pb25OZXdzQXJ0aWNsZXxSZXBvcnRhZ2VOZXdzQXJ0aWNsZXxSZXZpZXdOZXdzQXJ0aWNsZXxSZXBvcnR8U2F0aXJpY2FsQXJ0aWNsZXxTY2hvbGFybHlBcnRpY2xlfE1lZGljYWxTY2hvbGFybHlBcnRpY2xlfFNvY2lhbE1lZGlhUG9zdGluZ3xCbG9nUG9zdGluZ3xMaXZlQmxvZ1Bvc3Rpbmd8RGlzY3Vzc2lvbkZvcnVtUG9zdGluZ3xUZWNoQXJ0aWNsZXxBUElSZWZlcmVuY2UkL1xuICB9LFxuXG4gIFVOTElLRUxZX1JPTEVTOiBbIFwibWVudVwiLCBcIm1lbnViYXJcIiwgXCJjb21wbGVtZW50YXJ5XCIsIFwibmF2aWdhdGlvblwiLCBcImFsZXJ0XCIsIFwiYWxlcnRkaWFsb2dcIiwgXCJkaWFsb2dcIiBdLFxuXG4gIERJVl9UT19QX0VMRU1TOiBuZXcgU2V0KFsgXCJCTE9DS1FVT1RFXCIsIFwiRExcIiwgXCJESVZcIiwgXCJJTUdcIiwgXCJPTFwiLCBcIlBcIiwgXCJQUkVcIiwgXCJUQUJMRVwiLCBcIlVMXCIgXSksXG5cbiAgQUxURVJfVE9fRElWX0VYQ0VQVElPTlM6IFtcIkRJVlwiLCBcIkFSVElDTEVcIiwgXCJTRUNUSU9OXCIsIFwiUFwiXSxcblxuICBQUkVTRU5UQVRJT05BTF9BVFRSSUJVVEVTOiBbIFwiYWxpZ25cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmdjb2xvclwiLCBcImJvcmRlclwiLCBcImNlbGxwYWRkaW5nXCIsIFwiY2VsbHNwYWNpbmdcIiwgXCJmcmFtZVwiLCBcImhzcGFjZVwiLCBcInJ1bGVzXCIsIFwic3R5bGVcIiwgXCJ2YWxpZ25cIiwgXCJ2c3BhY2VcIiBdLFxuXG4gIERFUFJFQ0FURURfU0laRV9BVFRSSUJVVEVfRUxFTVM6IFsgXCJUQUJMRVwiLCBcIlRIXCIsIFwiVERcIiwgXCJIUlwiLCBcIlBSRVwiIF0sXG5cbiAgLy8gVGhlIGNvbW1lbnRlZCBvdXQgZWxlbWVudHMgcXVhbGlmeSBhcyBwaHJhc2luZyBjb250ZW50IGJ1dCB0ZW5kIHRvIGJlXG4gIC8vIHJlbW92ZWQgYnkgcmVhZGFiaWxpdHkgd2hlbiBwdXQgaW50byBwYXJhZ3JhcGhzLCBzbyB3ZSBpZ25vcmUgdGhlbSBoZXJlLlxuICBQSFJBU0lOR19FTEVNUzogW1xuICAgIC8vIFwiQ0FOVkFTXCIsIFwiSUZSQU1FXCIsIFwiU1ZHXCIsIFwiVklERU9cIixcbiAgICBcIkFCQlJcIiwgXCJBVURJT1wiLCBcIkJcIiwgXCJCRE9cIiwgXCJCUlwiLCBcIkJVVFRPTlwiLCBcIkNJVEVcIiwgXCJDT0RFXCIsIFwiREFUQVwiLFxuICAgIFwiREFUQUxJU1RcIiwgXCJERk5cIiwgXCJFTVwiLCBcIkVNQkVEXCIsIFwiSVwiLCBcIklNR1wiLCBcIklOUFVUXCIsIFwiS0JEXCIsIFwiTEFCRUxcIixcbiAgICBcIk1BUktcIiwgXCJNQVRIXCIsIFwiTUVURVJcIiwgXCJOT1NDUklQVFwiLCBcIk9CSkVDVFwiLCBcIk9VVFBVVFwiLCBcIlBST0dSRVNTXCIsIFwiUVwiLFxuICAgIFwiUlVCWVwiLCBcIlNBTVBcIiwgXCJTQ1JJUFRcIiwgXCJTRUxFQ1RcIiwgXCJTTUFMTFwiLCBcIlNQQU5cIiwgXCJTVFJPTkdcIiwgXCJTVUJcIixcbiAgICBcIlNVUFwiLCBcIlRFWFRBUkVBXCIsIFwiVElNRVwiLCBcIlZBUlwiLCBcIldCUlwiXG4gIF0sXG5cbiAgLy8gVGhlc2UgYXJlIHRoZSBjbGFzc2VzIHRoYXQgcmVhZGFiaWxpdHkgc2V0cyBpdHNlbGYuXG4gIENMQVNTRVNfVE9fUFJFU0VSVkU6IFsgXCJwYWdlXCIgXSxcblxuICAvLyBUaGVzZSBhcmUgdGhlIGxpc3Qgb2YgSFRNTCBlbnRpdGllcyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZC5cbiAgSFRNTF9FU0NBUEVfTUFQOiB7XG4gICAgXCJsdFwiOiBcIjxcIixcbiAgICBcImd0XCI6IFwiPlwiLFxuICAgIFwiYW1wXCI6IFwiJlwiLFxuICAgIFwicXVvdFwiOiAnXCInLFxuICAgIFwiYXBvc1wiOiBcIidcIixcbiAgfSxcblxuICAvKipcbiAgICogUnVuIGFueSBwb3N0LXByb2Nlc3MgbW9kaWZpY2F0aW9ucyB0byBhcnRpY2xlIGNvbnRlbnQgYXMgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgKiovXG4gIF9wb3N0UHJvY2Vzc0NvbnRlbnQ6IGZ1bmN0aW9uKGFydGljbGVDb250ZW50KSB7XG4gICAgLy8gUmVhZGFiaWxpdHkgY2Fubm90IG9wZW4gcmVsYXRpdmUgdXJpcyBzbyB3ZSBjb252ZXJ0IHRoZW0gdG8gYWJzb2x1dGUgdXJpcy5cbiAgICB0aGlzLl9maXhSZWxhdGl2ZVVyaXMoYXJ0aWNsZUNvbnRlbnQpO1xuXG4gICAgdGhpcy5fc2ltcGxpZnlOZXN0ZWRFbGVtZW50cyhhcnRpY2xlQ29udGVudCk7XG5cbiAgICBpZiAoIXRoaXMuX2tlZXBDbGFzc2VzKSB7XG4gICAgICAvLyBSZW1vdmUgY2xhc3Nlcy5cbiAgICAgIHRoaXMuX2NsZWFuQ2xhc3NlcyhhcnRpY2xlQ29udGVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGEgTm9kZUxpc3QsIGNhbGxzIGBmaWx0ZXJGbmAgZm9yIGVhY2ggbm9kZSBhbmQgcmVtb3ZlcyBub2RlXG4gICAqIGlmIGZ1bmN0aW9uIHJldHVybmVkIGB0cnVlYC5cbiAgICpcbiAgICogSWYgZnVuY3Rpb24gaXMgbm90IHBhc3NlZCwgcmVtb3ZlcyBhbGwgdGhlIG5vZGVzIGluIG5vZGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIE5vZGVMaXN0IG5vZGVMaXN0IFRoZSBub2RlcyB0byBvcGVyYXRlIG9uXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBmaWx0ZXJGbiB0aGUgZnVuY3Rpb24gdG8gdXNlIGFzIGEgZmlsdGVyXG4gICAqIEByZXR1cm4gdm9pZFxuICAgKi9cbiAgX3JlbW92ZU5vZGVzOiBmdW5jdGlvbihub2RlTGlzdCwgZmlsdGVyRm4pIHtcbiAgICAvLyBBdm9pZCBldmVyIG9wZXJhdGluZyBvbiBsaXZlIG5vZGUgbGlzdHMuXG4gICAgaWYgKHRoaXMuX2RvY0pTRE9NUGFyc2VyICYmIG5vZGVMaXN0Ll9pc0xpdmVOb2RlTGlzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IHBhc3MgbGl2ZSBub2RlIGxpc3RzIHRvIF9yZW1vdmVOb2Rlc1wiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IG5vZGVMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuLmNhbGwodGhpcywgbm9kZSwgaSwgbm9kZUxpc3QpKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhIE5vZGVMaXN0LCBhbmQgY2FsbHMgX3NldE5vZGVUYWcgZm9yIGVhY2ggbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIE5vZGVMaXN0IG5vZGVMaXN0IFRoZSBub2RlcyB0byBvcGVyYXRlIG9uXG4gICAqIEBwYXJhbSBTdHJpbmcgbmV3VGFnTmFtZSB0aGUgbmV3IHRhZyBuYW1lIHRvIHVzZVxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVRhZ3M6IGZ1bmN0aW9uKG5vZGVMaXN0LCBuZXdUYWdOYW1lKSB7XG4gICAgLy8gQXZvaWQgZXZlciBvcGVyYXRpbmcgb24gbGl2ZSBub2RlIGxpc3RzLlxuICAgIGlmICh0aGlzLl9kb2NKU0RPTVBhcnNlciAmJiBub2RlTGlzdC5faXNMaXZlTm9kZUxpc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCBwYXNzIGxpdmUgbm9kZSBsaXN0cyB0byBfcmVwbGFjZU5vZGVUYWdzXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICAgIHRoaXMuX3NldE5vZGVUYWcobm9kZSwgbmV3VGFnTmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYSBOb2RlTGlzdCwgd2hpY2ggZG9lc24ndCBuYXRpdmVseSBmdWxseSBpbXBsZW1lbnQgdGhlIEFycmF5XG4gICAqIGludGVyZmFjZS5cbiAgICpcbiAgICogRm9yIGNvbnZlbmllbmNlLCB0aGUgY3VycmVudCBvYmplY3QgY29udGV4dCBpcyBhcHBsaWVkIHRvIHRoZSBwcm92aWRlZFxuICAgKiBpdGVyYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIE5vZGVMaXN0IG5vZGVMaXN0IFRoZSBOb2RlTGlzdC5cbiAgICogQHBhcmFtICBGdW5jdGlvbiBmbiAgICAgICBUaGUgaXRlcmF0ZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICBfZm9yRWFjaE5vZGU6IGZ1bmN0aW9uKG5vZGVMaXN0LCBmbikge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobm9kZUxpc3QsIGZuLCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGEgTm9kZUxpc3QsIGFuZCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgdGhhdCBwYXNzZXNcbiAgICogdGhlIHN1cHBsaWVkIHRlc3QgZnVuY3Rpb25cbiAgICpcbiAgICogRm9yIGNvbnZlbmllbmNlLCB0aGUgY3VycmVudCBvYmplY3QgY29udGV4dCBpcyBhcHBsaWVkIHRvIHRoZSBwcm92aWRlZFxuICAgKiB0ZXN0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIE5vZGVMaXN0IG5vZGVMaXN0IFRoZSBOb2RlTGlzdC5cbiAgICogQHBhcmFtICBGdW5jdGlvbiBmbiAgICAgICBUaGUgdGVzdCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICBfZmluZE5vZGU6IGZ1bmN0aW9uKG5vZGVMaXN0LCBmbikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKG5vZGVMaXN0LCBmbiwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhIE5vZGVMaXN0LCByZXR1cm4gdHJ1ZSBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIGl0ZXJhdGVcbiAgICogZnVuY3Rpb24gY2FsbHMgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEZvciBjb252ZW5pZW5jZSwgdGhlIGN1cnJlbnQgb2JqZWN0IGNvbnRleHQgaXMgYXBwbGllZCB0byB0aGVcbiAgICogcHJvdmlkZWQgaXRlcmF0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICBOb2RlTGlzdCBub2RlTGlzdCBUaGUgTm9kZUxpc3QuXG4gICAqIEBwYXJhbSAgRnVuY3Rpb24gZm4gICAgICAgVGhlIGl0ZXJhdGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gQm9vbGVhblxuICAgKi9cbiAgX3NvbWVOb2RlOiBmdW5jdGlvbihub2RlTGlzdCwgZm4pIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChub2RlTGlzdCwgZm4sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYSBOb2RlTGlzdCwgcmV0dXJuIHRydWUgaWYgYWxsIG9mIHRoZSBwcm92aWRlZCBpdGVyYXRlXG4gICAqIGZ1bmN0aW9uIGNhbGxzIHJldHVybiB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEZvciBjb252ZW5pZW5jZSwgdGhlIGN1cnJlbnQgb2JqZWN0IGNvbnRleHQgaXMgYXBwbGllZCB0byB0aGVcbiAgICogcHJvdmlkZWQgaXRlcmF0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICBOb2RlTGlzdCBub2RlTGlzdCBUaGUgTm9kZUxpc3QuXG4gICAqIEBwYXJhbSAgRnVuY3Rpb24gZm4gICAgICAgVGhlIGl0ZXJhdGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gQm9vbGVhblxuICAgKi9cbiAgX2V2ZXJ5Tm9kZTogZnVuY3Rpb24obm9kZUxpc3QsIGZuKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKG5vZGVMaXN0LCBmbiwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbmNhdCBhbGwgbm9kZWxpc3RzIHBhc3NlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqIEByZXR1cm4gLi4uTm9kZUxpc3RcbiAgICogQHJldHVybiBBcnJheVxuICAgKi9cbiAgX2NvbmNhdE5vZGVMaXN0czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBub2RlTGlzdHMgPSBhcmdzLm1hcChmdW5jdGlvbihsaXN0KSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChsaXN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgbm9kZUxpc3RzKTtcbiAgfSxcblxuICBfZ2V0QWxsTm9kZXNXaXRoVGFnOiBmdW5jdGlvbihub2RlLCB0YWdOYW1lcykge1xuICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIHJldHVybiBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwodGFnTmFtZXMuam9pbihcIixcIikpO1xuICAgIH1cbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCB0YWdOYW1lcy5tYXAoZnVuY3Rpb24odGFnKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IEFycmF5LmZyb20oY29sbGVjdGlvbik7XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBjbGFzcz1cIlwiIGF0dHJpYnV0ZSBmcm9tIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGdpdmVuXG4gICAqIHN1YnRyZWUsIGV4Y2VwdCB0aG9zZSB0aGF0IG1hdGNoIENMQVNTRVNfVE9fUFJFU0VSVkUgYW5kXG4gICAqIHRoZSBjbGFzc2VzVG9QcmVzZXJ2ZSBhcnJheSBmcm9tIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIEVsZW1lbnRcbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICBfY2xlYW5DbGFzc2VzOiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGNsYXNzZXNUb1ByZXNlcnZlID0gdGhpcy5fY2xhc3Nlc1RvUHJlc2VydmU7XG4gICAgdmFyIGNsYXNzTmFtZSA9IChub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihjbHMpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXNUb1ByZXNlcnZlLmluZGV4T2YoY2xzKSAhPSAtMTtcbiAgICAgIH0pXG4gICAgICAuam9pbihcIiBcIik7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgfVxuXG4gICAgZm9yIChub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICB0aGlzLl9jbGVhbkNsYXNzZXMobm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBlYWNoIDxhPiBhbmQgPGltZz4gdXJpIGluIHRoZSBnaXZlbiBlbGVtZW50IHRvIGFuIGFic29sdXRlIFVSSSxcbiAgICogaWdub3JpbmcgI3JlZiBVUklzLlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIF9maXhSZWxhdGl2ZVVyaXM6IGZ1bmN0aW9uKGFydGljbGVDb250ZW50KSB7XG4gICAgdmFyIGJhc2VVUkkgPSB0aGlzLl9kb2MuYmFzZVVSSTtcbiAgICB2YXIgZG9jdW1lbnRVUkkgPSB0aGlzLl9kb2MuZG9jdW1lbnRVUkk7XG4gICAgZnVuY3Rpb24gdG9BYnNvbHV0ZVVSSSh1cmkpIHtcbiAgICAgIC8vIExlYXZlIGhhc2ggbGlua3MgYWxvbmUgaWYgdGhlIGJhc2UgVVJJIG1hdGNoZXMgdGhlIGRvY3VtZW50IFVSSTpcbiAgICAgIGlmIChiYXNlVVJJID09IGRvY3VtZW50VVJJICYmIHVyaS5jaGFyQXQoMCkgPT0gXCIjXCIpIHtcbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCByZXNvbHZlIGFnYWluc3QgYmFzZSBVUkk6XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmksIGJhc2VVUkkpLmhyZWY7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZywganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsOlxuICAgICAgfVxuICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG5cbiAgICB2YXIgbGlua3MgPSB0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoYXJ0aWNsZUNvbnRlbnQsIFtcImFcIl0pO1xuICAgIHRoaXMuX2ZvckVhY2hOb2RlKGxpbmtzLCBmdW5jdGlvbihsaW5rKSB7XG4gICAgICB2YXIgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIGlmIChocmVmKSB7XG4gICAgICAgIC8vIFJlbW92ZSBsaW5rcyB3aXRoIGphdmFzY3JpcHQ6IFVSSXMsIHNpbmNlXG4gICAgICAgIC8vIHRoZXkgd29uJ3Qgd29yayBhZnRlciBzY3JpcHRzIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhZ2UuXG4gICAgICAgIGlmIChocmVmLmluZGV4T2YoXCJqYXZhc2NyaXB0OlwiKSA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBsaW5rIG9ubHkgY29udGFpbnMgc2ltcGxlIHRleHQgY29udGVudCwgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHRleHQgbm9kZVxuICAgICAgICAgIGlmIChsaW5rLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGxpbmsuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gdGhpcy5URVhUX05PREUpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fZG9jLmNyZWF0ZVRleHROb2RlKGxpbmsudGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgbGluay5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0ZXh0LCBsaW5rKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxpbmsgaGFzIG11bHRpcGxlIGNoaWxkcmVuLCB0aGV5IHNob3VsZCBhbGwgYmUgcHJlc2VydmVkXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgd2hpbGUgKGxpbmsuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGluay5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmsucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGFpbmVyLCBsaW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHRvQWJzb2x1dGVVUkkoaHJlZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbWVkaWFzID0gdGhpcy5fZ2V0QWxsTm9kZXNXaXRoVGFnKGFydGljbGVDb250ZW50LCBbXG4gICAgICBcImltZ1wiLCBcInBpY3R1cmVcIiwgXCJmaWd1cmVcIiwgXCJ2aWRlb1wiLCBcImF1ZGlvXCIsIFwic291cmNlXCJcbiAgICBdKTtcblxuICAgIHRoaXMuX2ZvckVhY2hOb2RlKG1lZGlhcywgZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgIHZhciBzcmMgPSBtZWRpYS5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICB2YXIgcG9zdGVyID0gbWVkaWEuZ2V0QXR0cmlidXRlKFwicG9zdGVyXCIpO1xuICAgICAgdmFyIHNyY3NldCA9IG1lZGlhLmdldEF0dHJpYnV0ZShcInNyY3NldFwiKTtcblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBtZWRpYS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdG9BYnNvbHV0ZVVSSShzcmMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc3Rlcikge1xuICAgICAgICBtZWRpYS5zZXRBdHRyaWJ1dGUoXCJwb3N0ZXJcIiwgdG9BYnNvbHV0ZVVSSShwb3N0ZXIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICB2YXIgbmV3U3Jjc2V0ID0gc3Jjc2V0LnJlcGxhY2UodGhpcy5SRUdFWFBTLnNyY3NldFVybCwgZnVuY3Rpb24oXywgcDEsIHAyLCBwMykge1xuICAgICAgICAgIHJldHVybiB0b0Fic29sdXRlVVJJKHAxKSArIChwMiB8fCBcIlwiKSArIHAzO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZWRpYS5zZXRBdHRyaWJ1dGUoXCJzcmNzZXRcIiwgbmV3U3Jjc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBfc2ltcGxpZnlOZXN0ZWRFbGVtZW50czogZnVuY3Rpb24oYXJ0aWNsZUNvbnRlbnQpIHtcbiAgICB2YXIgbm9kZSA9IGFydGljbGVDb250ZW50O1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgJiYgW1wiRElWXCIsIFwiU0VDVElPTlwiXS5pbmNsdWRlcyhub2RlLnRhZ05hbWUpICYmICEobm9kZS5pZCAmJiBub2RlLmlkLnN0YXJ0c1dpdGgoXCJyZWFkYWJpbGl0eVwiKSkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRWxlbWVudFdpdGhvdXRDb250ZW50KG5vZGUpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzU2luZ2xlVGFnSW5zaWRlRWxlbWVudChub2RlLCBcIkRJVlwiKSB8fCB0aGlzLl9oYXNTaW5nbGVUYWdJbnNpZGVFbGVtZW50KG5vZGUsIFwiU0VDVElPTlwiKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0ubmFtZSwgbm9kZS5hdHRyaWJ1dGVzW2ldLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjaGlsZCwgbm9kZSk7XG4gICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSB0aGlzLl9nZXROZXh0Tm9kZShub2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJ0aWNsZSB0aXRsZSBhcyBhbiBIMS5cbiAgICpcbiAgICogQHJldHVybiBzdHJpbmdcbiAgICoqL1xuICBfZ2V0QXJ0aWNsZVRpdGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5fZG9jO1xuICAgIHZhciBjdXJUaXRsZSA9IFwiXCI7XG4gICAgdmFyIG9yaWdUaXRsZSA9IFwiXCI7XG5cbiAgICB0cnkge1xuICAgICAgY3VyVGl0bGUgPSBvcmlnVGl0bGUgPSBkb2MudGl0bGUudHJpbSgpO1xuXG4gICAgICAvLyBJZiB0aGV5IGhhZCBhbiBlbGVtZW50IHdpdGggaWQgXCJ0aXRsZVwiIGluIHRoZWlyIEhUTUxcbiAgICAgIGlmICh0eXBlb2YgY3VyVGl0bGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIGN1clRpdGxlID0gb3JpZ1RpdGxlID0gdGhpcy5fZ2V0SW5uZXJUZXh0KGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdKTtcbiAgICB9IGNhdGNoIChlKSB7LyogaWdub3JlIGV4Y2VwdGlvbnMgc2V0dGluZyB0aGUgdGl0bGUuICovfVxuXG4gICAgdmFyIHRpdGxlSGFkSGllcmFyY2hpY2FsU2VwYXJhdG9ycyA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHdvcmRDb3VudChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoL1xccysvKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHNlcGFyYXRvciBpbiB0aGUgdGl0bGUsIGZpcnN0IHJlbW92ZSB0aGUgZmluYWwgcGFydFxuICAgIGlmICgoLyBbXFx8XFwtXFxcXFxcLz7Cu10gLykudGVzdChjdXJUaXRsZSkpIHtcbiAgICAgIHRpdGxlSGFkSGllcmFyY2hpY2FsU2VwYXJhdG9ycyA9IC8gW1xcXFxcXC8+wrtdIC8udGVzdChjdXJUaXRsZSk7XG4gICAgICBjdXJUaXRsZSA9IG9yaWdUaXRsZS5yZXBsYWNlKC8oLiopW1xcfFxcLVxcXFxcXC8+wrtdIC4qL2dpLCBcIiQxXCIpO1xuXG4gICAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHRpdGxlIGlzIHRvbyBzaG9ydCAoMyB3b3JkcyBvciBmZXdlciksIHJlbW92ZVxuICAgICAgLy8gdGhlIGZpcnN0IHBhcnQgaW5zdGVhZDpcbiAgICAgIGlmICh3b3JkQ291bnQoY3VyVGl0bGUpIDwgMylcbiAgICAgICAgY3VyVGl0bGUgPSBvcmlnVGl0bGUucmVwbGFjZSgvW15cXHxcXC1cXFxcXFwvPsK7XSpbXFx8XFwtXFxcXFxcLz7Cu10oLiopL2dpLCBcIiQxXCIpO1xuICAgIH0gZWxzZSBpZiAoY3VyVGl0bGUuaW5kZXhPZihcIjogXCIpICE9PSAtMSkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbiBoZWFkaW5nIGNvbnRhaW5pbmcgdGhpcyBleGFjdCBzdHJpbmcsIHNvIHdlXG4gICAgICAvLyBjb3VsZCBhc3N1bWUgaXQncyB0aGUgZnVsbCB0aXRsZS5cbiAgICAgIHZhciBoZWFkaW5ncyA9IHRoaXMuX2NvbmNhdE5vZGVMaXN0cyhcbiAgICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaDFcIiksXG4gICAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImgyXCIpXG4gICAgICApO1xuICAgICAgdmFyIHRyaW1tZWRUaXRsZSA9IGN1clRpdGxlLnRyaW0oKTtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuX3NvbWVOb2RlKGhlYWRpbmdzLCBmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgIHJldHVybiBoZWFkaW5nLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdHJpbW1lZFRpdGxlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0LCBsZXQncyBleHRyYWN0IHRoZSB0aXRsZSBvdXQgb2YgdGhlIG9yaWdpbmFsIHRpdGxlIHN0cmluZy5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY3VyVGl0bGUgPSBvcmlnVGl0bGUuc3Vic3RyaW5nKG9yaWdUaXRsZS5sYXN0SW5kZXhPZihcIjpcIikgKyAxKTtcblxuICAgICAgICAvLyBJZiB0aGUgdGl0bGUgaXMgbm93IHRvbyBzaG9ydCwgdHJ5IHRoZSBmaXJzdCBjb2xvbiBpbnN0ZWFkOlxuICAgICAgICBpZiAod29yZENvdW50KGN1clRpdGxlKSA8IDMpIHtcbiAgICAgICAgICBjdXJUaXRsZSA9IG9yaWdUaXRsZS5zdWJzdHJpbmcob3JpZ1RpdGxlLmluZGV4T2YoXCI6XCIpICsgMSk7XG4gICAgICAgICAgLy8gQnV0IGlmIHdlIGhhdmUgdG9vIG1hbnkgd29yZHMgYmVmb3JlIHRoZSBjb2xvbiB0aGVyZSdzIHNvbWV0aGluZyB3ZWlyZFxuICAgICAgICAgIC8vIHdpdGggdGhlIHRpdGxlcyBhbmQgdGhlIEggdGFncyBzbyBsZXQncyBqdXN0IHVzZSB0aGUgb3JpZ2luYWwgdGl0bGUgaW5zdGVhZFxuICAgICAgICB9IGVsc2UgaWYgKHdvcmRDb3VudChvcmlnVGl0bGUuc3Vic3RyKDAsIG9yaWdUaXRsZS5pbmRleE9mKFwiOlwiKSkpID4gNSkge1xuICAgICAgICAgIGN1clRpdGxlID0gb3JpZ1RpdGxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJUaXRsZS5sZW5ndGggPiAxNTAgfHwgY3VyVGl0bGUubGVuZ3RoIDwgMTUpIHtcbiAgICAgIHZhciBoT25lcyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImgxXCIpO1xuXG4gICAgICBpZiAoaE9uZXMubGVuZ3RoID09PSAxKVxuICAgICAgICBjdXJUaXRsZSA9IHRoaXMuX2dldElubmVyVGV4dChoT25lc1swXSk7XG4gICAgfVxuXG4gICAgY3VyVGl0bGUgPSBjdXJUaXRsZS50cmltKCkucmVwbGFjZSh0aGlzLlJFR0VYUFMubm9ybWFsaXplLCBcIiBcIik7XG4gICAgLy8gSWYgd2Ugbm93IGhhdmUgNCB3b3JkcyBvciBmZXdlciBhcyBvdXIgdGl0bGUsIGFuZCBlaXRoZXIgbm9cbiAgICAvLyAnaGllcmFyY2hpY2FsJyBzZXBhcmF0b3JzIChcXCwgLywgPiBvciDCuykgd2VyZSBmb3VuZCBpbiB0aGUgb3JpZ2luYWxcbiAgICAvLyB0aXRsZSBvciB3ZSBkZWNyZWFzZWQgdGhlIG51bWJlciBvZiB3b3JkcyBieSBtb3JlIHRoYW4gMSB3b3JkLCB1c2VcbiAgICAvLyB0aGUgb3JpZ2luYWwgdGl0bGUuXG4gICAgdmFyIGN1clRpdGxlV29yZENvdW50ID0gd29yZENvdW50KGN1clRpdGxlKTtcbiAgICBpZiAoY3VyVGl0bGVXb3JkQ291bnQgPD0gNCAmJlxuICAgICAgICAoIXRpdGxlSGFkSGllcmFyY2hpY2FsU2VwYXJhdG9ycyB8fFxuICAgICAgICAgY3VyVGl0bGVXb3JkQ291bnQgIT0gd29yZENvdW50KG9yaWdUaXRsZS5yZXBsYWNlKC9bXFx8XFwtXFxcXFxcLz7Cu10rL2csIFwiXCIpKSAtIDEpKSB7XG4gICAgICBjdXJUaXRsZSA9IG9yaWdUaXRsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VyVGl0bGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIEhUTUwgZG9jdW1lbnQgZm9yIHJlYWRhYmlsaXR5IHRvIHNjcmFwZSBpdC5cbiAgICogVGhpcyBpbmNsdWRlcyB0aGluZ3MgbGlrZSBzdHJpcHBpbmcgamF2YXNjcmlwdCwgQ1NTLCBhbmQgaGFuZGxpbmcgdGVycmlibGUgbWFya3VwLlxuICAgKlxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICoqL1xuICBfcHJlcERvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5fZG9jO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBzdHlsZSB0YWdzIGluIGhlYWRcbiAgICB0aGlzLl9yZW1vdmVOb2Rlcyh0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoZG9jLCBbXCJzdHlsZVwiXSkpO1xuXG4gICAgaWYgKGRvYy5ib2R5KSB7XG4gICAgICB0aGlzLl9yZXBsYWNlQnJzKGRvYy5ib2R5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBsYWNlTm9kZVRhZ3ModGhpcy5fZ2V0QWxsTm9kZXNXaXRoVGFnKGRvYywgW1wiZm9udFwiXSksIFwiU1BBTlwiKTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIG5leHQgbm9kZSwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gbm9kZSwgYW5kIGlnbm9yaW5nXG4gICAqIHdoaXRlc3BhY2UgaW4gYmV0d2Vlbi4gSWYgdGhlIGdpdmVuIG5vZGUgaXMgYW4gZWxlbWVudCwgdGhlIHNhbWUgbm9kZSBpc1xuICAgKiByZXR1cm5lZC5cbiAgICovXG4gIF9uZXh0Tm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbmV4dCA9IG5vZGU7XG4gICAgd2hpbGUgKG5leHRcbiAgICAgICAgJiYgKG5leHQubm9kZVR5cGUgIT0gdGhpcy5FTEVNRU5UX05PREUpXG4gICAgICAgICYmIHRoaXMuUkVHRVhQUy53aGl0ZXNwYWNlLnRlc3QobmV4dC50ZXh0Q29udGVudCkpIHtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgMiBvciBtb3JlIHN1Y2Nlc3NpdmUgPGJyPiBlbGVtZW50cyB3aXRoIGEgc2luZ2xlIDxwPi5cbiAgICogV2hpdGVzcGFjZSBiZXR3ZWVuIDxicj4gZWxlbWVudHMgYXJlIGlnbm9yZWQuIEZvciBleGFtcGxlOlxuICAgKiAgIDxkaXY+Zm9vPGJyPmJhcjxicj4gPGJyPjxicj5hYmM8L2Rpdj5cbiAgICogd2lsbCBiZWNvbWU6XG4gICAqICAgPGRpdj5mb288YnI+YmFyPHA+YWJjPC9wPjwvZGl2PlxuICAgKi9cbiAgX3JlcGxhY2VCcnM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdGhpcy5fZm9yRWFjaE5vZGUodGhpcy5fZ2V0QWxsTm9kZXNXaXRoVGFnKGVsZW0sIFtcImJyXCJdKSwgZnVuY3Rpb24oYnIpIHtcbiAgICAgIHZhciBuZXh0ID0gYnIubmV4dFNpYmxpbmc7XG5cbiAgICAgIC8vIFdoZXRoZXIgMiBvciBtb3JlIDxicj4gZWxlbWVudHMgaGF2ZSBiZWVuIGZvdW5kIGFuZCByZXBsYWNlZCB3aXRoIGFcbiAgICAgIC8vIDxwPiBibG9jay5cbiAgICAgIHZhciByZXBsYWNlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiB3ZSBmaW5kIGEgPGJyPiBjaGFpbiwgcmVtb3ZlIHRoZSA8YnI+cyB1bnRpbCB3ZSBoaXQgYW5vdGhlciBub2RlXG4gICAgICAvLyBvciBub24td2hpdGVzcGFjZS4gVGhpcyBsZWF2ZXMgYmVoaW5kIHRoZSBmaXJzdCA8YnI+IGluIHRoZSBjaGFpblxuICAgICAgLy8gKHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIDxwPiBsYXRlcikuXG4gICAgICB3aGlsZSAoKG5leHQgPSB0aGlzLl9uZXh0Tm9kZShuZXh0KSkgJiYgKG5leHQudGFnTmFtZSA9PSBcIkJSXCIpKSB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGJyU2libGluZyA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgIG5leHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXh0KTtcbiAgICAgICAgbmV4dCA9IGJyU2libGluZztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIDxicj4gY2hhaW4sIHJlcGxhY2UgdGhlIHJlbWFpbmluZyA8YnI+IHdpdGggYSA8cD4uIEFkZFxuICAgICAgLy8gYWxsIHNpYmxpbmcgbm9kZXMgYXMgY2hpbGRyZW4gb2YgdGhlIDxwPiB1bnRpbCB3ZSBoaXQgYW5vdGhlciA8YnI+XG4gICAgICAvLyBjaGFpbi5cbiAgICAgIGlmIChyZXBsYWNlZCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgYnIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocCwgYnIpO1xuXG4gICAgICAgIG5leHQgPSBwLm5leHRTaWJsaW5nO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIC8vIElmIHdlJ3ZlIGhpdCBhbm90aGVyIDxicj48YnI+LCB3ZSdyZSBkb25lIGFkZGluZyBjaGlsZHJlbiB0byB0aGlzIDxwPi5cbiAgICAgICAgICBpZiAobmV4dC50YWdOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgdmFyIG5leHRFbGVtID0gdGhpcy5fbmV4dE5vZGUobmV4dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAobmV4dEVsZW0gJiYgbmV4dEVsZW0udGFnTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5faXNQaHJhc2luZ0NvbnRlbnQobmV4dCkpXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSB0aGlzIG5vZGUgYSBjaGlsZCBvZiB0aGUgbmV3IDxwPi5cbiAgICAgICAgICB2YXIgc2libGluZyA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcC5hcHBlbmRDaGlsZChuZXh0KTtcbiAgICAgICAgICBuZXh0ID0gc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChwLmxhc3RDaGlsZCAmJiB0aGlzLl9pc1doaXRlc3BhY2UocC5sYXN0Q2hpbGQpKSB7XG4gICAgICAgICAgcC5yZW1vdmVDaGlsZChwLmxhc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC5wYXJlbnROb2RlLnRhZ05hbWUgPT09IFwiUFwiKVxuICAgICAgICAgIHRoaXMuX3NldE5vZGVUYWcocC5wYXJlbnROb2RlLCBcIkRJVlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBfc2V0Tm9kZVRhZzogZnVuY3Rpb24gKG5vZGUsIHRhZykge1xuICAgIHRoaXMubG9nKFwiX3NldE5vZGVUYWdcIiwgbm9kZSwgdGFnKTtcbiAgICBpZiAodGhpcy5fZG9jSlNET01QYXJzZXIpIHtcbiAgICAgIG5vZGUubG9jYWxOYW1lID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBub2RlLnRhZ05hbWUgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciByZXBsYWNlbWVudCA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgcmVwbGFjZW1lbnQuYXBwZW5kQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudCwgbm9kZSk7XG4gICAgaWYgKG5vZGUucmVhZGFiaWxpdHkpXG4gICAgICByZXBsYWNlbWVudC5yZWFkYWJpbGl0eSA9IG5vZGUucmVhZGFiaWxpdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVwbGFjZW1lbnQuc2V0QXR0cmlidXRlKG5vZGUuYXR0cmlidXRlc1tpXS5uYW1lLCBub2RlLmF0dHJpYnV0ZXNbaV0udmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgLyogaXQncyBwb3NzaWJsZSBmb3Igc2V0QXR0cmlidXRlKCkgdG8gdGhyb3cgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAqIGlzbid0IGEgdmFsaWQgWE1MIE5hbWUuIFN1Y2ggYXR0cmlidXRlcyBjYW4gaG93ZXZlciBiZSBwYXJzZWQgZnJvbVxuICAgICAgICAgKiBzb3VyY2UgaW4gSFRNTCBkb2NzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy80Mjc1LFxuICAgICAgICAgKiBzbyB3ZSBjYW4gaGl0IHRoZW0gaGVyZSBhbmQgdGhlbiB0aHJvdy4gV2UgZG9uJ3QgY2FyZSBhYm91dCBzdWNoXG4gICAgICAgICAqIGF0dHJpYnV0ZXMgc28gd2UgaWdub3JlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIGFydGljbGUgbm9kZSBmb3IgZGlzcGxheS4gQ2xlYW4gb3V0IGFueSBpbmxpbmUgc3R5bGVzLFxuICAgKiBpZnJhbWVzLCBmb3Jtcywgc3RyaXAgZXh0cmFuZW91cyA8cD4gdGFncywgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICoqL1xuICBfcHJlcEFydGljbGU6IGZ1bmN0aW9uKGFydGljbGVDb250ZW50KSB7XG4gICAgdGhpcy5fY2xlYW5TdHlsZXMoYXJ0aWNsZUNvbnRlbnQpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGRhdGEgdGFibGVzIGJlZm9yZSB3ZSBjb250aW51ZSwgdG8gYXZvaWQgcmVtb3ZpbmcgaXRlbXMgaW5cbiAgICAvLyB0aG9zZSB0YWJsZXMsIHdoaWNoIHdpbGwgb2Z0ZW4gYmUgaXNvbGF0ZWQgZXZlbiB0aG91Z2ggdGhleSdyZVxuICAgIC8vIHZpc3VhbGx5IGxpbmtlZCB0byBvdGhlciBjb250ZW50LWZ1bCBlbGVtZW50cyAodGV4dCwgaW1hZ2VzLCBldGMuKS5cbiAgICB0aGlzLl9tYXJrRGF0YVRhYmxlcyhhcnRpY2xlQ29udGVudCk7XG5cbiAgICB0aGlzLl9maXhMYXp5SW1hZ2VzKGFydGljbGVDb250ZW50KTtcblxuICAgIC8vIENsZWFuIG91dCBqdW5rIGZyb20gdGhlIGFydGljbGUgY29udGVudFxuICAgIHRoaXMuX2NsZWFuQ29uZGl0aW9uYWxseShhcnRpY2xlQ29udGVudCwgXCJmb3JtXCIpO1xuICAgIHRoaXMuX2NsZWFuQ29uZGl0aW9uYWxseShhcnRpY2xlQ29udGVudCwgXCJmaWVsZHNldFwiKTtcbiAgICB0aGlzLl9jbGVhbihhcnRpY2xlQ29udGVudCwgXCJvYmplY3RcIik7XG4gICAgdGhpcy5fY2xlYW4oYXJ0aWNsZUNvbnRlbnQsIFwiZW1iZWRcIik7XG4gICAgdGhpcy5fY2xlYW4oYXJ0aWNsZUNvbnRlbnQsIFwiZm9vdGVyXCIpO1xuICAgIHRoaXMuX2NsZWFuKGFydGljbGVDb250ZW50LCBcImxpbmtcIik7XG4gICAgdGhpcy5fY2xlYW4oYXJ0aWNsZUNvbnRlbnQsIFwiYXNpZGVcIik7XG5cbiAgICAvLyBDbGVhbiBvdXQgZWxlbWVudHMgd2l0aCBsaXR0bGUgY29udGVudCB0aGF0IGhhdmUgXCJzaGFyZVwiIGluIHRoZWlyIGlkL2NsYXNzIGNvbWJpbmF0aW9ucyBmcm9tIGZpbmFsIHRvcCBjYW5kaWRhdGVzLFxuICAgIC8vIHdoaWNoIG1lYW5zIHdlIGRvbid0IHJlbW92ZSB0aGUgdG9wIGNhbmRpZGF0ZXMgZXZlbiB0aGV5IGhhdmUgXCJzaGFyZVwiLlxuXG4gICAgdmFyIHNoYXJlRWxlbWVudFRocmVzaG9sZCA9IHRoaXMuREVGQVVMVF9DSEFSX1RIUkVTSE9MRDtcblxuICAgIHRoaXMuX2ZvckVhY2hOb2RlKGFydGljbGVDb250ZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAodG9wQ2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLl9jbGVhbk1hdGNoZWROb2Rlcyh0b3BDYW5kaWRhdGUsIGZ1bmN0aW9uIChub2RlLCBtYXRjaFN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5SRUdFWFBTLnNoYXJlRWxlbWVudHMudGVzdChtYXRjaFN0cmluZykgJiYgbm9kZS50ZXh0Q29udGVudC5sZW5ndGggPCBzaGFyZUVsZW1lbnRUaHJlc2hvbGQ7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsZWFuKGFydGljbGVDb250ZW50LCBcImlmcmFtZVwiKTtcbiAgICB0aGlzLl9jbGVhbihhcnRpY2xlQ29udGVudCwgXCJpbnB1dFwiKTtcbiAgICB0aGlzLl9jbGVhbihhcnRpY2xlQ29udGVudCwgXCJ0ZXh0YXJlYVwiKTtcbiAgICB0aGlzLl9jbGVhbihhcnRpY2xlQ29udGVudCwgXCJzZWxlY3RcIik7XG4gICAgdGhpcy5fY2xlYW4oYXJ0aWNsZUNvbnRlbnQsIFwiYnV0dG9uXCIpO1xuICAgIHRoaXMuX2NsZWFuSGVhZGVycyhhcnRpY2xlQ29udGVudCk7XG5cbiAgICAvLyBEbyB0aGVzZSBsYXN0IGFzIHRoZSBwcmV2aW91cyBzdHVmZiBtYXkgaGF2ZSByZW1vdmVkIGp1bmtcbiAgICAvLyB0aGF0IHdpbGwgYWZmZWN0IHRoZXNlXG4gICAgdGhpcy5fY2xlYW5Db25kaXRpb25hbGx5KGFydGljbGVDb250ZW50LCBcInRhYmxlXCIpO1xuICAgIHRoaXMuX2NsZWFuQ29uZGl0aW9uYWxseShhcnRpY2xlQ29udGVudCwgXCJ1bFwiKTtcbiAgICB0aGlzLl9jbGVhbkNvbmRpdGlvbmFsbHkoYXJ0aWNsZUNvbnRlbnQsIFwiZGl2XCIpO1xuXG4gICAgLy8gcmVwbGFjZSBIMSB3aXRoIEgyIGFzIEgxIHNob3VsZCBiZSBvbmx5IHRpdGxlIHRoYXQgaXMgZGlzcGxheWVkIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9yZXBsYWNlTm9kZVRhZ3ModGhpcy5fZ2V0QWxsTm9kZXNXaXRoVGFnKGFydGljbGVDb250ZW50LCBbXCJoMVwiXSksIFwiaDJcIik7XG5cbiAgICAvLyBSZW1vdmUgZXh0cmEgcGFyYWdyYXBoc1xuICAgIHRoaXMuX3JlbW92ZU5vZGVzKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhhcnRpY2xlQ29udGVudCwgW1wicFwiXSksIGZ1bmN0aW9uIChwYXJhZ3JhcGgpIHtcbiAgICAgIHZhciBpbWdDb3VudCA9IHBhcmFncmFwaC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKS5sZW5ndGg7XG4gICAgICB2YXIgZW1iZWRDb3VudCA9IHBhcmFncmFwaC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImVtYmVkXCIpLmxlbmd0aDtcbiAgICAgIHZhciBvYmplY3RDb3VudCA9IHBhcmFncmFwaC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9iamVjdFwiKS5sZW5ndGg7XG4gICAgICAvLyBBdCB0aGlzIHBvaW50LCBuYXN0eSBpZnJhbWVzIGhhdmUgYmVlbiByZW1vdmVkLCBvbmx5IHJlbWFpbiBlbWJlZGRlZCB2aWRlbyBvbmVzLlxuICAgICAgdmFyIGlmcmFtZUNvdW50ID0gcGFyYWdyYXBoLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaWZyYW1lXCIpLmxlbmd0aDtcbiAgICAgIHZhciB0b3RhbENvdW50ID0gaW1nQ291bnQgKyBlbWJlZENvdW50ICsgb2JqZWN0Q291bnQgKyBpZnJhbWVDb3VudDtcblxuICAgICAgcmV0dXJuIHRvdGFsQ291bnQgPT09IDAgJiYgIXRoaXMuX2dldElubmVyVGV4dChwYXJhZ3JhcGgsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2ZvckVhY2hOb2RlKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhhcnRpY2xlQ29udGVudCwgW1wiYnJcIl0pLCBmdW5jdGlvbihicikge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLl9uZXh0Tm9kZShici5uZXh0U2libGluZyk7XG4gICAgICBpZiAobmV4dCAmJiBuZXh0LnRhZ05hbWUgPT0gXCJQXCIpXG4gICAgICAgIGJyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYnIpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIHNpbmdsZS1jZWxsIHRhYmxlc1xuICAgIHRoaXMuX2ZvckVhY2hOb2RlKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhhcnRpY2xlQ29udGVudCwgW1widGFibGVcIl0pLCBmdW5jdGlvbih0YWJsZSkge1xuICAgICAgdmFyIHRib2R5ID0gdGhpcy5faGFzU2luZ2xlVGFnSW5zaWRlRWxlbWVudCh0YWJsZSwgXCJUQk9EWVwiKSA/IHRhYmxlLmZpcnN0RWxlbWVudENoaWxkIDogdGFibGU7XG4gICAgICBpZiAodGhpcy5faGFzU2luZ2xlVGFnSW5zaWRlRWxlbWVudCh0Ym9keSwgXCJUUlwiKSkge1xuICAgICAgICB2YXIgcm93ID0gdGJvZHkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIGlmICh0aGlzLl9oYXNTaW5nbGVUYWdJbnNpZGVFbGVtZW50KHJvdywgXCJURFwiKSkge1xuICAgICAgICAgIHZhciBjZWxsID0gcm93LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIGNlbGwgPSB0aGlzLl9zZXROb2RlVGFnKGNlbGwsIHRoaXMuX2V2ZXJ5Tm9kZShjZWxsLmNoaWxkTm9kZXMsIHRoaXMuX2lzUGhyYXNpbmdDb250ZW50KSA/IFwiUFwiIDogXCJESVZcIik7XG4gICAgICAgICAgdGFibGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2VsbCwgdGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBub2RlIHdpdGggdGhlIHJlYWRhYmlsaXR5IG9iamVjdC4gQWxzbyBjaGVja3MgdGhlXG4gICAqIGNsYXNzTmFtZS9pZCBmb3Igc3BlY2lhbCBuYW1lcyB0byBhZGQgdG8gaXRzIHNjb3JlLlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgKiovXG4gIF9pbml0aWFsaXplTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUucmVhZGFiaWxpdHkgPSB7XCJjb250ZW50U2NvcmVcIjogMH07XG5cbiAgICBzd2l0Y2ggKG5vZGUudGFnTmFtZSkge1xuICAgICAgY2FzZSBcIkRJVlwiOlxuICAgICAgICBub2RlLnJlYWRhYmlsaXR5LmNvbnRlbnRTY29yZSArPSA1O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBSRVwiOlxuICAgICAgY2FzZSBcIlREXCI6XG4gICAgICBjYXNlIFwiQkxPQ0tRVU9URVwiOlxuICAgICAgICBub2RlLnJlYWRhYmlsaXR5LmNvbnRlbnRTY29yZSArPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFERFJFU1NcIjpcbiAgICAgIGNhc2UgXCJPTFwiOlxuICAgICAgY2FzZSBcIlVMXCI6XG4gICAgICBjYXNlIFwiRExcIjpcbiAgICAgIGNhc2UgXCJERFwiOlxuICAgICAgY2FzZSBcIkRUXCI6XG4gICAgICBjYXNlIFwiTElcIjpcbiAgICAgIGNhc2UgXCJGT1JNXCI6XG4gICAgICAgIG5vZGUucmVhZGFiaWxpdHkuY29udGVudFNjb3JlIC09IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiSDFcIjpcbiAgICAgIGNhc2UgXCJIMlwiOlxuICAgICAgY2FzZSBcIkgzXCI6XG4gICAgICBjYXNlIFwiSDRcIjpcbiAgICAgIGNhc2UgXCJINVwiOlxuICAgICAgY2FzZSBcIkg2XCI6XG4gICAgICBjYXNlIFwiVEhcIjpcbiAgICAgICAgbm9kZS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgLT0gNTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgKz0gdGhpcy5fZ2V0Q2xhc3NXZWlnaHQobm9kZSk7XG4gIH0sXG5cbiAgX3JlbW92ZUFuZEdldE5leHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSB0aGlzLl9nZXROZXh0Tm9kZShub2RlLCB0cnVlKTtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgRE9NIGZyb20gbm9kZSB0byBub2RlLCBzdGFydGluZyBhdCB0aGUgbm9kZSBwYXNzZWQgaW4uXG4gICAqIFBhc3MgdHJ1ZSBmb3IgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5kaWNhdGUgdGhpcyBub2RlIGl0c2VsZlxuICAgKiAoYW5kIGl0cyBraWRzKSBhcmUgZ29pbmcgYXdheSwgYW5kIHdlIHdhbnQgdGhlIG5leHQgbm9kZSBvdmVyLlxuICAgKlxuICAgKiBDYWxsaW5nIHRoaXMgaW4gYSBsb29wIHdpbGwgdHJhdmVyc2UgdGhlIERPTSBkZXB0aC1maXJzdC5cbiAgICovXG4gIF9nZXROZXh0Tm9kZTogZnVuY3Rpb24obm9kZSwgaWdub3JlU2VsZkFuZEtpZHMpIHtcbiAgICAvLyBGaXJzdCBjaGVjayBmb3Iga2lkcyBpZiB0aG9zZSBhcmVuJ3QgYmVpbmcgaWdub3JlZFxuICAgIGlmICghaWdub3JlU2VsZkFuZEtpZHMgJiYgbm9kZS5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgcmV0dXJuIG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICAgIC8vIFRoZW4gZm9yIHNpYmxpbmdzLi4uXG4gICAgaWYgKG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIC8vIEFuZCBmaW5hbGx5LCBtb3ZlIHVwIHRoZSBwYXJlbnQgY2hhaW4gKmFuZCogZmluZCBhIHNpYmxpbmdcbiAgICAvLyAoYmVjYXVzZSB0aGlzIGlzIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCwgd2Ugd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBzZWVuIHRoZSBwYXJlbnQgbm9kZXMgdGhlbXNlbHZlcykuXG4gICAgZG8ge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChub2RlICYmICFub2RlLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH0sXG5cbiAgLy8gY29tcGFyZXMgc2Vjb25kIHRleHQgdG8gZmlyc3Qgb25lXG4gIC8vIDEgPSBzYW1lIHRleHQsIDAgPSBjb21wbGV0ZWx5IGRpZmZlcmVudCB0ZXh0XG4gIC8vIHdvcmtzIHRoZSB3YXkgdGhhdCBpdCBzcGxpdHMgYm90aCB0ZXh0cyBpbnRvIHdvcmRzIGFuZCB0aGVuIGZpbmRzIHdvcmRzIHRoYXQgYXJlIHVuaXF1ZSBpbiBzZWNvbmQgdGV4dFxuICAvLyB0aGUgcmVzdWx0IGlzIGdpdmVuIGJ5IHRoZSBsb3dlciBsZW5ndGggb2YgdW5pcXVlIHBhcnRzXG4gIF90ZXh0U2ltaWxhcml0eTogZnVuY3Rpb24odGV4dEEsIHRleHRCKSB7XG4gICAgdmFyIHRva2Vuc0EgPSB0ZXh0QS50b0xvd2VyQ2FzZSgpLnNwbGl0KHRoaXMuUkVHRVhQUy50b2tlbml6ZSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHZhciB0b2tlbnNCID0gdGV4dEIudG9Mb3dlckNhc2UoKS5zcGxpdCh0aGlzLlJFR0VYUFMudG9rZW5pemUpLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoIXRva2Vuc0EubGVuZ3RoIHx8ICF0b2tlbnNCLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB1bmlxVG9rZW5zQiA9IHRva2Vuc0IuZmlsdGVyKHRva2VuID0+ICF0b2tlbnNBLmluY2x1ZGVzKHRva2VuKSk7XG4gICAgdmFyIGRpc3RhbmNlQiA9IHVuaXFUb2tlbnNCLmpvaW4oXCIgXCIpLmxlbmd0aCAvIHRva2Vuc0Iuam9pbihcIiBcIikubGVuZ3RoO1xuICAgIHJldHVybiAxIC0gZGlzdGFuY2VCO1xuICB9LFxuXG4gIF9jaGVja0J5bGluZTogZnVuY3Rpb24obm9kZSwgbWF0Y2hTdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fYXJ0aWNsZUJ5bGluZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVsID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIik7XG4gICAgICB2YXIgaXRlbXByb3AgPSBub2RlLmdldEF0dHJpYnV0ZShcIml0ZW1wcm9wXCIpO1xuICAgIH1cblxuICAgIGlmICgocmVsID09PSBcImF1dGhvclwiIHx8IChpdGVtcHJvcCAmJiBpdGVtcHJvcC5pbmRleE9mKFwiYXV0aG9yXCIpICE9PSAtMSkgfHwgdGhpcy5SRUdFWFBTLmJ5bGluZS50ZXN0KG1hdGNoU3RyaW5nKSkgJiYgdGhpcy5faXNWYWxpZEJ5bGluZShub2RlLnRleHRDb250ZW50KSkge1xuICAgICAgdGhpcy5fYXJ0aWNsZUJ5bGluZSA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIF9nZXROb2RlQW5jZXN0b3JzOiBmdW5jdGlvbihub2RlLCBtYXhEZXB0aCkge1xuICAgIG1heERlcHRoID0gbWF4RGVwdGggfHwgMDtcbiAgICB2YXIgaSA9IDAsIGFuY2VzdG9ycyA9IFtdO1xuICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICBpZiAobWF4RGVwdGggJiYgKytpID09PSBtYXhEZXB0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9LFxuXG4gIC8qKipcbiAgICogZ3JhYkFydGljbGUgLSBVc2luZyBhIHZhcmlldHkgb2YgbWV0cmljcyAoY29udGVudCBzY29yZSwgY2xhc3NuYW1lLCBlbGVtZW50IHR5cGVzKSwgZmluZCB0aGUgY29udGVudCB0aGF0IGlzXG4gICAqICAgICAgICAgbW9zdCBsaWtlbHkgdG8gYmUgdGhlIHN0dWZmIGEgdXNlciB3YW50cyB0byByZWFkLiBUaGVuIHJldHVybiBpdCB3cmFwcGVkIHVwIGluIGEgZGl2LlxuICAgKlxuICAgKiBAcGFyYW0gcGFnZSBhIGRvY3VtZW50IHRvIHJ1biB1cG9uLiBOZWVkcyB0byBiZSBhIGZ1bGwgZG9jdW1lbnQsIGNvbXBsZXRlIHdpdGggYm9keS5cbiAgICogQHJldHVybiBFbGVtZW50XG4gICoqL1xuICBfZ3JhYkFydGljbGU6IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgdGhpcy5sb2coXCIqKioqIGdyYWJBcnRpY2xlICoqKipcIik7XG4gICAgdmFyIGRvYyA9IHRoaXMuX2RvYztcbiAgICB2YXIgaXNQYWdpbmcgPSBwYWdlICE9PSBudWxsO1xuICAgIHBhZ2UgPSBwYWdlID8gcGFnZSA6IHRoaXMuX2RvYy5ib2R5O1xuXG4gICAgLy8gV2UgY2FuJ3QgZ3JhYiBhbiBhcnRpY2xlIGlmIHdlIGRvbid0IGhhdmUgYSBwYWdlIVxuICAgIGlmICghcGFnZSkge1xuICAgICAgdGhpcy5sb2coXCJObyBib2R5IGZvdW5kIGluIGRvY3VtZW50LiBBYm9ydC5cIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGFnZUNhY2hlSHRtbCA9IHBhZ2UuaW5uZXJIVE1MO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRoaXMubG9nKFwiU3RhcnRpbmcgZ3JhYkFydGljbGUgbG9vcFwiKTtcbiAgICAgIHZhciBzdHJpcFVubGlrZWx5Q2FuZGlkYXRlcyA9IHRoaXMuX2ZsYWdJc0FjdGl2ZSh0aGlzLkZMQUdfU1RSSVBfVU5MSUtFTFlTKTtcblxuICAgICAgLy8gRmlyc3QsIG5vZGUgcHJlcHBpbmcuIFRyYXNoIG5vZGVzIHRoYXQgbG9vayBjcnVkZHkgKGxpa2Ugb25lcyB3aXRoIHRoZVxuICAgICAgLy8gY2xhc3MgbmFtZSBcImNvbW1lbnRcIiwgZXRjKSwgYW5kIHR1cm4gZGl2cyBpbnRvIFAgdGFncyB3aGVyZSB0aGV5IGhhdmUgYmVlblxuICAgICAgLy8gdXNlZCBpbmFwcHJvcHJpYXRlbHkgKGFzIGluLCB3aGVyZSB0aGV5IGNvbnRhaW4gbm8gb3RoZXIgYmxvY2sgbGV2ZWwgZWxlbWVudHMuKVxuICAgICAgdmFyIGVsZW1lbnRzVG9TY29yZSA9IFtdO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9kb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBsZXQgc2hvdWxkUmVtb3ZlVGl0bGVIZWFkZXIgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuXG4gICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwiSFRNTFwiKSB7XG4gICAgICAgICAgdGhpcy5fYXJ0aWNsZUxhbmcgPSBub2RlLmdldEF0dHJpYnV0ZShcImxhbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hTdHJpbmcgPSBub2RlLmNsYXNzTmFtZSArIFwiIFwiICsgbm9kZS5pZDtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzUHJvYmFibHlWaXNpYmxlKG5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJSZW1vdmluZyBoaWRkZW4gbm9kZSAtIFwiICsgbWF0Y2hTdHJpbmcpO1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl9yZW1vdmVBbmRHZXROZXh0KG5vZGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBpcyBub3QgYWJsZSB0byBzZWUgZWxlbWVudHMgYXBwbGllZCB3aXRoIGJvdGggXCJhcmlhLW1vZGFsID0gdHJ1ZVwiIGFuZCBcInJvbGUgPSBkaWFsb2dcIlxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpID09IFwidHJ1ZVwiICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PSBcImRpYWxvZ1wiKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBub2RlIGlzIGEgYnlsaW5lLCBhbmQgcmVtb3ZlIGl0IGlmIGl0IGlzLlxuICAgICAgICBpZiAodGhpcy5fY2hlY2tCeWxpbmUobm9kZSwgbWF0Y2hTdHJpbmcpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlVGl0bGVIZWFkZXIgJiYgdGhpcy5faGVhZGVyRHVwbGljYXRlc1RpdGxlKG5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJSZW1vdmluZyBoZWFkZXI6IFwiLCBub2RlLnRleHRDb250ZW50LnRyaW0oKSwgdGhpcy5fYXJ0aWNsZVRpdGxlLnRyaW0oKSk7XG4gICAgICAgICAgc2hvdWxkUmVtb3ZlVGl0bGVIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICBub2RlID0gdGhpcy5fcmVtb3ZlQW5kR2V0TmV4dChub2RlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB1bmxpa2VseSBjYW5kaWRhdGVzXG4gICAgICAgIGlmIChzdHJpcFVubGlrZWx5Q2FuZGlkYXRlcykge1xuICAgICAgICAgIGlmICh0aGlzLlJFR0VYUFMudW5saWtlbHlDYW5kaWRhdGVzLnRlc3QobWF0Y2hTdHJpbmcpICYmXG4gICAgICAgICAgICAgICF0aGlzLlJFR0VYUFMub2tNYXliZUl0c0FDYW5kaWRhdGUudGVzdChtYXRjaFN0cmluZykgJiZcbiAgICAgICAgICAgICAgIXRoaXMuX2hhc0FuY2VzdG9yVGFnKG5vZGUsIFwidGFibGVcIikgJiZcbiAgICAgICAgICAgICAgIXRoaXMuX2hhc0FuY2VzdG9yVGFnKG5vZGUsIFwiY29kZVwiKSAmJlxuICAgICAgICAgICAgICBub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiICYmXG4gICAgICAgICAgICAgIG5vZGUudGFnTmFtZSAhPT0gXCJBXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiUmVtb3ZpbmcgdW5saWtlbHkgY2FuZGlkYXRlIC0gXCIgKyBtYXRjaFN0cmluZyk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fcmVtb3ZlQW5kR2V0TmV4dChub2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLlVOTElLRUxZX1JPTEVTLmluY2x1ZGVzKG5vZGUuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiUmVtb3ZpbmcgY29udGVudCB3aXRoIHJvbGUgXCIgKyBub2RlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgKyBcIiAtIFwiICsgbWF0Y2hTdHJpbmcpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgRElWLCBTRUNUSU9OLCBhbmQgSEVBREVSIG5vZGVzIHdpdGhvdXQgYW55IGNvbnRlbnQoZS5nLiB0ZXh0LCBpbWFnZSwgdmlkZW8sIG9yIGlmcmFtZSkuXG4gICAgICAgIGlmICgobm9kZS50YWdOYW1lID09PSBcIkRJVlwiIHx8IG5vZGUudGFnTmFtZSA9PT0gXCJTRUNUSU9OXCIgfHwgbm9kZS50YWdOYW1lID09PSBcIkhFQURFUlwiIHx8XG4gICAgICAgICAgICAgbm9kZS50YWdOYW1lID09PSBcIkgxXCIgfHwgbm9kZS50YWdOYW1lID09PSBcIkgyXCIgfHwgbm9kZS50YWdOYW1lID09PSBcIkgzXCIgfHxcbiAgICAgICAgICAgICBub2RlLnRhZ05hbWUgPT09IFwiSDRcIiB8fCBub2RlLnRhZ05hbWUgPT09IFwiSDVcIiB8fCBub2RlLnRhZ05hbWUgPT09IFwiSDZcIikgJiZcbiAgICAgICAgICAgIHRoaXMuX2lzRWxlbWVudFdpdGhvdXRDb250ZW50KG5vZGUpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ERUZBVUxUX1RBR1NfVE9fU0NPUkUuaW5kZXhPZihub2RlLnRhZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgIGVsZW1lbnRzVG9TY29yZS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHVybiBhbGwgZGl2cyB0aGF0IGRvbid0IGhhdmUgY2hpbGRyZW4gYmxvY2sgbGV2ZWwgZWxlbWVudHMgaW50byBwJ3NcbiAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJESVZcIikge1xuICAgICAgICAgIC8vIFB1dCBwaHJhc2luZyBjb250ZW50IGludG8gcGFyYWdyYXBocy5cbiAgICAgICAgICB2YXIgcCA9IG51bGw7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICB3aGlsZSAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNQaHJhc2luZ0NvbnRlbnQoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICBpZiAocCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNXaGl0ZXNwYWNlKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVwbGFjZUNoaWxkKHAsIGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHAubGFzdENoaWxkICYmIHRoaXMuX2lzV2hpdGVzcGFjZShwLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBwLnJlbW92ZUNoaWxkKHAubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNpdGVzIGxpa2UgaHR0cDovL21vYmlsZS5zbGF0ZS5jb20gZW5jbG9zZXMgZWFjaCBwYXJhZ3JhcGggd2l0aCBhIERJVlxuICAgICAgICAgIC8vIGVsZW1lbnQuIERJVnMgd2l0aCBvbmx5IGEgUCBlbGVtZW50IGluc2lkZSBhbmQgbm8gdGV4dCBjb250ZW50IGNhbiBiZVxuICAgICAgICAgIC8vIHNhZmVseSBjb252ZXJ0ZWQgaW50byBwbGFpbiBQIGVsZW1lbnRzIHRvIGF2b2lkIGNvbmZ1c2luZyB0aGUgc2NvcmluZ1xuICAgICAgICAgIC8vIGFsZ29yaXRobSB3aXRoIERJVnMgd2l0aCBhcmUsIGluIHByYWN0aWNlLCBwYXJhZ3JhcGhzLlxuICAgICAgICAgIGlmICh0aGlzLl9oYXNTaW5nbGVUYWdJbnNpZGVFbGVtZW50KG5vZGUsIFwiUFwiKSAmJiB0aGlzLl9nZXRMaW5rRGVuc2l0eShub2RlKSA8IDAuMjUpIHtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIGVsZW1lbnRzVG9TY29yZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2hhc0NoaWxkQmxvY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fc2V0Tm9kZVRhZyhub2RlLCBcIlBcIik7XG4gICAgICAgICAgICBlbGVtZW50c1RvU2NvcmUucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHRoaXMuX2dldE5leHROb2RlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbGwgcGFyYWdyYXBocywgYW5kIGFzc2lnbiBhIHNjb3JlIHRvIHRoZW0gYmFzZWQgb24gaG93IGNvbnRlbnQteSB0aGV5IGxvb2suXG4gICAgICAgKiBUaGVuIGFkZCB0aGVpciBzY29yZSB0byB0aGVpciBwYXJlbnQgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBBIHNjb3JlIGlzIGRldGVybWluZWQgYnkgdGhpbmdzIGxpa2UgbnVtYmVyIG9mIGNvbW1hcywgY2xhc3MgbmFtZXMsIGV0Yy4gTWF5YmUgZXZlbnR1YWxseSBsaW5rIGRlbnNpdHkuXG4gICAgICAqKi9cbiAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgICB0aGlzLl9mb3JFYWNoTm9kZShlbGVtZW50c1RvU2NvcmUsIGZ1bmN0aW9uKGVsZW1lbnRUb1Njb3JlKSB7XG4gICAgICAgIGlmICghZWxlbWVudFRvU2NvcmUucGFyZW50Tm9kZSB8fCB0eXBlb2YoZWxlbWVudFRvU2NvcmUucGFyZW50Tm9kZS50YWdOYW1lKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gSWYgdGhpcyBwYXJhZ3JhcGggaXMgbGVzcyB0aGFuIDI1IGNoYXJhY3RlcnMsIGRvbid0IGV2ZW4gY291bnQgaXQuXG4gICAgICAgIHZhciBpbm5lclRleHQgPSB0aGlzLl9nZXRJbm5lclRleHQoZWxlbWVudFRvU2NvcmUpO1xuICAgICAgICBpZiAoaW5uZXJUZXh0Lmxlbmd0aCA8IDI1KVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBFeGNsdWRlIG5vZGVzIHdpdGggbm8gYW5jZXN0b3IuXG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSB0aGlzLl9nZXROb2RlQW5jZXN0b3JzKGVsZW1lbnRUb1Njb3JlLCA1KTtcbiAgICAgICAgaWYgKGFuY2VzdG9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjb250ZW50U2NvcmUgPSAwO1xuXG4gICAgICAgIC8vIEFkZCBhIHBvaW50IGZvciB0aGUgcGFyYWdyYXBoIGl0c2VsZiBhcyBhIGJhc2UuXG4gICAgICAgIGNvbnRlbnRTY29yZSArPSAxO1xuXG4gICAgICAgIC8vIEFkZCBwb2ludHMgZm9yIGFueSBjb21tYXMgd2l0aGluIHRoaXMgcGFyYWdyYXBoLlxuICAgICAgICBjb250ZW50U2NvcmUgKz0gaW5uZXJUZXh0LnNwbGl0KHRoaXMuUkVHRVhQUy5jb21tYXMpLmxlbmd0aDtcblxuICAgICAgICAvLyBGb3IgZXZlcnkgMTAwIGNoYXJhY3RlcnMgaW4gdGhpcyBwYXJhZ3JhcGgsIGFkZCBhbm90aGVyIHBvaW50LiBVcCB0byAzIHBvaW50cy5cbiAgICAgICAgY29udGVudFNjb3JlICs9IE1hdGgubWluKE1hdGguZmxvb3IoaW5uZXJUZXh0Lmxlbmd0aCAvIDEwMCksIDMpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYW5kIHNjb3JlIGFuY2VzdG9ycy5cbiAgICAgICAgdGhpcy5fZm9yRWFjaE5vZGUoYW5jZXN0b3JzLCBmdW5jdGlvbihhbmNlc3RvciwgbGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWFuY2VzdG9yLnRhZ05hbWUgfHwgIWFuY2VzdG9yLnBhcmVudE5vZGUgfHwgdHlwZW9mKGFuY2VzdG9yLnBhcmVudE5vZGUudGFnTmFtZSkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBpZiAodHlwZW9mKGFuY2VzdG9yLnJlYWRhYmlsaXR5KSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5vZGUoYW5jZXN0b3IpO1xuICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb2RlIHNjb3JlIGRpdmlkZXI6XG4gICAgICAgICAgLy8gLSBwYXJlbnQ6ICAgICAgICAgICAgIDEgKG5vIGRpdmlzaW9uKVxuICAgICAgICAgIC8vIC0gZ3JhbmRwYXJlbnQ6ICAgICAgICAyXG4gICAgICAgICAgLy8gLSBncmVhdCBncmFuZHBhcmVudCs6IGFuY2VzdG9yIGxldmVsICogM1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMClcbiAgICAgICAgICAgIHZhciBzY29yZURpdmlkZXIgPSAxO1xuICAgICAgICAgIGVsc2UgaWYgKGxldmVsID09PSAxKVxuICAgICAgICAgICAgc2NvcmVEaXZpZGVyID0gMjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzY29yZURpdmlkZXIgPSBsZXZlbCAqIDM7XG4gICAgICAgICAgYW5jZXN0b3IucmVhZGFiaWxpdHkuY29udGVudFNjb3JlICs9IGNvbnRlbnRTY29yZSAvIHNjb3JlRGl2aWRlcjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWZ0ZXIgd2UndmUgY2FsY3VsYXRlZCBzY29yZXMsIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAvLyBjYW5kaWRhdGUgbm9kZXMgd2UgZm91bmQgYW5kIGZpbmQgdGhlIG9uZSB3aXRoIHRoZSBoaWdoZXN0IHNjb3JlLlxuICAgICAgdmFyIHRvcENhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGMgPSAwLCBjbCA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBjIDwgY2w7IGMgKz0gMSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tjXTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgZmluYWwgY2FuZGlkYXRlcyBzY29yZSBiYXNlZCBvbiBsaW5rIGRlbnNpdHkuIEdvb2QgY29udGVudFxuICAgICAgICAvLyBzaG91bGQgaGF2ZSBhIHJlbGF0aXZlbHkgc21hbGwgbGluayBkZW5zaXR5ICg1JSBvciBsZXNzKSBhbmQgYmUgbW9zdGx5XG4gICAgICAgIC8vIHVuYWZmZWN0ZWQgYnkgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgIHZhciBjYW5kaWRhdGVTY29yZSA9IGNhbmRpZGF0ZS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgKiAoMSAtIHRoaXMuX2dldExpbmtEZW5zaXR5KGNhbmRpZGF0ZSkpO1xuICAgICAgICBjYW5kaWRhdGUucmVhZGFiaWxpdHkuY29udGVudFNjb3JlID0gY2FuZGlkYXRlU2NvcmU7XG5cbiAgICAgICAgdGhpcy5sb2coXCJDYW5kaWRhdGU6XCIsIGNhbmRpZGF0ZSwgXCJ3aXRoIHNjb3JlIFwiICsgY2FuZGlkYXRlU2NvcmUpO1xuXG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy5fbmJUb3BDYW5kaWRhdGVzOyB0KyspIHtcbiAgICAgICAgICB2YXIgYVRvcENhbmRpZGF0ZSA9IHRvcENhbmRpZGF0ZXNbdF07XG5cbiAgICAgICAgICBpZiAoIWFUb3BDYW5kaWRhdGUgfHwgY2FuZGlkYXRlU2NvcmUgPiBhVG9wQ2FuZGlkYXRlLnJlYWRhYmlsaXR5LmNvbnRlbnRTY29yZSkge1xuICAgICAgICAgICAgdG9wQ2FuZGlkYXRlcy5zcGxpY2UodCwgMCwgY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGlmICh0b3BDYW5kaWRhdGVzLmxlbmd0aCA+IHRoaXMuX25iVG9wQ2FuZGlkYXRlcylcbiAgICAgICAgICAgICAgdG9wQ2FuZGlkYXRlcy5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdG9wQ2FuZGlkYXRlID0gdG9wQ2FuZGlkYXRlc1swXSB8fCBudWxsO1xuICAgICAgdmFyIG5lZWRlZFRvQ3JlYXRlVG9wQ2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB2YXIgcGFyZW50T2ZUb3BDYW5kaWRhdGU7XG5cbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgbm8gdG9wIGNhbmRpZGF0ZSwganVzdCB1c2UgdGhlIGJvZHkgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAgIC8vIFdlIGFsc28gaGF2ZSB0byBjb3B5IHRoZSBib2R5IG5vZGUgc28gaXQgaXMgc29tZXRoaW5nIHdlIGNhbiBtb2RpZnkuXG4gICAgICBpZiAodG9wQ2FuZGlkYXRlID09PSBudWxsIHx8IHRvcENhbmRpZGF0ZS50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgICAvLyBNb3ZlIGFsbCBvZiB0aGUgcGFnZSdzIGNoaWxkcmVuIGludG8gdG9wQ2FuZGlkYXRlXG4gICAgICAgIHRvcENhbmRpZGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBuZWVkZWRUb0NyZWF0ZVRvcENhbmRpZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIE1vdmUgZXZlcnl0aGluZyAobm90IGp1c3QgZWxlbWVudHMsIGFsc28gdGV4dCBub2RlcyBldGMuKSBpbnRvIHRoZSBjb250YWluZXJcbiAgICAgICAgLy8gc28gd2UgZXZlbiBpbmNsdWRlIHRleHQgZGlyZWN0bHkgaW4gdGhlIGJvZHk6XG4gICAgICAgIHdoaWxlIChwYWdlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIk1vdmluZyBjaGlsZCBvdXQ6XCIsIHBhZ2UuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgdG9wQ2FuZGlkYXRlLmFwcGVuZENoaWxkKHBhZ2UuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYWdlLmFwcGVuZENoaWxkKHRvcENhbmRpZGF0ZSk7XG5cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5vZGUodG9wQ2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAodG9wQ2FuZGlkYXRlKSB7XG4gICAgICAgIC8vIEZpbmQgYSBiZXR0ZXIgdG9wIGNhbmRpZGF0ZSBub2RlIGlmIGl0IGNvbnRhaW5zIChhdCBsZWFzdCB0aHJlZSkgbm9kZXMgd2hpY2ggYmVsb25nIHRvIGB0b3BDYW5kaWRhdGVzYCBhcnJheVxuICAgICAgICAvLyBhbmQgd2hvc2Ugc2NvcmVzIGFyZSBxdWl0ZSBjbG9zZWQgd2l0aCBjdXJyZW50IGB0b3BDYW5kaWRhdGVgIG5vZGUuXG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZUNhbmRpZGF0ZUFuY2VzdG9ycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRvcENhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodG9wQ2FuZGlkYXRlc1tpXS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgLyB0b3BDYW5kaWRhdGUucmVhZGFiaWxpdHkuY29udGVudFNjb3JlID49IDAuNzUpIHtcbiAgICAgICAgICAgIGFsdGVybmF0aXZlQ2FuZGlkYXRlQW5jZXN0b3JzLnB1c2godGhpcy5fZ2V0Tm9kZUFuY2VzdG9ycyh0b3BDYW5kaWRhdGVzW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBNSU5JTVVNX1RPUENBTkRJREFURVMgPSAzO1xuICAgICAgICBpZiAoYWx0ZXJuYXRpdmVDYW5kaWRhdGVBbmNlc3RvcnMubGVuZ3RoID49IE1JTklNVU1fVE9QQ0FORElEQVRFUykge1xuICAgICAgICAgIHBhcmVudE9mVG9wQ2FuZGlkYXRlID0gdG9wQ2FuZGlkYXRlLnBhcmVudE5vZGU7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudE9mVG9wQ2FuZGlkYXRlLnRhZ05hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICAgICAgICB2YXIgbGlzdHNDb250YWluaW5nVGhpc0FuY2VzdG9yID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGFuY2VzdG9ySW5kZXggPSAwOyBhbmNlc3RvckluZGV4IDwgYWx0ZXJuYXRpdmVDYW5kaWRhdGVBbmNlc3RvcnMubGVuZ3RoICYmIGxpc3RzQ29udGFpbmluZ1RoaXNBbmNlc3RvciA8IE1JTklNVU1fVE9QQ0FORElEQVRFUzsgYW5jZXN0b3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgIGxpc3RzQ29udGFpbmluZ1RoaXNBbmNlc3RvciArPSBOdW1iZXIoYWx0ZXJuYXRpdmVDYW5kaWRhdGVBbmNlc3RvcnNbYW5jZXN0b3JJbmRleF0uaW5jbHVkZXMocGFyZW50T2ZUb3BDYW5kaWRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0c0NvbnRhaW5pbmdUaGlzQW5jZXN0b3IgPj0gTUlOSU1VTV9UT1BDQU5ESURBVEVTKSB7XG4gICAgICAgICAgICAgIHRvcENhbmRpZGF0ZSA9IHBhcmVudE9mVG9wQ2FuZGlkYXRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudE9mVG9wQ2FuZGlkYXRlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BDYW5kaWRhdGUucmVhZGFiaWxpdHkpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTm9kZSh0b3BDYW5kaWRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiBvdXIgYm9udXMgc3lzdGVtLCBwYXJlbnRzIG9mIGNhbmRpZGF0ZXMgbWlnaHQgaGF2ZSBzY29yZXNcbiAgICAgICAgLy8gdGhlbXNlbHZlcy4gVGhleSBnZXQgaGFsZiBvZiB0aGUgbm9kZS4gVGhlcmUgd29uJ3QgYmUgbm9kZXMgd2l0aCBoaWdoZXJcbiAgICAgICAgLy8gc2NvcmVzIHRoYW4gb3VyIHRvcENhbmRpZGF0ZSwgYnV0IGlmIHdlIHNlZSB0aGUgc2NvcmUgZ29pbmcgKnVwKiBpbiB0aGUgZmlyc3RcbiAgICAgICAgLy8gZmV3IHN0ZXBzIHVwIHRoZSB0cmVlLCB0aGF0J3MgYSBkZWNlbnQgc2lnbiB0aGF0IHRoZXJlIG1pZ2h0IGJlIG1vcmUgY29udGVudFxuICAgICAgICAvLyBsdXJraW5nIGluIG90aGVyIHBsYWNlcyB0aGF0IHdlIHdhbnQgdG8gdW5pZnkgaW4uIFRoZSBzaWJsaW5nIHN0dWZmXG4gICAgICAgIC8vIGJlbG93IGRvZXMgc29tZSBvZiB0aGF0IC0gYnV0IG9ubHkgaWYgd2UndmUgbG9va2VkIGhpZ2ggZW5vdWdoIHVwIHRoZSBET01cbiAgICAgICAgLy8gdHJlZS5cbiAgICAgICAgcGFyZW50T2ZUb3BDYW5kaWRhdGUgPSB0b3BDYW5kaWRhdGUucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIGxhc3RTY29yZSA9IHRvcENhbmRpZGF0ZS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmU7XG4gICAgICAgIC8vIFRoZSBzY29yZXMgc2hvdWxkbid0IGdldCB0b28gbG93LlxuICAgICAgICB2YXIgc2NvcmVUaHJlc2hvbGQgPSBsYXN0U2NvcmUgLyAzO1xuICAgICAgICB3aGlsZSAocGFyZW50T2ZUb3BDYW5kaWRhdGUudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgICAgICBpZiAoIXBhcmVudE9mVG9wQ2FuZGlkYXRlLnJlYWRhYmlsaXR5KSB7XG4gICAgICAgICAgICBwYXJlbnRPZlRvcENhbmRpZGF0ZSA9IHBhcmVudE9mVG9wQ2FuZGlkYXRlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhcmVudFNjb3JlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGUucmVhZGFiaWxpdHkuY29udGVudFNjb3JlO1xuICAgICAgICAgIGlmIChwYXJlbnRTY29yZSA8IHNjb3JlVGhyZXNob2xkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgaWYgKHBhcmVudFNjb3JlID4gbGFzdFNjb3JlKSB7XG4gICAgICAgICAgICAvLyBBbHJpZ2h0ISBXZSBmb3VuZCBhIGJldHRlciBwYXJlbnQgdG8gdXNlLlxuICAgICAgICAgICAgdG9wQ2FuZGlkYXRlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFNjb3JlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGUucmVhZGFiaWxpdHkuY29udGVudFNjb3JlO1xuICAgICAgICAgIHBhcmVudE9mVG9wQ2FuZGlkYXRlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB0b3AgY2FuZGlkYXRlIGlzIHRoZSBvbmx5IGNoaWxkLCB1c2UgcGFyZW50IGluc3RlYWQuIFRoaXMgd2lsbCBoZWxwIHNpYmxpbmdcbiAgICAgICAgLy8gam9pbmluZyBsb2dpYyB3aGVuIGFkamFjZW50IGNvbnRlbnQgaXMgYWN0dWFsbHkgbG9jYXRlZCBpbiBwYXJlbnQncyBzaWJsaW5nIG5vZGUuXG4gICAgICAgIHBhcmVudE9mVG9wQ2FuZGlkYXRlID0gdG9wQ2FuZGlkYXRlLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChwYXJlbnRPZlRvcENhbmRpZGF0ZS50YWdOYW1lICE9IFwiQk9EWVwiICYmIHBhcmVudE9mVG9wQ2FuZGlkYXRlLmNoaWxkcmVuLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgdG9wQ2FuZGlkYXRlID0gcGFyZW50T2ZUb3BDYW5kaWRhdGU7XG4gICAgICAgICAgcGFyZW50T2ZUb3BDYW5kaWRhdGUgPSB0b3BDYW5kaWRhdGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcENhbmRpZGF0ZS5yZWFkYWJpbGl0eSkge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVOb2RlKHRvcENhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgdG9wIGNhbmRpZGF0ZSwgbG9vayB0aHJvdWdoIGl0cyBzaWJsaW5ncyBmb3IgY29udGVudFxuICAgICAgLy8gdGhhdCBtaWdodCBhbHNvIGJlIHJlbGF0ZWQuIFRoaW5ncyBsaWtlIHByZWFtYmxlcywgY29udGVudCBzcGxpdCBieSBhZHNcbiAgICAgIC8vIHRoYXQgd2UgcmVtb3ZlZCwgZXRjLlxuICAgICAgdmFyIGFydGljbGVDb250ZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICBpZiAoaXNQYWdpbmcpXG4gICAgICAgIGFydGljbGVDb250ZW50LmlkID0gXCJyZWFkYWJpbGl0eS1jb250ZW50XCI7XG5cbiAgICAgIHZhciBzaWJsaW5nU2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1heCgxMCwgdG9wQ2FuZGlkYXRlLnJlYWRhYmlsaXR5LmNvbnRlbnRTY29yZSAqIDAuMik7XG4gICAgICAvLyBLZWVwIHBvdGVudGlhbCB0b3AgY2FuZGlkYXRlJ3MgcGFyZW50IG5vZGUgdG8gdHJ5IHRvIGdldCB0ZXh0IGRpcmVjdGlvbiBvZiBpdCBsYXRlci5cbiAgICAgIHBhcmVudE9mVG9wQ2FuZGlkYXRlID0gdG9wQ2FuZGlkYXRlLnBhcmVudE5vZGU7XG4gICAgICB2YXIgc2libGluZ3MgPSBwYXJlbnRPZlRvcENhbmRpZGF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgcyA9IDAsIHNsID0gc2libGluZ3MubGVuZ3RoOyBzIDwgc2w7IHMrKykge1xuICAgICAgICB2YXIgc2libGluZyA9IHNpYmxpbmdzW3NdO1xuICAgICAgICB2YXIgYXBwZW5kID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sb2coXCJMb29raW5nIGF0IHNpYmxpbmcgbm9kZTpcIiwgc2libGluZywgc2libGluZy5yZWFkYWJpbGl0eSA/IChcIndpdGggc2NvcmUgXCIgKyBzaWJsaW5nLnJlYWRhYmlsaXR5LmNvbnRlbnRTY29yZSkgOiBcIlwiKTtcbiAgICAgICAgdGhpcy5sb2coXCJTaWJsaW5nIGhhcyBzY29yZVwiLCBzaWJsaW5nLnJlYWRhYmlsaXR5ID8gc2libGluZy5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgOiBcIlVua25vd25cIik7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgPT09IHRvcENhbmRpZGF0ZSkge1xuICAgICAgICAgIGFwcGVuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRCb251cyA9IDA7XG5cbiAgICAgICAgICAvLyBHaXZlIGEgYm9udXMgaWYgc2libGluZyBub2RlcyBhbmQgdG9wIGNhbmRpZGF0ZXMgaGF2ZSB0aGUgZXhhbXBsZSBzYW1lIGNsYXNzbmFtZVxuICAgICAgICAgIGlmIChzaWJsaW5nLmNsYXNzTmFtZSA9PT0gdG9wQ2FuZGlkYXRlLmNsYXNzTmFtZSAmJiB0b3BDYW5kaWRhdGUuY2xhc3NOYW1lICE9PSBcIlwiKVxuICAgICAgICAgICAgY29udGVudEJvbnVzICs9IHRvcENhbmRpZGF0ZS5yZWFkYWJpbGl0eS5jb250ZW50U2NvcmUgKiAwLjI7XG5cbiAgICAgICAgICBpZiAoc2libGluZy5yZWFkYWJpbGl0eSAmJlxuICAgICAgICAgICAgICAoKHNpYmxpbmcucmVhZGFiaWxpdHkuY29udGVudFNjb3JlICsgY29udGVudEJvbnVzKSA+PSBzaWJsaW5nU2NvcmVUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBhcHBlbmQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2libGluZy5ub2RlTmFtZSA9PT0gXCJQXCIpIHtcbiAgICAgICAgICAgIHZhciBsaW5rRGVuc2l0eSA9IHRoaXMuX2dldExpbmtEZW5zaXR5KHNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIG5vZGVDb250ZW50ID0gdGhpcy5fZ2V0SW5uZXJUZXh0KHNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSBub2RlQ29udGVudC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChub2RlTGVuZ3RoID4gODAgJiYgbGlua0RlbnNpdHkgPCAwLjI1KSB7XG4gICAgICAgICAgICAgIGFwcGVuZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVMZW5ndGggPCA4MCAmJiBub2RlTGVuZ3RoID4gMCAmJiBsaW5rRGVuc2l0eSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICBub2RlQ29udGVudC5zZWFyY2goL1xcLiggfCQpLykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGFwcGVuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgIHRoaXMubG9nKFwiQXBwZW5kaW5nIG5vZGU6XCIsIHNpYmxpbmcpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuQUxURVJfVE9fRElWX0VYQ0VQVElPTlMuaW5kZXhPZihzaWJsaW5nLm5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBub2RlIHRoYXQgaXNuJ3QgYSBjb21tb24gYmxvY2sgbGV2ZWwgZWxlbWVudCwgbGlrZSBhIGZvcm0gb3IgdGQgdGFnLlxuICAgICAgICAgICAgLy8gVHVybiBpdCBpbnRvIGEgZGl2IHNvIGl0IGRvZXNuJ3QgZ2V0IGZpbHRlcmVkIG91dCBsYXRlciBieSBhY2NpZGVudC5cbiAgICAgICAgICAgIHRoaXMubG9nKFwiQWx0ZXJpbmcgc2libGluZzpcIiwgc2libGluZywgXCJ0byBkaXYuXCIpO1xuXG4gICAgICAgICAgICBzaWJsaW5nID0gdGhpcy5fc2V0Tm9kZVRhZyhzaWJsaW5nLCBcIkRJVlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnRpY2xlQ29udGVudC5hcHBlbmRDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICAvLyBGZXRjaCBjaGlsZHJlbiBhZ2FpbiB0byBtYWtlIGl0IGNvbXBhdGlibGVcbiAgICAgICAgICAvLyB3aXRoIERPTSBwYXJzZXJzIHdpdGhvdXQgbGl2ZSBjb2xsZWN0aW9uIHN1cHBvcnQuXG4gICAgICAgICAgc2libGluZ3MgPSBwYXJlbnRPZlRvcENhbmRpZGF0ZS5jaGlsZHJlbjtcbiAgICAgICAgICAvLyBzaWJsaW5ncyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgY2hpbGRyZW4gYXJyYXksIGFuZFxuICAgICAgICAgIC8vIHNpYmxpbmcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheSB3aGVuIHdlIGNhbGwgYXBwZW5kQ2hpbGQoKS5cbiAgICAgICAgICAvLyBBcyBhIHJlc3VsdCwgd2UgbXVzdCByZXZpc2l0IHRoaXMgaW5kZXggc2luY2UgdGhlIG5vZGVzXG4gICAgICAgICAgLy8gaGF2ZSBiZWVuIHNoaWZ0ZWQuXG4gICAgICAgICAgcyAtPSAxO1xuICAgICAgICAgIHNsIC09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RlYnVnKVxuICAgICAgICB0aGlzLmxvZyhcIkFydGljbGUgY29udGVudCBwcmUtcHJlcDogXCIgKyBhcnRpY2xlQ29udGVudC5pbm5lckhUTUwpO1xuICAgICAgLy8gU28gd2UgaGF2ZSBhbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3ZSBuZWVkLiBOb3cgd2UgY2xlYW4gaXQgdXAgZm9yIHByZXNlbnRhdGlvbi5cbiAgICAgIHRoaXMuX3ByZXBBcnRpY2xlKGFydGljbGVDb250ZW50KTtcbiAgICAgIGlmICh0aGlzLl9kZWJ1ZylcbiAgICAgICAgdGhpcy5sb2coXCJBcnRpY2xlIGNvbnRlbnQgcG9zdC1wcmVwOiBcIiArIGFydGljbGVDb250ZW50LmlubmVySFRNTCk7XG5cbiAgICAgIGlmIChuZWVkZWRUb0NyZWF0ZVRvcENhbmRpZGF0ZSkge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGNyZWF0ZWQgYSBmYWtlIGRpdiB0aGluZywgYW5kIHRoZXJlIHdvdWxkbid0IGhhdmUgYmVlbiBhbnkgc2libGluZ3MgbGVmdFxuICAgICAgICAvLyBmb3IgdGhlIHByZXZpb3VzIGxvb3AsIHNvIHRoZXJlJ3Mgbm8gcG9pbnQgdHJ5aW5nIHRvIGNyZWF0ZSBhIG5ldyBkaXYsIGFuZCB0aGVuXG4gICAgICAgIC8vIG1vdmUgYWxsIHRoZSBjaGlsZHJlbiBvdmVyLiBKdXN0IGFzc2lnbiBJRHMgYW5kIGNsYXNzIG5hbWVzIGhlcmUuIE5vIG5lZWQgdG8gYXBwZW5kXG4gICAgICAgIC8vIGJlY2F1c2UgdGhhdCBhbHJlYWR5IGhhcHBlbmVkIGFueXdheS5cbiAgICAgICAgdG9wQ2FuZGlkYXRlLmlkID0gXCJyZWFkYWJpbGl0eS1wYWdlLTFcIjtcbiAgICAgICAgdG9wQ2FuZGlkYXRlLmNsYXNzTmFtZSA9IFwicGFnZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBkaXYuaWQgPSBcInJlYWRhYmlsaXR5LXBhZ2UtMVwiO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJwYWdlXCI7XG4gICAgICAgIHdoaWxlIChhcnRpY2xlQ29udGVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGFydGljbGVDb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGFydGljbGVDb250ZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kZWJ1ZylcbiAgICAgICAgdGhpcy5sb2coXCJBcnRpY2xlIGNvbnRlbnQgYWZ0ZXIgcGFnaW5nOiBcIiArIGFydGljbGVDb250ZW50LmlubmVySFRNTCk7XG5cbiAgICAgIHZhciBwYXJzZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBnb25lIHRocm91Z2ggdGhlIGZ1bGwgYWxnb3JpdGhtLCBjaGVjayB0byBzZWUgaWZcbiAgICAgIC8vIHdlIGdvdCBhbnkgbWVhbmluZ2Z1bCBjb250ZW50LiBJZiB3ZSBkaWRuJ3QsIHdlIG1heSBuZWVkIHRvIHJlLXJ1blxuICAgICAgLy8gZ3JhYkFydGljbGUgd2l0aCBkaWZmZXJlbnQgZmxhZ3Mgc2V0LiBUaGlzIGdpdmVzIHVzIGEgaGlnaGVyIGxpa2VsaWhvb2Qgb2ZcbiAgICAgIC8vIGZpbmRpbmcgdGhlIGNvbnRlbnQsIGFuZCB0aGUgc2lldmUgYXBwcm9hY2ggZ2l2ZXMgdXMgYSBoaWdoZXIgbGlrZWxpaG9vZCBvZlxuICAgICAgLy8gZmluZGluZyB0aGUgLXJpZ2h0LSBjb250ZW50LlxuICAgICAgdmFyIHRleHRMZW5ndGggPSB0aGlzLl9nZXRJbm5lclRleHQoYXJ0aWNsZUNvbnRlbnQsIHRydWUpLmxlbmd0aDtcbiAgICAgIGlmICh0ZXh0TGVuZ3RoIDwgdGhpcy5fY2hhclRocmVzaG9sZCkge1xuICAgICAgICBwYXJzZVN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgcGFnZS5pbm5lckhUTUwgPSBwYWdlQ2FjaGVIdG1sO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSXNBY3RpdmUodGhpcy5GTEFHX1NUUklQX1VOTElLRUxZUykpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVGbGFnKHRoaXMuRkxBR19TVFJJUF9VTkxJS0VMWVMpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRzLnB1c2goe2FydGljbGVDb250ZW50OiBhcnRpY2xlQ29udGVudCwgdGV4dExlbmd0aDogdGV4dExlbmd0aH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdJc0FjdGl2ZSh0aGlzLkZMQUdfV0VJR0hUX0NMQVNTRVMpKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRmxhZyh0aGlzLkZMQUdfV0VJR0hUX0NMQVNTRVMpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRzLnB1c2goe2FydGljbGVDb250ZW50OiBhcnRpY2xlQ29udGVudCwgdGV4dExlbmd0aDogdGV4dExlbmd0aH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdJc0FjdGl2ZSh0aGlzLkZMQUdfQ0xFQU5fQ09ORElUSU9OQUxMWSkpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVGbGFnKHRoaXMuRkxBR19DTEVBTl9DT05ESVRJT05BTExZKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0cy5wdXNoKHthcnRpY2xlQ29udGVudDogYXJ0aWNsZUNvbnRlbnQsIHRleHRMZW5ndGg6IHRleHRMZW5ndGh9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0cy5wdXNoKHthcnRpY2xlQ29udGVudDogYXJ0aWNsZUNvbnRlbnQsIHRleHRMZW5ndGg6IHRleHRMZW5ndGh9KTtcbiAgICAgICAgICAvLyBObyBsdWNrIGFmdGVyIHJlbW92aW5nIGZsYWdzLCBqdXN0IHJldHVybiB0aGUgbG9uZ2VzdCB0ZXh0IHdlIGZvdW5kIGR1cmluZyB0aGUgZGlmZmVyZW50IGxvb3BzXG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIudGV4dExlbmd0aCAtIGEudGV4dExlbmd0aDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEJ1dCBmaXJzdCBjaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHNvbWV0aGluZ1xuICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdHNbMF0udGV4dExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJ0aWNsZUNvbnRlbnQgPSB0aGlzLl9hdHRlbXB0c1swXS5hcnRpY2xlQ29udGVudDtcbiAgICAgICAgICBwYXJzZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZVN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgLy8gRmluZCBvdXQgdGV4dCBkaXJlY3Rpb24gZnJvbSBhbmNlc3RvcnMgb2YgZmluYWwgdG9wIGNhbmRpZGF0ZS5cbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFtwYXJlbnRPZlRvcENhbmRpZGF0ZSwgdG9wQ2FuZGlkYXRlXS5jb25jYXQodGhpcy5fZ2V0Tm9kZUFuY2VzdG9ycyhwYXJlbnRPZlRvcENhbmRpZGF0ZSkpO1xuICAgICAgICB0aGlzLl9zb21lTm9kZShhbmNlc3RvcnMsIGZ1bmN0aW9uKGFuY2VzdG9yKSB7XG4gICAgICAgICAgaWYgKCFhbmNlc3Rvci50YWdOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhciBhcnRpY2xlRGlyID0gYW5jZXN0b3IuZ2V0QXR0cmlidXRlKFwiZGlyXCIpO1xuICAgICAgICAgIGlmIChhcnRpY2xlRGlyKSB7XG4gICAgICAgICAgICB0aGlzLl9hcnRpY2xlRGlyID0gYXJ0aWNsZURpcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJ0aWNsZUNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBzdHJpbmcgY291bGQgYmUgYSBieWxpbmUuXG4gICAqIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgaW5wdXQgaXMgYSBzdHJpbmcsIGFuZCB0aGF0IHRoZSBsZW5ndGhcbiAgICogaXMgbGVzcyB0aGFuIDEwMCBjaGFycy5cbiAgICpcbiAgICogQHBhcmFtIHBvc3NpYmxlQnlsaW5lIHtzdHJpbmd9IC0gYSBzdHJpbmcgdG8gY2hlY2sgd2hldGhlciBpdHMgYSBieWxpbmUuXG4gICAqIEByZXR1cm4gQm9vbGVhbiAtIHdoZXRoZXIgdGhlIGlucHV0IHN0cmluZyBpcyBhIGJ5bGluZS5cbiAgICovXG4gIF9pc1ZhbGlkQnlsaW5lOiBmdW5jdGlvbihieWxpbmUpIHtcbiAgICBpZiAodHlwZW9mIGJ5bGluZSA9PSBcInN0cmluZ1wiIHx8IGJ5bGluZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgYnlsaW5lID0gYnlsaW5lLnRyaW0oKTtcbiAgICAgIHJldHVybiAoYnlsaW5lLmxlbmd0aCA+IDApICYmIChieWxpbmUubGVuZ3RoIDwgMTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBzb21lIG9mIHRoZSBjb21tb24gSFRNTCBlbnRpdGllcyBpbiBzdHJpbmcgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyIHtzdHJpbmd9IC0gYSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm4gc3RyaW5nIHdpdGhvdXQgSFRNTCBlbnRpdHkuXG4gICAqL1xuICBfdW5lc2NhcGVIdG1sRW50aXRpZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBodG1sRXNjYXBlTWFwID0gdGhpcy5IVE1MX0VTQ0FQRV9NQVA7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKHF1b3R8YW1wfGFwb3N8bHR8Z3QpOy9nLCBmdW5jdGlvbihfLCB0YWcpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlTWFwW3RhZ107XG4gICAgfSkucmVwbGFjZSgvJiMoPzp4KFswLTlhLXpdezEsNH0pfChbMC05XXsxLDR9KSk7L2dpLCBmdW5jdGlvbihfLCBoZXgsIG51bVN0cikge1xuICAgICAgdmFyIG51bSA9IHBhcnNlSW50KGhleCB8fCBudW1TdHIsIGhleCA/IDE2IDogMTApO1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobnVtKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVHJ5IHRvIGV4dHJhY3QgbWV0YWRhdGEgZnJvbSBKU09OLUxEIG9iamVjdC5cbiAgICogRm9yIG5vdywgb25seSBTY2hlbWEub3JnIG9iamVjdHMgb2YgdHlwZSBBcnRpY2xlIG9yIGl0cyBzdWJ0eXBlcyBhcmUgc3VwcG9ydGVkLlxuICAgKiBAcmV0dXJuIE9iamVjdCB3aXRoIGFueSBtZXRhZGF0YSB0aGF0IGNvdWxkIGJlIGV4dHJhY3RlZCAocG9zc2libHkgbm9uZSlcbiAgICovXG4gIF9nZXRKU09OTEQ6IGZ1bmN0aW9uIChkb2MpIHtcbiAgICB2YXIgc2NyaXB0cyA9IHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhkb2MsIFtcInNjcmlwdFwiXSk7XG5cbiAgICB2YXIgbWV0YWRhdGE7XG5cbiAgICB0aGlzLl9mb3JFYWNoTm9kZShzY3JpcHRzLCBmdW5jdGlvbihqc29uTGRFbGVtZW50KSB7XG4gICAgICBpZiAoIW1ldGFkYXRhICYmIGpzb25MZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTdHJpcCBDREFUQSBtYXJrZXJzIGlmIHByZXNlbnRcbiAgICAgICAgICB2YXIgY29udGVudCA9IGpzb25MZEVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nLCBcIlwiKTtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhcGFyc2VkW1wiQGNvbnRleHRcIl0gfHxcbiAgICAgICAgICAgICFwYXJzZWRbXCJAY29udGV4dFwiXS5tYXRjaCgvXmh0dHBzP1xcOlxcL1xcL3NjaGVtYVxcLm9yZyQvKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcGFyc2VkW1wiQHR5cGVcIl0gJiYgQXJyYXkuaXNBcnJheShwYXJzZWRbXCJAZ3JhcGhcIl0pKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZWRbXCJAZ3JhcGhcIl0uZmluZChmdW5jdGlvbihpdCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGl0W1wiQHR5cGVcIl0gfHwgXCJcIikubWF0Y2goXG4gICAgICAgICAgICAgICAgdGhpcy5SRUdFWFBTLmpzb25MZEFydGljbGVUeXBlc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXBhcnNlZCB8fFxuICAgICAgICAgICAgIXBhcnNlZFtcIkB0eXBlXCJdIHx8XG4gICAgICAgICAgICAhcGFyc2VkW1wiQHR5cGVcIl0ubWF0Y2godGhpcy5SRUdFWFBTLmpzb25MZEFydGljbGVUeXBlcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcGFyc2VkLmhlYWRsaW5lID09PSBcInN0cmluZ1wiICYmIHBhcnNlZC5uYW1lICE9PSBwYXJzZWQuaGVhZGxpbmUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgYm90aCBuYW1lIGFuZCBoZWFkbGluZSBlbGVtZW50IGluIHRoZSBKU09OLUxELiBUaGV5IHNob3VsZCBib3RoIGJlIHRoZSBzYW1lIGJ1dCBzb21lIHdlYnNpdGVzIGxpa2UgYWt0dWFsbmUuY3pcbiAgICAgICAgICAgIC8vIHB1dCB0aGVpciBvd24gbmFtZSBpbnRvIFwibmFtZVwiIGFuZCB0aGUgYXJ0aWNsZSB0aXRsZSB0byBcImhlYWRsaW5lXCIgd2hpY2ggY29uZnVzZXMgUmVhZGFiaWxpdHkuIFNvIHdlIHRyeSB0byBjaGVjayBpZiBlaXRoZXJcbiAgICAgICAgICAgIC8vIFwibmFtZVwiIG9yIFwiaGVhZGxpbmVcIiBjbG9zZWx5IG1hdGNoZXMgdGhlIGh0bWwgdGl0bGUsIGFuZCBpZiBzbywgdXNlIHRoYXQgb25lLiBJZiBub3QsIHRoZW4gd2UgdXNlIFwibmFtZVwiIGJ5IGRlZmF1bHQuXG5cbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuX2dldEFydGljbGVUaXRsZSgpO1xuICAgICAgICAgICAgdmFyIG5hbWVNYXRjaGVzID0gdGhpcy5fdGV4dFNpbWlsYXJpdHkocGFyc2VkLm5hbWUsIHRpdGxlKSA+IDAuNzU7XG4gICAgICAgICAgICB2YXIgaGVhZGxpbmVNYXRjaGVzID0gdGhpcy5fdGV4dFNpbWlsYXJpdHkocGFyc2VkLmhlYWRsaW5lLCB0aXRsZSkgPiAwLjc1O1xuXG4gICAgICAgICAgICBpZiAoaGVhZGxpbmVNYXRjaGVzICYmICFuYW1lTWF0Y2hlcykge1xuICAgICAgICAgICAgICBtZXRhZGF0YS50aXRsZSA9IHBhcnNlZC5oZWFkbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnRpdGxlID0gcGFyc2VkLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyc2VkLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLnRpdGxlID0gcGFyc2VkLm5hbWUudHJpbSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnNlZC5oZWFkbGluZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWV0YWRhdGEudGl0bGUgPSBwYXJzZWQuaGVhZGxpbmUudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyc2VkLmF1dGhvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuYXV0aG9yLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEuYnlsaW5lID0gcGFyc2VkLmF1dGhvci5uYW1lLnRyaW0oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQuYXV0aG9yKSAmJiBwYXJzZWQuYXV0aG9yWzBdICYmIHR5cGVvZiBwYXJzZWQuYXV0aG9yWzBdLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEuYnlsaW5lID0gcGFyc2VkLmF1dGhvclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYXV0aG9yKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yICYmIHR5cGVvZiBhdXRob3IubmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYXV0aG9yKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yLm5hbWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuZGVzY3JpcHRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmV4Y2VycHQgPSBwYXJzZWQuZGVzY3JpcHRpb24udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJzZWQucHVibGlzaGVyICYmXG4gICAgICAgICAgICB0eXBlb2YgcGFyc2VkLnB1Ymxpc2hlci5uYW1lID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5zaXRlTmFtZSA9IHBhcnNlZC5wdWJsaXNoZXIubmFtZS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkLmRhdGVQdWJsaXNoZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmRhdGVQdWJsaXNoZWQgPSBwYXJzZWQuZGF0ZVB1Ymxpc2hlZC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5sb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhID8gbWV0YWRhdGEgOiB7fTtcbiAgfSxcblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZ2V0IGV4Y2VycHQgYW5kIGJ5bGluZSBtZXRhZGF0YSBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29ubGQg4oCUIG9iamVjdCBjb250YWluaW5nIGFueSBtZXRhZGF0YSB0aGF0XG4gICAqIGNvdWxkIGJlIGV4dHJhY3RlZCBmcm9tIEpTT04tTEQgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIE9iamVjdCB3aXRoIG9wdGlvbmFsIFwiZXhjZXJwdFwiIGFuZCBcImJ5bGluZVwiIHByb3BlcnRpZXNcbiAgICovXG4gIF9nZXRBcnRpY2xlTWV0YWRhdGE6IGZ1bmN0aW9uKGpzb25sZCkge1xuICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICB2YXIgbWV0YUVsZW1lbnRzID0gdGhpcy5fZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWV0YVwiKTtcblxuICAgIC8vIHByb3BlcnR5IGlzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzXG4gICAgdmFyIHByb3BlcnR5UGF0dGVybiA9IC9cXHMqKGFydGljbGV8ZGN8ZGN0ZXJtfG9nfHR3aXR0ZXIpXFxzKjpcXHMqKGF1dGhvcnxjcmVhdG9yfGRlc2NyaXB0aW9ufHB1Ymxpc2hlZF90aW1lfHRpdGxlfHNpdGVfbmFtZSlcXHMqL2dpO1xuXG4gICAgLy8gbmFtZSBpcyBhIHNpbmdsZSB2YWx1ZVxuICAgIHZhciBuYW1lUGF0dGVybiA9IC9eXFxzKig/OihkY3xkY3Rlcm18b2d8dHdpdHRlcnx3ZWlibzooYXJ0aWNsZXx3ZWJwYWdlKSlcXHMqW1xcLjpdXFxzKik/KGF1dGhvcnxjcmVhdG9yfGRlc2NyaXB0aW9ufHRpdGxlfHNpdGVfbmFtZSlcXHMqJC9pO1xuXG4gICAgLy8gRmluZCBkZXNjcmlwdGlvbiB0YWdzLlxuICAgIHRoaXMuX2ZvckVhY2hOb2RlKG1ldGFFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGVsZW1lbnROYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgdmFyIGVsZW1lbnRQcm9wZXJ0eSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicHJvcGVydHlcIik7XG4gICAgICB2YXIgY29udGVudCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKTtcbiAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2hlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZSA9IG51bGw7XG5cbiAgICAgIGlmIChlbGVtZW50UHJvcGVydHkpIHtcbiAgICAgICAgbWF0Y2hlcyA9IGVsZW1lbnRQcm9wZXJ0eS5tYXRjaChwcm9wZXJ0eVBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIENvbnZlcnQgdG8gbG93ZXJjYXNlLCBhbmQgcmVtb3ZlIGFueSB3aGl0ZXNwYWNlXG4gICAgICAgICAgLy8gc28gd2UgY2FuIG1hdGNoIGJlbG93LlxuICAgICAgICAgIG5hbWUgPSBtYXRjaGVzWzBdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xuICAgICAgICAgIC8vIG11bHRpcGxlIGF1dGhvcnNcbiAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSBjb250ZW50LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaGVzICYmIGVsZW1lbnROYW1lICYmIG5hbWVQYXR0ZXJuLnRlc3QoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRvIGxvd2VyY2FzZSwgcmVtb3ZlIGFueSB3aGl0ZXNwYWNlLCBhbmQgY29udmVydCBkb3RzXG4gICAgICAgICAgLy8gdG8gY29sb25zIHNvIHdlIGNhbiBtYXRjaCBiZWxvdy5cbiAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5yZXBsYWNlKC9cXC4vZywgXCI6XCIpO1xuICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IGNvbnRlbnQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBnZXQgdGl0bGVcbiAgICBtZXRhZGF0YS50aXRsZSA9IGpzb25sZC50aXRsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW1wiZGM6dGl0bGVcIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcImRjdGVybTp0aXRsZVwiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW1wib2c6dGl0bGVcIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcIndlaWJvOmFydGljbGU6dGl0bGVcIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcIndlaWJvOndlYnBhZ2U6dGl0bGVcIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcInRpdGxlXCJdIHx8XG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbXCJ0d2l0dGVyOnRpdGxlXCJdO1xuXG4gICAgaWYgKCFtZXRhZGF0YS50aXRsZSkge1xuICAgICAgbWV0YWRhdGEudGl0bGUgPSB0aGlzLl9nZXRBcnRpY2xlVGl0bGUoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYXV0aG9yXG4gICAgbWV0YWRhdGEuYnlsaW5lID0ganNvbmxkLmJ5bGluZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcImRjOmNyZWF0b3JcIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbXCJkY3Rlcm06Y3JlYXRvclwiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcImF1dGhvclwiXTtcblxuICAgIC8vIGdldCBkZXNjcmlwdGlvblxuICAgIG1ldGFkYXRhLmV4Y2VycHQgPSBqc29ubGQuZXhjZXJwdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbXCJkYzpkZXNjcmlwdGlvblwiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbXCJkY3Rlcm06ZGVzY3JpcHRpb25cIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW1wib2c6ZGVzY3JpcHRpb25cIl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW1wid2VpYm86YXJ0aWNsZTpkZXNjcmlwdGlvblwiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbXCJ3ZWlibzp3ZWJwYWdlOmRlc2NyaXB0aW9uXCJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcImRlc2NyaXB0aW9uXCJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcInR3aXR0ZXI6ZGVzY3JpcHRpb25cIl07XG5cbiAgICAvLyBnZXQgc2l0ZSBuYW1lXG4gICAgbWV0YWRhdGEuc2l0ZU5hbWUgPSBqc29ubGQuc2l0ZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tcIm9nOnNpdGVfbmFtZVwiXTtcblxuICAgIC8vIGdldCBhcnRpY2xlIHB1Ymxpc2hlZCB0aW1lXG4gICAgbWV0YWRhdGEucHVibGlzaGVkVGltZSA9IGpzb25sZC5kYXRlUHVibGlzaGVkIHx8XG4gICAgICB2YWx1ZXNbXCJhcnRpY2xlOnB1Ymxpc2hlZF90aW1lXCJdIHx8IG51bGw7XG5cbiAgICAvLyBpbiBtYW55IHNpdGVzIHRoZSBtZXRhIHZhbHVlIGlzIGVzY2FwZWQgd2l0aCBIVE1MIGVudGl0aWVzLFxuICAgIC8vIHNvIGhlcmUgd2UgbmVlZCB0byB1bmVzY2FwZSBpdFxuICAgIG1ldGFkYXRhLnRpdGxlID0gdGhpcy5fdW5lc2NhcGVIdG1sRW50aXRpZXMobWV0YWRhdGEudGl0bGUpO1xuICAgIG1ldGFkYXRhLmJ5bGluZSA9IHRoaXMuX3VuZXNjYXBlSHRtbEVudGl0aWVzKG1ldGFkYXRhLmJ5bGluZSk7XG4gICAgbWV0YWRhdGEuZXhjZXJwdCA9IHRoaXMuX3VuZXNjYXBlSHRtbEVudGl0aWVzKG1ldGFkYXRhLmV4Y2VycHQpO1xuICAgIG1ldGFkYXRhLnNpdGVOYW1lID0gdGhpcy5fdW5lc2NhcGVIdG1sRW50aXRpZXMobWV0YWRhdGEuc2l0ZU5hbWUpO1xuICAgIG1ldGFkYXRhLnB1Ymxpc2hlZFRpbWUgPSB0aGlzLl91bmVzY2FwZUh0bWxFbnRpdGllcyhtZXRhZGF0YS5wdWJsaXNoZWRUaW1lKTtcblxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgbm9kZSBpcyBpbWFnZSwgb3IgaWYgbm9kZSBjb250YWlucyBleGFjdGx5IG9ubHkgb25lIGltYWdlXG4gICAqIHdoZXRoZXIgYXMgYSBkaXJlY3QgY2hpbGQgb3IgYXMgaXRzIGRlc2NlbmRhbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAqKi9cbiAgX2lzU2luZ2xlSW1hZ2U6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIklNR1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgbm9kZS50ZXh0Q29udGVudC50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNTaW5nbGVJbWFnZShub2RlLmNoaWxkcmVuWzBdKTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCBhbGwgPG5vc2NyaXB0PiB0aGF0IGFyZSBsb2NhdGVkIGFmdGVyIDxpbWc+IG5vZGVzLCBhbmQgd2hpY2ggY29udGFpbiBvbmx5IG9uZVxuICAgKiA8aW1nPiBlbGVtZW50LiBSZXBsYWNlIHRoZSBmaXJzdCBpbWFnZSB3aXRoIHRoZSBpbWFnZSBmcm9tIGluc2lkZSB0aGUgPG5vc2NyaXB0PiB0YWcsXG4gICAqIGFuZCByZW1vdmUgdGhlIDxub3NjcmlwdD4gdGFnLiBUaGlzIGltcHJvdmVzIHRoZSBxdWFsaXR5IG9mIHRoZSBpbWFnZXMgd2UgdXNlIG9uXG4gICAqIHNvbWUgc2l0ZXMgKGUuZy4gTWVkaXVtKS5cbiAgICpcbiAgICogQHBhcmFtIEVsZW1lbnRcbiAgKiovXG4gIF91bndyYXBOb3NjcmlwdEltYWdlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgLy8gRmluZCBpbWcgd2l0aG91dCBzb3VyY2Ugb3IgYXR0cmlidXRlcyB0aGF0IG1pZ2h0IGNvbnRhaW5zIGltYWdlLCBhbmQgcmVtb3ZlIGl0LlxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IGEgcGxhY2Vob2xkZXIgaW1nIGlzIHJlcGxhY2VkIGJ5IGltZyBmcm9tIG5vc2NyaXB0IGluIG5leHQgc3RlcC5cbiAgICB2YXIgaW1ncyA9IEFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpKTtcbiAgICB0aGlzLl9mb3JFYWNoTm9kZShpbWdzLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1nLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSBpbWcuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgc3dpdGNoIChhdHRyLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgICAgY2FzZSBcInNyY3NldFwiOlxuICAgICAgICAgIGNhc2UgXCJkYXRhLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJkYXRhLXNyY3NldFwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9cXC4oanBnfGpwZWd8cG5nfHdlYnApL2kudGVzdChhdHRyLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpO1xuICAgIH0pO1xuXG4gICAgLy8gTmV4dCBmaW5kIG5vc2NyaXB0IGFuZCB0cnkgdG8gZXh0cmFjdCBpdHMgaW1hZ2VcbiAgICB2YXIgbm9zY3JpcHRzID0gQXJyYXkuZnJvbShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJub3NjcmlwdFwiKSk7XG4gICAgdGhpcy5fZm9yRWFjaE5vZGUobm9zY3JpcHRzLCBmdW5jdGlvbihub3NjcmlwdCkge1xuICAgICAgLy8gUGFyc2UgY29udGVudCBvZiBub3NjcmlwdCBhbmQgbWFrZSBzdXJlIGl0IG9ubHkgY29udGFpbnMgaW1hZ2VcbiAgICAgIHZhciB0bXAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRtcC5pbm5lckhUTUwgPSBub3NjcmlwdC5pbm5lckhUTUw7XG4gICAgICBpZiAoIXRoaXMuX2lzU2luZ2xlSW1hZ2UodG1wKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vc2NyaXB0IGhhcyBwcmV2aW91cyBzaWJsaW5nIGFuZCBpdCBvbmx5IGNvbnRhaW5zIGltYWdlLFxuICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIG5vc2NyaXB0IGNvbnRlbnQuIEhvd2V2ZXIgd2UgYWxzbyBrZWVwIG9sZFxuICAgICAgLy8gYXR0cmlidXRlcyB0aGF0IG1pZ2h0IGNvbnRhaW5zIGltYWdlLlxuICAgICAgdmFyIHByZXZFbGVtZW50ID0gbm9zY3JpcHQucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgIGlmIChwcmV2RWxlbWVudCAmJiB0aGlzLl9pc1NpbmdsZUltYWdlKHByZXZFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHJldkltZyA9IHByZXZFbGVtZW50O1xuICAgICAgICBpZiAocHJldkltZy50YWdOYW1lICE9PSBcIklNR1wiKSB7XG4gICAgICAgICAgcHJldkltZyA9IHByZXZFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0ltZyA9IHRtcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKVswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2SW1nLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IHByZXZJbWcuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBpZiAoYXR0ci52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gXCJzcmNcIiB8fCBhdHRyLm5hbWUgPT09IFwic3Jjc2V0XCIgfHwgL1xcLihqcGd8anBlZ3xwbmd8d2VicCkvaS50ZXN0KGF0dHIudmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAobmV3SW1nLmdldEF0dHJpYnV0ZShhdHRyLm5hbWUpID09PSBhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICBpZiAobmV3SW1nLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgYXR0ck5hbWUgPSBcImRhdGEtb2xkLVwiICsgYXR0ck5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0ltZy5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vc2NyaXB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRtcC5maXJzdEVsZW1lbnRDaGlsZCwgcHJldkVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHNjcmlwdCB0YWdzIGZyb20gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAqKi9cbiAgX3JlbW92ZVNjcmlwdHM6IGZ1bmN0aW9uKGRvYykge1xuICAgIHRoaXMuX3JlbW92ZU5vZGVzKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhkb2MsIFtcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCJdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgbm9kZSBoYXMgb25seSB3aGl0ZXNwYWNlIGFuZCBhIHNpbmdsZSBlbGVtZW50IHdpdGggZ2l2ZW4gdGFnXG4gICAqIFJldHVybnMgZmFsc2UgaWYgdGhlIERJViBub2RlIGNvbnRhaW5zIG5vbi1lbXB0eSB0ZXh0IG5vZGVzXG4gICAqIG9yIGlmIGl0IGNvbnRhaW5zIG5vIGVsZW1lbnQgd2l0aCBnaXZlbiB0YWcgb3IgbW9yZSB0aGFuIDEgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIEVsZW1lbnRcbiAgICogQHBhcmFtIHN0cmluZyB0YWcgb2YgY2hpbGQgZWxlbWVudFxuICAqKi9cbiAgX2hhc1NpbmdsZVRhZ0luc2lkZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHRhZykge1xuICAgIC8vIFRoZXJlIHNob3VsZCBiZSBleGFjdGx5IDEgZWxlbWVudCBjaGlsZCB3aXRoIGdpdmVuIHRhZ1xuICAgIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAhPSAxIHx8IGVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSAhPT0gdGFnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQW5kIHRoZXJlIHNob3VsZCBiZSBubyB0ZXh0IG5vZGVzIHdpdGggcmVhbCBjb250ZW50XG4gICAgcmV0dXJuICF0aGlzLl9zb21lTm9kZShlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSB0aGlzLlRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgIHRoaXMuUkVHRVhQUy5oYXNDb250ZW50LnRlc3Qobm9kZS50ZXh0Q29udGVudCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX2lzRWxlbWVudFdpdGhvdXRDb250ZW50OiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHRoaXMuRUxFTUVOVF9OT0RFICYmXG4gICAgICBub2RlLnRleHRDb250ZW50LnRyaW0oKS5sZW5ndGggPT0gMCAmJlxuICAgICAgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHxcbiAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYnJcIikubGVuZ3RoICsgbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhyXCIpLmxlbmd0aCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGVsZW1lbnQgaGFzIGFueSBjaGlsZHJlbiBibG9jayBsZXZlbCBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIEVsZW1lbnRcbiAgICovXG4gIF9oYXNDaGlsZEJsb2NrRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fc29tZU5vZGUoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ESVZfVE9fUF9FTEVNUy5oYXMobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICAgICAgIHRoaXMuX2hhc0NoaWxkQmxvY2tFbGVtZW50KG5vZGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgbm9kZSBxdWFsaWZpZXMgYXMgcGhyYXNpbmcgY29udGVudC5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvSFRNTC9Db250ZW50X2NhdGVnb3JpZXMjUGhyYXNpbmdfY29udGVudFxuICAqKi9cbiAgX2lzUGhyYXNpbmdDb250ZW50OiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHRoaXMuVEVYVF9OT0RFIHx8IHRoaXMuUEhSQVNJTkdfRUxFTVMuaW5kZXhPZihub2RlLnRhZ05hbWUpICE9PSAtMSB8fFxuICAgICAgKChub2RlLnRhZ05hbWUgPT09IFwiQVwiIHx8IG5vZGUudGFnTmFtZSA9PT0gXCJERUxcIiB8fCBub2RlLnRhZ05hbWUgPT09IFwiSU5TXCIpICYmXG4gICAgICAgIHRoaXMuX2V2ZXJ5Tm9kZShub2RlLmNoaWxkTm9kZXMsIHRoaXMuX2lzUGhyYXNpbmdDb250ZW50KSk7XG4gIH0sXG5cbiAgX2lzV2hpdGVzcGFjZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gdGhpcy5URVhUX05PREUgJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAobm9kZS5ub2RlVHlwZSA9PT0gdGhpcy5FTEVNRU5UX05PREUgJiYgbm9kZS50YWdOYW1lID09PSBcIkJSXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlubmVyIHRleHQgb2YgYSBub2RlIC0gY3Jvc3MgYnJvd3NlciBjb21wYXRpYmx5LlxuICAgKiBUaGlzIGFsc28gc3RyaXBzIG91dCBhbnkgZXhjZXNzIHdoaXRlc3BhY2UgdG8gYmUgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEBwYXJhbSBCb29sZWFuIG5vcm1hbGl6ZVNwYWNlcyAoZGVmYXVsdDogdHJ1ZSlcbiAgICogQHJldHVybiBzdHJpbmdcbiAgKiovXG4gIF9nZXRJbm5lclRleHQ6IGZ1bmN0aW9uKGUsIG5vcm1hbGl6ZVNwYWNlcykge1xuICAgIG5vcm1hbGl6ZVNwYWNlcyA9ICh0eXBlb2Ygbm9ybWFsaXplU3BhY2VzID09PSBcInVuZGVmaW5lZFwiKSA/IHRydWUgOiBub3JtYWxpemVTcGFjZXM7XG4gICAgdmFyIHRleHRDb250ZW50ID0gZS50ZXh0Q29udGVudC50cmltKCk7XG5cbiAgICBpZiAobm9ybWFsaXplU3BhY2VzKSB7XG4gICAgICByZXR1cm4gdGV4dENvbnRlbnQucmVwbGFjZSh0aGlzLlJFR0VYUFMubm9ybWFsaXplLCBcIiBcIik7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgdGltZXMgYSBzdHJpbmcgcyBhcHBlYXJzIGluIHRoZSBub2RlIGUuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEBwYXJhbSBzdHJpbmcgLSB3aGF0IHRvIHNwbGl0IG9uLiBEZWZhdWx0IGlzIFwiLFwiXG4gICAqIEByZXR1cm4gbnVtYmVyIChpbnRlZ2VyKVxuICAqKi9cbiAgX2dldENoYXJDb3VudDogZnVuY3Rpb24oZSwgcykge1xuICAgIHMgPSBzIHx8IFwiLFwiO1xuICAgIHJldHVybiB0aGlzLl9nZXRJbm5lclRleHQoZSkuc3BsaXQocykubGVuZ3RoIC0gMTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzdHlsZSBhdHRyaWJ1dGUgb24gZXZlcnkgZSBhbmQgdW5kZXIuXG4gICAqIFRPRE86IFRlc3QgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoKikgaXMgZmFzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgKiovXG4gIF9jbGVhblN0eWxlczogZnVuY3Rpb24oZSkge1xuICAgIGlmICghZSB8fCBlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIilcbiAgICAgIHJldHVybjtcblxuICAgIC8vIFJlbW92ZSBgc3R5bGVgIGFuZCBkZXByZWNhdGVkIHByZXNlbnRhdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuUFJFU0VOVEFUSU9OQUxfQVRUUklCVVRFUy5sZW5ndGg7IGkrKykge1xuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5QUkVTRU5UQVRJT05BTF9BVFRSSUJVVEVTW2ldKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ERVBSRUNBVEVEX1NJWkVfQVRUUklCVVRFX0VMRU1TLmluZGV4T2YoZS50YWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKFwid2lkdGhcIik7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY3VyID0gZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9jbGVhblN0eWxlcyhjdXIpO1xuICAgICAgY3VyID0gY3VyLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVuc2l0eSBvZiBsaW5rcyBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGNvbnRlbnRcbiAgICogVGhpcyBpcyB0aGUgYW1vdW50IG9mIHRleHQgdGhhdCBpcyBpbnNpZGUgYSBsaW5rIGRpdmlkZWQgYnkgdGhlIHRvdGFsIHRleHQgaW4gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEByZXR1cm4gbnVtYmVyIChmbG9hdClcbiAgKiovXG4gIF9nZXRMaW5rRGVuc2l0eTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGhpcy5fZ2V0SW5uZXJUZXh0KGVsZW1lbnQpLmxlbmd0aDtcbiAgICBpZiAodGV4dExlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAwO1xuXG4gICAgdmFyIGxpbmtMZW5ndGggPSAwO1xuXG4gICAgLy8gWFhYIGltcGxlbWVudCBfcmVkdWNlTm9kZUxpc3Q/XG4gICAgdGhpcy5fZm9yRWFjaE5vZGUoZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIiksIGZ1bmN0aW9uKGxpbmtOb2RlKSB7XG4gICAgICB2YXIgaHJlZiA9IGxpbmtOb2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICB2YXIgY29lZmZpY2llbnQgPSBocmVmICYmIHRoaXMuUkVHRVhQUy5oYXNoVXJsLnRlc3QoaHJlZikgPyAwLjMgOiAxO1xuICAgICAgbGlua0xlbmd0aCArPSB0aGlzLl9nZXRJbm5lclRleHQobGlua05vZGUpLmxlbmd0aCAqIGNvZWZmaWNpZW50O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxpbmtMZW5ndGggLyB0ZXh0TGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZWxlbWVudHMgY2xhc3MvaWQgd2VpZ2h0LiBVc2VzIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gdGVsbCBpZiB0aGlzXG4gICAqIGVsZW1lbnQgbG9va3MgZ29vZCBvciBiYWQuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEByZXR1cm4gbnVtYmVyIChJbnRlZ2VyKVxuICAqKi9cbiAgX2dldENsYXNzV2VpZ2h0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLl9mbGFnSXNBY3RpdmUodGhpcy5GTEFHX1dFSUdIVF9DTEFTU0VTKSlcbiAgICAgIHJldHVybiAwO1xuXG4gICAgdmFyIHdlaWdodCA9IDA7XG5cbiAgICAvLyBMb29rIGZvciBhIHNwZWNpYWwgY2xhc3NuYW1lXG4gICAgaWYgKHR5cGVvZihlLmNsYXNzTmFtZSkgPT09IFwic3RyaW5nXCIgJiYgZS5jbGFzc05hbWUgIT09IFwiXCIpIHtcbiAgICAgIGlmICh0aGlzLlJFR0VYUFMubmVnYXRpdmUudGVzdChlLmNsYXNzTmFtZSkpXG4gICAgICAgIHdlaWdodCAtPSAyNTtcblxuICAgICAgaWYgKHRoaXMuUkVHRVhQUy5wb3NpdGl2ZS50ZXN0KGUuY2xhc3NOYW1lKSlcbiAgICAgICAgd2VpZ2h0ICs9IDI1O1xuICAgIH1cblxuICAgIC8vIExvb2sgZm9yIGEgc3BlY2lhbCBJRFxuICAgIGlmICh0eXBlb2YoZS5pZCkgPT09IFwic3RyaW5nXCIgJiYgZS5pZCAhPT0gXCJcIikge1xuICAgICAgaWYgKHRoaXMuUkVHRVhQUy5uZWdhdGl2ZS50ZXN0KGUuaWQpKVxuICAgICAgICB3ZWlnaHQgLT0gMjU7XG5cbiAgICAgIGlmICh0aGlzLlJFR0VYUFMucG9zaXRpdmUudGVzdChlLmlkKSlcbiAgICAgICAgd2VpZ2h0ICs9IDI1O1xuICAgIH1cblxuICAgIHJldHVybiB3ZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFuIGEgbm9kZSBvZiBhbGwgZWxlbWVudHMgb2YgdHlwZSBcInRhZ1wiLlxuICAgKiAoVW5sZXNzIGl0J3MgYSB5b3V0dWJlL3ZpbWVvIHZpZGVvLiBQZW9wbGUgbG92ZSBtb3ZpZXMuKVxuICAgKlxuICAgKiBAcGFyYW0gRWxlbWVudFxuICAgKiBAcGFyYW0gc3RyaW5nIHRhZyB0byBjbGVhblxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICoqL1xuICBfY2xlYW46IGZ1bmN0aW9uKGUsIHRhZykge1xuICAgIHZhciBpc0VtYmVkID0gW1wib2JqZWN0XCIsIFwiZW1iZWRcIiwgXCJpZnJhbWVcIl0uaW5kZXhPZih0YWcpICE9PSAtMTtcblxuICAgIHRoaXMuX3JlbW92ZU5vZGVzKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhlLCBbdGFnXSksIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIEFsbG93IHlvdXR1YmUgYW5kIHZpbWVvIHZpZGVvcyB0aHJvdWdoIGFzIHBlb3BsZSB1c3VhbGx5IHdhbnQgdG8gc2VlIHRob3NlLlxuICAgICAgaWYgKGlzRW1iZWQpIHtcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIHRoZSBlbGVtZW50cyBhdHRyaWJ1dGVzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBjb250YWluIHlvdXR1YmUgb3IgdmltZW9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fYWxsb3dlZFZpZGVvUmVnZXgudGVzdChlbGVtZW50LmF0dHJpYnV0ZXNbaV0udmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGVtYmVkIHdpdGggPG9iamVjdD4gdGFnLCBjaGVjayBpbm5lciBIVE1MIGFzIHdlbGwuXG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5fYWxsb3dlZFZpZGVvUmVnZXgudGVzdChlbGVtZW50LmlubmVySFRNTCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgZ2l2ZW4gbm9kZSBoYXMgb25lIG9mIGl0cyBhbmNlc3RvciB0YWcgbmFtZSBtYXRjaGluZyB0aGVcbiAgICogcHJvdmlkZWQgb25lLlxuICAgKiBAcGFyYW0gIEhUTUxFbGVtZW50IG5vZGVcbiAgICogQHBhcmFtICBTdHJpbmcgICAgICB0YWdOYW1lXG4gICAqIEBwYXJhbSAgTnVtYmVyICAgICAgbWF4RGVwdGhcbiAgICogQHBhcmFtICBGdW5jdGlvbiAgICBmaWx0ZXJGbiBhIGZpbHRlciB0byBpbnZva2UgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBub2RlICdjb3VudHMnXG4gICAqIEByZXR1cm4gQm9vbGVhblxuICAgKi9cbiAgX2hhc0FuY2VzdG9yVGFnOiBmdW5jdGlvbihub2RlLCB0YWdOYW1lLCBtYXhEZXB0aCwgZmlsdGVyRm4pIHtcbiAgICBtYXhEZXB0aCA9IG1heERlcHRoIHx8IDM7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChtYXhEZXB0aCA+IDAgJiYgZGVwdGggPiBtYXhEZXB0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZS50YWdOYW1lID09PSB0YWdOYW1lICYmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4obm9kZS5wYXJlbnROb2RlKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGRlcHRoKys7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCBpbmRpY2F0aW5nIGhvdyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgdGhpcyB0YWJsZSBoYXMuXG4gICAqL1xuICBfZ2V0Um93QW5kQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIHJvd3MgPSAwO1xuICAgIHZhciBjb2x1bW5zID0gMDtcbiAgICB2YXIgdHJzID0gdGFibGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0clwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJvd3NwYW4gPSB0cnNbaV0uZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKSB8fCAwO1xuICAgICAgaWYgKHJvd3NwYW4pIHtcbiAgICAgICAgcm93c3BhbiA9IHBhcnNlSW50KHJvd3NwYW4sIDEwKTtcbiAgICAgIH1cbiAgICAgIHJvd3MgKz0gKHJvd3NwYW4gfHwgMSk7XG5cbiAgICAgIC8vIE5vdyBsb29rIGZvciBjb2x1bW4tcmVsYXRlZCBpbmZvXG4gICAgICB2YXIgY29sdW1uc0luVGhpc1JvdyA9IDA7XG4gICAgICB2YXIgY2VsbHMgPSB0cnNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2VsbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNvbHNwYW4gPSBjZWxsc1tqXS5nZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIpIHx8IDA7XG4gICAgICAgIGlmIChjb2xzcGFuKSB7XG4gICAgICAgICAgY29sc3BhbiA9IHBhcnNlSW50KGNvbHNwYW4sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zSW5UaGlzUm93ICs9IChjb2xzcGFuIHx8IDEpO1xuICAgICAgfVxuICAgICAgY29sdW1ucyA9IE1hdGgubWF4KGNvbHVtbnMsIGNvbHVtbnNJblRoaXNSb3cpO1xuICAgIH1cbiAgICByZXR1cm4ge3Jvd3M6IHJvd3MsIGNvbHVtbnM6IGNvbHVtbnN9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rIGZvciAnZGF0YScgKGFzIG9wcG9zZWQgdG8gJ2xheW91dCcpIHRhYmxlcywgZm9yIHdoaWNoIHdlIHVzZVxuICAgKiBzaW1pbGFyIGNoZWNrcyBhc1xuICAgKiBodHRwczovL3NlYXJjaGZveC5vcmcvbW96aWxsYS1jZW50cmFsL3Jldi9mODJkNWM1NDlmMDQ2Y2I2NGNlNTYwMmJmZDg5NGI3YWU4MDdjOGY4L2FjY2Vzc2libGUvZ2VuZXJpYy9UYWJsZUFjY2Vzc2libGUuY3BwIzE5XG4gICAqL1xuICBfbWFya0RhdGFUYWJsZXM6IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICB2YXIgdGFibGVzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRhYmxlXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGFibGUgPSB0YWJsZXNbaV07XG4gICAgICB2YXIgcm9sZSA9IHRhYmxlLmdldEF0dHJpYnV0ZShcInJvbGVcIik7XG4gICAgICBpZiAocm9sZSA9PSBcInByZXNlbnRhdGlvblwiKSB7XG4gICAgICAgIHRhYmxlLl9yZWFkYWJpbGl0eURhdGFUYWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhdGFibGUgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhdGFibGVcIik7XG4gICAgICBpZiAoZGF0YXRhYmxlID09IFwiMFwiKSB7XG4gICAgICAgIHRhYmxlLl9yZWFkYWJpbGl0eURhdGFUYWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdW1tYXJ5ID0gdGFibGUuZ2V0QXR0cmlidXRlKFwic3VtbWFyeVwiKTtcbiAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgIHRhYmxlLl9yZWFkYWJpbGl0eURhdGFUYWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdGlvbiA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FwdGlvblwiKVswXTtcbiAgICAgIGlmIChjYXB0aW9uICYmIGNhcHRpb24uY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRhYmxlLl9yZWFkYWJpbGl0eURhdGFUYWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgdGFibGUgaGFzIGEgZGVzY2VuZGFudCB3aXRoIGFueSBvZiB0aGVzZSB0YWdzLCBjb25zaWRlciBhIGRhdGEgdGFibGU6XG4gICAgICB2YXIgZGF0YVRhYmxlRGVzY2VuZGFudHMgPSBbXCJjb2xcIiwgXCJjb2xncm91cFwiLCBcInRmb290XCIsIFwidGhlYWRcIiwgXCJ0aFwiXTtcbiAgICAgIHZhciBkZXNjZW5kYW50RXhpc3RzID0gZnVuY3Rpb24odGFnKSB7XG4gICAgICAgIHJldHVybiAhIXRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZylbMF07XG4gICAgICB9O1xuICAgICAgaWYgKGRhdGFUYWJsZURlc2NlbmRhbnRzLnNvbWUoZGVzY2VuZGFudEV4aXN0cykpIHtcbiAgICAgICAgdGhpcy5sb2coXCJEYXRhIHRhYmxlIGJlY2F1c2UgZm91bmQgZGF0YS15IGRlc2NlbmRhbnRcIik7XG4gICAgICAgIHRhYmxlLl9yZWFkYWJpbGl0eURhdGFUYWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZXN0ZWQgdGFibGVzIGluZGljYXRlIGEgbGF5b3V0IHRhYmxlOlxuICAgICAgaWYgKHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGFibGVcIilbMF0pIHtcbiAgICAgICAgdGFibGUuX3JlYWRhYmlsaXR5RGF0YVRhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZUluZm8gPSB0aGlzLl9nZXRSb3dBbmRDb2x1bW5Db3VudCh0YWJsZSk7XG4gICAgICBpZiAoc2l6ZUluZm8ucm93cyA+PSAxMCB8fCBzaXplSW5mby5jb2x1bW5zID4gNCkge1xuICAgICAgICB0YWJsZS5fcmVhZGFiaWxpdHlEYXRhVGFibGUgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdyBqdXN0IGdvIGJ5IHNpemUgZW50aXJlbHk6XG4gICAgICB0YWJsZS5fcmVhZGFiaWxpdHlEYXRhVGFibGUgPSBzaXplSW5mby5yb3dzICogc2l6ZUluZm8uY29sdW1ucyA+IDEwO1xuICAgIH1cbiAgfSxcblxuICAvKiBjb252ZXJ0IGltYWdlcyBhbmQgZmlndXJlcyB0aGF0IGhhdmUgcHJvcGVydGllcyBsaWtlIGRhdGEtc3JjIGludG8gaW1hZ2VzIHRoYXQgY2FuIGJlIGxvYWRlZCB3aXRob3V0IEpTICovXG4gIF9maXhMYXp5SW1hZ2VzOiBmdW5jdGlvbiAocm9vdCkge1xuICAgIHRoaXMuX2ZvckVhY2hOb2RlKHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhyb290LCBbXCJpbWdcIiwgXCJwaWN0dXJlXCIsIFwiZmlndXJlXCJdKSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIC8vIEluIHNvbWUgc2l0ZXMgKGUuZy4gS290YWt1KSwgdGhleSBwdXQgMXB4IHNxdWFyZSBpbWFnZSBhcyBiYXNlNjQgZGF0YSB1cmkgaW4gdGhlIHNyYyBhdHRyaWJ1dGUuXG4gICAgICAvLyBTbywgaGVyZSB3ZSBjaGVjayBpZiB0aGUgZGF0YSB1cmkgaXMgdG9vIHNob3J0LCBqdXN0IG1pZ2h0IGFzIHdlbGwgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGVsZW0uc3JjICYmIHRoaXMuUkVHRVhQUy5iNjREYXRhVXJsLnRlc3QoZWxlbS5zcmMpKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBTVkcsIGJlY2F1c2UgU1ZHIGNhbiBoYXZlIGEgbWVhbmluZ2Z1bCBpbWFnZSBpbiB1bmRlciAxMzMgYnl0ZXMuXG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuUkVHRVhQUy5iNjREYXRhVXJsLmV4ZWMoZWxlbS5zcmMpO1xuICAgICAgICBpZiAocGFydHNbMV0gPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgZWxlbWVudCBoYXMgb3RoZXIgYXR0cmlidXRlcyB3aGljaCBjb250YWlucyBpbWFnZS5cbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCwgdGhlbiB0aGlzIHNyYyBpcyBpbXBvcnRhbnQgYW5kIHNob3VsZG4ndCBiZSByZW1vdmVkLlxuICAgICAgICB2YXIgc3JjQ291bGRCZVJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGVsZW0uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBcInNyY1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL1xcLihqcGd8anBlZ3xwbmd8d2VicCkvaS50ZXN0KGF0dHIudmFsdWUpKSB7XG4gICAgICAgICAgICBzcmNDb3VsZEJlUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZXJlIHdlIGFzc3VtZSBpZiBpbWFnZSBpcyBsZXNzIHRoYW4gMTAwIGJ5dGVzIChvciAxMzNCIGFmdGVyIGVuY29kZWQgdG8gYmFzZTY0KVxuICAgICAgICAvLyBpdCB3aWxsIGJlIHRvbyBzbWFsbCwgdGhlcmVmb3JlIGl0IG1pZ2h0IGJlIHBsYWNlaG9sZGVyIGltYWdlLlxuICAgICAgICBpZiAoc3JjQ291bGRCZVJlbW92ZWQpIHtcbiAgICAgICAgICB2YXIgYjY0c3RhcnRzID0gZWxlbS5zcmMuc2VhcmNoKC9iYXNlNjRcXHMqL2kpICsgNztcbiAgICAgICAgICB2YXIgYjY0bGVuZ3RoID0gZWxlbS5zcmMubGVuZ3RoIC0gYjY0c3RhcnRzO1xuICAgICAgICAgIGlmIChiNjRsZW5ndGggPCAxMzMpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhbHNvIGNoZWNrIGZvciBcIm51bGxcIiB0byB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vanNkb20vanNkb20vaXNzdWVzLzI1ODBcbiAgICAgIGlmICgoZWxlbS5zcmMgfHwgKGVsZW0uc3Jjc2V0ICYmIGVsZW0uc3Jjc2V0ICE9IFwibnVsbFwiKSkgJiYgZWxlbS5jbGFzc05hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibGF6eVwiKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW0uYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBhdHRyID0gZWxlbS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBcInNyY1wiIHx8IGF0dHIubmFtZSA9PT0gXCJzcmNzZXRcIiB8fCBhdHRyLm5hbWUgPT09IFwiYWx0XCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29weVRvID0gbnVsbDtcbiAgICAgICAgaWYgKC9cXC4oanBnfGpwZWd8cG5nfHdlYnApXFxzK1xcZC8udGVzdChhdHRyLnZhbHVlKSkge1xuICAgICAgICAgIGNvcHlUbyA9IFwic3Jjc2V0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL15cXHMqXFxTK1xcLihqcGd8anBlZ3xwbmd8d2VicClcXFMqXFxzKiQvLnRlc3QoYXR0ci52YWx1ZSkpIHtcbiAgICAgICAgICBjb3B5VG8gPSBcInNyY1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5VG8pIHtcbiAgICAgICAgICAvL2lmIHRoaXMgaXMgYW4gaW1nIG9yIHBpY3R1cmUsIHNldCB0aGUgYXR0cmlidXRlIGRpcmVjdGx5XG4gICAgICAgICAgaWYgKGVsZW0udGFnTmFtZSA9PT0gXCJJTUdcIiB8fCBlbGVtLnRhZ05hbWUgPT09IFwiUElDVFVSRVwiKSB7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShjb3B5VG8sIGF0dHIudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS50YWdOYW1lID09PSBcIkZJR1VSRVwiICYmICF0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoZWxlbSwgW1wiaW1nXCIsIFwicGljdHVyZVwiXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvL2lmIHRoZSBpdGVtIGlzIGEgPGZpZ3VyZT4gdGhhdCBkb2VzIG5vdCBjb250YWluIGFuIGltYWdlIG9yIHBpY3R1cmUsIGNyZWF0ZSBvbmUgYW5kIHBsYWNlIGl0IGluc2lkZSB0aGUgZmlndXJlXG4gICAgICAgICAgICAvL3NlZSB0aGUgbnl0aW1lcy0zIHRlc3RjYXNlIGZvciBhbiBleGFtcGxlXG4gICAgICAgICAgICB2YXIgaW1nID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKGNvcHlUbywgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgX2dldFRleHREZW5zaXR5OiBmdW5jdGlvbihlLCB0YWdzKSB7XG4gICAgdmFyIHRleHRMZW5ndGggPSB0aGlzLl9nZXRJbm5lclRleHQoZSwgdHJ1ZSkubGVuZ3RoO1xuICAgIGlmICh0ZXh0TGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gMDtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoZSwgdGFncyk7XG4gICAgdGhpcy5fZm9yRWFjaE5vZGUoY2hpbGRyZW4sIChjaGlsZCkgPT4gY2hpbGRyZW5MZW5ndGggKz0gdGhpcy5fZ2V0SW5uZXJUZXh0KGNoaWxkLCB0cnVlKS5sZW5ndGgpO1xuICAgIHJldHVybiBjaGlsZHJlbkxlbmd0aCAvIHRleHRMZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFuIGFuIGVsZW1lbnQgb2YgYWxsIHRhZ3Mgb2YgdHlwZSBcInRhZ1wiIGlmIHRoZXkgbG9vayBmaXNoeS5cbiAgICogXCJGaXNoeVwiIGlzIGFuIGFsZ29yaXRobSBiYXNlZCBvbiBjb250ZW50IGxlbmd0aCwgY2xhc3NuYW1lcywgbGluayBkZW5zaXR5LCBudW1iZXIgb2YgaW1hZ2VzICYgZW1iZWRzLCBldGMuXG4gICAqXG4gICAqIEByZXR1cm4gdm9pZFxuICAgKiovXG4gIF9jbGVhbkNvbmRpdGlvbmFsbHk6IGZ1bmN0aW9uKGUsIHRhZykge1xuICAgIGlmICghdGhpcy5fZmxhZ0lzQWN0aXZlKHRoaXMuRkxBR19DTEVBTl9DT05ESVRJT05BTExZKSlcbiAgICAgIHJldHVybjtcblxuICAgIC8vIEdhdGhlciBjb3VudHMgZm9yIG90aGVyIHR5cGljYWwgZWxlbWVudHMgZW1iZWRkZWQgd2l0aGluLlxuICAgIC8vIFRyYXZlcnNlIGJhY2t3YXJkcyBzbyB3ZSBjYW4gcmVtb3ZlIG5vZGVzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAvLyB3aXRob3V0IGVmZmVjdGluZyB0aGUgdHJhdmVyc2FsLlxuICAgIC8vXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdGFraW5nIGludG8gYWNjb3VudCBvcmlnaW5hbCBjb250ZW50U2NvcmUgaGVyZS5cbiAgICB0aGlzLl9yZW1vdmVOb2Rlcyh0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoZSwgW3RhZ10pLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIG5vZGUgSVMgZGF0YSB0YWJsZSwgaW4gd2hpY2ggY2FzZSBkb24ndCByZW1vdmUgaXQuXG4gICAgICB2YXIgaXNEYXRhVGFibGUgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Ll9yZWFkYWJpbGl0eURhdGFUYWJsZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc0xpc3QgPSB0YWcgPT09IFwidWxcIiB8fCB0YWcgPT09IFwib2xcIjtcbiAgICAgIGlmICghaXNMaXN0KSB7XG4gICAgICAgIHZhciBsaXN0TGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIGxpc3ROb2RlcyA9IHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhub2RlLCBbXCJ1bFwiLCBcIm9sXCJdKTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaE5vZGUobGlzdE5vZGVzLCAobGlzdCkgPT4gbGlzdExlbmd0aCArPSB0aGlzLl9nZXRJbm5lclRleHQobGlzdCkubGVuZ3RoKTtcbiAgICAgICAgaXNMaXN0ID0gbGlzdExlbmd0aCAvIHRoaXMuX2dldElubmVyVGV4dChub2RlKS5sZW5ndGggPiAwLjk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YWcgPT09IFwidGFibGVcIiAmJiBpc0RhdGFUYWJsZShub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIE5leHQgY2hlY2sgaWYgd2UncmUgaW5zaWRlIGEgZGF0YSB0YWJsZSwgaW4gd2hpY2ggY2FzZSBkb24ndCByZW1vdmUgaXQgYXMgd2VsbC5cbiAgICAgIGlmICh0aGlzLl9oYXNBbmNlc3RvclRhZyhub2RlLCBcInRhYmxlXCIsIC0xLCBpc0RhdGFUYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzQW5jZXN0b3JUYWcobm9kZSwgXCJjb2RlXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdlaWdodCA9IHRoaXMuX2dldENsYXNzV2VpZ2h0KG5vZGUpO1xuXG4gICAgICB0aGlzLmxvZyhcIkNsZWFuaW5nIENvbmRpdGlvbmFsbHlcIiwgbm9kZSk7XG5cbiAgICAgIHZhciBjb250ZW50U2NvcmUgPSAwO1xuXG4gICAgICBpZiAod2VpZ2h0ICsgY29udGVudFNjb3JlIDwgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2dldENoYXJDb3VudChub2RlLCBcIixcIikgPCAxMCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm90IHZlcnkgbWFueSBjb21tYXMsIGFuZCB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIG5vbi1wYXJhZ3JhcGggZWxlbWVudHMgaXMgbW9yZSB0aGFuIHBhcmFncmFwaHMgb3Igb3RoZXJcbiAgICAgICAgLy8gb21pbm91cyBzaWducywgcmVtb3ZlIHRoZSBlbGVtZW50LlxuICAgICAgICB2YXIgcCA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwXCIpLmxlbmd0aDtcbiAgICAgICAgdmFyIGltZyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIikubGVuZ3RoO1xuICAgICAgICB2YXIgbGkgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlcIikubGVuZ3RoIC0gMTAwO1xuICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIikubGVuZ3RoO1xuICAgICAgICB2YXIgaGVhZGluZ0RlbnNpdHkgPSB0aGlzLl9nZXRUZXh0RGVuc2l0eShub2RlLCBbXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLCBcImg1XCIsIFwiaDZcIl0pO1xuXG4gICAgICAgIHZhciBlbWJlZENvdW50ID0gMDtcbiAgICAgICAgdmFyIGVtYmVkcyA9IHRoaXMuX2dldEFsbE5vZGVzV2l0aFRhZyhub2RlLCBbXCJvYmplY3RcIiwgXCJlbWJlZFwiLCBcImlmcmFtZVwiXSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbWJlZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGVtYmVkIGhhcyBhdHRyaWJ1dGUgdGhhdCBtYXRjaGVzIHZpZGVvIHJlZ2V4LCBkb24ndCBkZWxldGUgaXQuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbWJlZHNbaV0uYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbG93ZWRWaWRlb1JlZ2V4LnRlc3QoZW1iZWRzW2ldLmF0dHJpYnV0ZXNbal0udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3IgZW1iZWQgd2l0aCA8b2JqZWN0PiB0YWcsIGNoZWNrIGlubmVyIEhUTUwgYXMgd2VsbC5cbiAgICAgICAgICBpZiAoZW1iZWRzW2ldLnRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5fYWxsb3dlZFZpZGVvUmVnZXgudGVzdChlbWJlZHNbaV0uaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVtYmVkQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rRGVuc2l0eSA9IHRoaXMuX2dldExpbmtEZW5zaXR5KG5vZGUpO1xuICAgICAgICB2YXIgY29udGVudExlbmd0aCA9IHRoaXMuX2dldElubmVyVGV4dChub2RlKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGhhdmVUb1JlbW92ZSA9XG4gICAgICAgICAgKGltZyA+IDEgJiYgcCAvIGltZyA8IDAuNSAmJiAhdGhpcy5faGFzQW5jZXN0b3JUYWcobm9kZSwgXCJmaWd1cmVcIikpIHx8XG4gICAgICAgICAgKCFpc0xpc3QgJiYgbGkgPiBwKSB8fFxuICAgICAgICAgIChpbnB1dCA+IE1hdGguZmxvb3IocC8zKSkgfHxcbiAgICAgICAgICAoIWlzTGlzdCAmJiBoZWFkaW5nRGVuc2l0eSA8IDAuOSAmJiBjb250ZW50TGVuZ3RoIDwgMjUgJiYgKGltZyA9PT0gMCB8fCBpbWcgPiAyKSAmJiAhdGhpcy5faGFzQW5jZXN0b3JUYWcobm9kZSwgXCJmaWd1cmVcIikpIHx8XG4gICAgICAgICAgKCFpc0xpc3QgJiYgd2VpZ2h0IDwgMjUgJiYgbGlua0RlbnNpdHkgPiAwLjIpIHx8XG4gICAgICAgICAgKHdlaWdodCA+PSAyNSAmJiBsaW5rRGVuc2l0eSA+IDAuNSkgfHxcbiAgICAgICAgICAoKGVtYmVkQ291bnQgPT09IDEgJiYgY29udGVudExlbmd0aCA8IDc1KSB8fCBlbWJlZENvdW50ID4gMSk7XG4gICAgICAgIC8vIEFsbG93IHNpbXBsZSBsaXN0cyBvZiBpbWFnZXMgdG8gcmVtYWluIGluIHBhZ2VzXG4gICAgICAgIGlmIChpc0xpc3QgJiYgaGF2ZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkcmVuW3hdO1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIGluIGxpc3RzIHdpdGggbGkncyB0aGF0IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBjaGlsZFxuICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhdmVUb1JlbW92ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGxpX2NvdW50ID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpXCIpLmxlbmd0aDtcbiAgICAgICAgICAvLyBPbmx5IGFsbG93IHRoZSBsaXN0IHRvIHJlbWFpbiBpZiBldmVyeSBsaSBjb250YWlucyBhbiBpbWFnZVxuICAgICAgICAgIGlmIChpbWcgPT0gbGlfY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhdmVUb1JlbW92ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYW4gb3V0IGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHNwZWNpZmllZCBjb25kaXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEBwYXJhbSBGdW5jdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBub2RlIHNob3VsZCBiZSByZW1vdmVkXG4gICAqIEByZXR1cm4gdm9pZFxuICAgKiovXG4gIF9jbGVhbk1hdGNoZWROb2RlczogZnVuY3Rpb24oZSwgZmlsdGVyKSB7XG4gICAgdmFyIGVuZE9mU2VhcmNoTWFya2VyTm9kZSA9IHRoaXMuX2dldE5leHROb2RlKGUsIHRydWUpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fZ2V0TmV4dE5vZGUoZSk7XG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBlbmRPZlNlYXJjaE1hcmtlck5vZGUpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBuZXh0LCBuZXh0LmNsYXNzTmFtZSArIFwiIFwiICsgbmV4dC5pZCkpIHtcbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlbW92ZUFuZEdldE5leHQobmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gdGhpcy5fZ2V0TmV4dE5vZGUobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhbiBvdXQgc3B1cmlvdXMgaGVhZGVycyBmcm9tIGFuIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50XG4gICAqIEByZXR1cm4gdm9pZFxuICAqKi9cbiAgX2NsZWFuSGVhZGVyczogZnVuY3Rpb24oZSkge1xuICAgIGxldCBoZWFkaW5nTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2Rlc1dpdGhUYWcoZSwgW1wiaDFcIiwgXCJoMlwiXSk7XG4gICAgdGhpcy5fcmVtb3ZlTm9kZXMoaGVhZGluZ05vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBsZXQgc2hvdWxkUmVtb3ZlID0gdGhpcy5fZ2V0Q2xhc3NXZWlnaHQobm9kZSkgPCAwO1xuICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICB0aGlzLmxvZyhcIlJlbW92aW5nIGhlYWRlciB3aXRoIGxvdyBjbGFzcyB3ZWlnaHQ6XCIsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZFJlbW92ZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyBub2RlIGlzIGFuIEgxIG9yIEgyIGVsZW1lbnQgd2hvc2UgY29udGVudCBpcyBtb3N0bHlcbiAgICogdGhlIHNhbWUgYXMgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSBFbGVtZW50ICB0aGUgbm9kZSB0byBjaGVjay5cbiAgICogQHJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgdGl0bGUtbGlrZSBoZWFkZXIuXG4gICAqL1xuICBfaGVhZGVyRHVwbGljYXRlc1RpdGxlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSAhPSBcIkgxXCIgJiYgbm9kZS50YWdOYW1lICE9IFwiSDJcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaGVhZGluZyA9IHRoaXMuX2dldElubmVyVGV4dChub2RlLCBmYWxzZSk7XG4gICAgdGhpcy5sb2coXCJFdmFsdWF0aW5nIHNpbWlsYXJpdHkgb2YgaGVhZGVyOlwiLCBoZWFkaW5nLCB0aGlzLl9hcnRpY2xlVGl0bGUpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0U2ltaWxhcml0eSh0aGlzLl9hcnRpY2xlVGl0bGUsIGhlYWRpbmcpID4gMC43NTtcbiAgfSxcblxuICBfZmxhZ0lzQWN0aXZlOiBmdW5jdGlvbihmbGFnKSB7XG4gICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGZsYWcpID4gMDtcbiAgfSxcblxuICBfcmVtb3ZlRmxhZzogZnVuY3Rpb24oZmxhZykge1xuICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgJiB+ZmxhZztcbiAgfSxcblxuICBfaXNQcm9iYWJseVZpc2libGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvLyBIYXZlIHRvIG51bGwtY2hlY2sgbm9kZS5zdHlsZSBhbmQgbm9kZS5jbGFzc05hbWUuaW5kZXhPZiB0byBkZWFsIHdpdGggU1ZHIGFuZCBNYXRoTUwgbm9kZXMuXG4gICAgcmV0dXJuICghbm9kZS5zdHlsZSB8fCBub2RlLnN0eWxlLmRpc3BsYXkgIT0gXCJub25lXCIpXG4gICAgICAmJiAoIW5vZGUuc3R5bGUgfHwgbm9kZS5zdHlsZS52aXNpYmlsaXR5ICE9IFwiaGlkZGVuXCIpXG4gICAgICAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIilcbiAgICAgIC8vY2hlY2sgZm9yIFwiZmFsbGJhY2staW1hZ2VcIiBzbyB0aGF0IHdpa2ltZWRpYSBtYXRoIGltYWdlcyBhcmUgZGlzcGxheWVkXG4gICAgICAmJiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSAhPSBcInRydWVcIiB8fCAobm9kZS5jbGFzc05hbWUgJiYgbm9kZS5jbGFzc05hbWUuaW5kZXhPZiAmJiBub2RlLmNsYXNzTmFtZS5pbmRleE9mKFwiZmFsbGJhY2staW1hZ2VcIikgIT09IC0xKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJ1bnMgcmVhZGFiaWxpdHkuXG4gICAqXG4gICAqIFdvcmtmbG93OlxuICAgKiAgMS4gUHJlcCB0aGUgZG9jdW1lbnQgYnkgcmVtb3Zpbmcgc2NyaXB0IHRhZ3MsIGNzcywgZXRjLlxuICAgKiAgMi4gQnVpbGQgcmVhZGFiaWxpdHkncyBET00gdHJlZS5cbiAgICogIDMuIEdyYWIgdGhlIGFydGljbGUgY29udGVudCBmcm9tIHRoZSBjdXJyZW50IGRvbSB0cmVlLlxuICAgKiAgNC4gUmVwbGFjZSB0aGUgY3VycmVudCBET00gdHJlZSB3aXRoIHRoZSBuZXcgb25lLlxuICAgKiAgNS4gUmVhZCBwZWFjZWZ1bGx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICoqL1xuICBwYXJzZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF2b2lkIHBhcnNpbmcgdG9vIGxhcmdlIGRvY3VtZW50cywgYXMgcGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9uXG4gICAgaWYgKHRoaXMuX21heEVsZW1zVG9QYXJzZSA+IDApIHtcbiAgICAgIHZhciBudW1UYWdzID0gdGhpcy5fZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG4gICAgICBpZiAobnVtVGFncyA+IHRoaXMuX21heEVsZW1zVG9QYXJzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGluZyBwYXJzaW5nIGRvY3VtZW50OyBcIiArIG51bVRhZ3MgKyBcIiBlbGVtZW50cyBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbndyYXAgaW1hZ2UgZnJvbSBub3NjcmlwdFxuICAgIHRoaXMuX3Vud3JhcE5vc2NyaXB0SW1hZ2VzKHRoaXMuX2RvYyk7XG5cbiAgICAvLyBFeHRyYWN0IEpTT04tTEQgbWV0YWRhdGEgYmVmb3JlIHJlbW92aW5nIHNjcmlwdHNcbiAgICB2YXIganNvbkxkID0gdGhpcy5fZGlzYWJsZUpTT05MRCA/IHt9IDogdGhpcy5fZ2V0SlNPTkxEKHRoaXMuX2RvYyk7XG5cbiAgICAvLyBSZW1vdmUgc2NyaXB0IHRhZ3MgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgdGhpcy5fcmVtb3ZlU2NyaXB0cyh0aGlzLl9kb2MpO1xuXG4gICAgdGhpcy5fcHJlcERvY3VtZW50KCk7XG5cbiAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLl9nZXRBcnRpY2xlTWV0YWRhdGEoanNvbkxkKTtcbiAgICB0aGlzLl9hcnRpY2xlVGl0bGUgPSBtZXRhZGF0YS50aXRsZTtcblxuICAgIHZhciBhcnRpY2xlQ29udGVudCA9IHRoaXMuX2dyYWJBcnRpY2xlKCk7XG4gICAgaWYgKCFhcnRpY2xlQ29udGVudClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdGhpcy5sb2coXCJHcmFiYmVkOiBcIiArIGFydGljbGVDb250ZW50LmlubmVySFRNTCk7XG5cbiAgICB0aGlzLl9wb3N0UHJvY2Vzc0NvbnRlbnQoYXJ0aWNsZUNvbnRlbnQpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBmb3VuZCBhbiBleGNlcnB0IGluIHRoZSBhcnRpY2xlJ3MgbWV0YWRhdGEsIHVzZSB0aGUgYXJ0aWNsZSdzXG4gICAgLy8gZmlyc3QgcGFyYWdyYXBoIGFzIHRoZSBleGNlcnB0LiBUaGlzIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgYSBwcmV2aWV3IG9mXG4gICAgLy8gdGhlIGFydGljbGUncyBjb250ZW50LlxuICAgIGlmICghbWV0YWRhdGEuZXhjZXJwdCkge1xuICAgICAgdmFyIHBhcmFncmFwaHMgPSBhcnRpY2xlQ29udGVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBcIik7XG4gICAgICBpZiAocGFyYWdyYXBocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1ldGFkYXRhLmV4Y2VycHQgPSBwYXJhZ3JhcGhzWzBdLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSBhcnRpY2xlQ29udGVudC50ZXh0Q29udGVudDtcbiAgICByZXR1cm4ge1xuICAgICAgdGl0bGU6IHRoaXMuX2FydGljbGVUaXRsZSxcbiAgICAgIGJ5bGluZTogbWV0YWRhdGEuYnlsaW5lIHx8IHRoaXMuX2FydGljbGVCeWxpbmUsXG4gICAgICBkaXI6IHRoaXMuX2FydGljbGVEaXIsXG4gICAgICBsYW5nOiB0aGlzLl9hcnRpY2xlTGFuZyxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuX3NlcmlhbGl6ZXIoYXJ0aWNsZUNvbnRlbnQpLFxuICAgICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgICAgbGVuZ3RoOiB0ZXh0Q29udGVudC5sZW5ndGgsXG4gICAgICBleGNlcnB0OiBtZXRhZGF0YS5leGNlcnB0LFxuICAgICAgc2l0ZU5hbWU6IG1ldGFkYXRhLnNpdGVOYW1lIHx8IHRoaXMuX2FydGljbGVTaXRlTmFtZSxcbiAgICAgIHB1Ymxpc2hlZFRpbWU6IG1ldGFkYXRhLnB1Ymxpc2hlZFRpbWVcbiAgICB9O1xuICB9XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAvKiBnbG9iYWwgbW9kdWxlICovXG4gIG1vZHVsZS5leHBvcnRzID0gUmVhZGFiaWxpdHk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIEFyYzkwIEluY1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKlxuICogVGhpcyBjb2RlIGlzIGhlYXZpbHkgYmFzZWQgb24gQXJjOTAncyByZWFkYWJpbGl0eS5qcyAoMS43LjEpIHNjcmlwdFxuICogYXZhaWxhYmxlIGF0OiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXJjOTBsYWJzLXJlYWRhYmlsaXR5XG4gKi9cblxudmFyIFJFR0VYUFMgPSB7XG4gIC8vIE5PVEU6IFRoZXNlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBkdXBsaWNhdGVkIGluXG4gIC8vIFJlYWRhYmlsaXR5LmpzLiBQbGVhc2Uga2VlcCBib3RoIGNvcGllcyBpbiBzeW5jLlxuICB1bmxpa2VseUNhbmRpZGF0ZXM6IC8tYWQtfGFpMmh0bWx8YmFubmVyfGJyZWFkY3J1bWJzfGNvbWJ4fGNvbW1lbnR8Y29tbXVuaXR5fGNvdmVyLXdyYXB8ZGlzcXVzfGV4dHJhfGZvb3RlcnxnZHByfGhlYWRlcnxsZWdlbmRzfG1lbnV8cmVsYXRlZHxyZW1hcmt8cmVwbGllc3xyc3N8c2hvdXRib3h8c2lkZWJhcnxza3lzY3JhcGVyfHNvY2lhbHxzcG9uc29yfHN1cHBsZW1lbnRhbHxhZC1icmVha3xhZ2VnYXRlfHBhZ2luYXRpb258cGFnZXJ8cG9wdXB8eW9tLXJlbW90ZS9pLFxuICBva01heWJlSXRzQUNhbmRpZGF0ZTogL2FuZHxhcnRpY2xlfGJvZHl8Y29sdW1ufGNvbnRlbnR8bWFpbnxzaGFkb3cvaSxcbn07XG5cbmZ1bmN0aW9uIGlzTm9kZVZpc2libGUobm9kZSkge1xuICAvLyBIYXZlIHRvIG51bGwtY2hlY2sgbm9kZS5zdHlsZSBhbmQgbm9kZS5jbGFzc05hbWUuaW5kZXhPZiB0byBkZWFsIHdpdGggU1ZHIGFuZCBNYXRoTUwgbm9kZXMuXG4gIHJldHVybiAoIW5vZGUuc3R5bGUgfHwgbm9kZS5zdHlsZS5kaXNwbGF5ICE9IFwibm9uZVwiKVxuICAgICYmICFub2RlLmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKVxuICAgIC8vY2hlY2sgZm9yIFwiZmFsbGJhY2staW1hZ2VcIiBzbyB0aGF0IHdpa2ltZWRpYSBtYXRoIGltYWdlcyBhcmUgZGlzcGxheWVkXG4gICAgJiYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT0gXCJ0cnVlXCIgfHwgKG5vZGUuY2xhc3NOYW1lICYmIG5vZGUuY2xhc3NOYW1lLmluZGV4T2YgJiYgbm9kZS5jbGFzc05hbWUuaW5kZXhPZihcImZhbGxiYWNrLWltYWdlXCIpICE9PSAtMSkpO1xufVxuXG4vKipcbiAqIERlY2lkZXMgd2hldGhlciBvciBub3QgdGhlIGRvY3VtZW50IGlzIHJlYWRlci1hYmxlIHdpdGhvdXQgcGFyc2luZyB0aGUgd2hvbGUgdGhpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5Db250ZW50TGVuZ3RoPTE0MF0gVGhlIG1pbmltdW0gbm9kZSBjb250ZW50IGxlbmd0aCB1c2VkIHRvIGRlY2lkZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZGVyYWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5TY29yZT0yMF0gVGhlIG1pbnVtdW0gY3VtdWxhdGVkICdzY29yZScgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWRlcmFibGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52aXNpYmlsaXR5Q2hlY2tlcj1pc05vZGVWaXNpYmxlXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBub2RlIGlzIHZpc2libGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB3ZSBzdXNwZWN0IFJlYWRhYmlsaXR5LnBhcnNlKCkgd2lsbCBzdWNlZWVkIGF0IHJldHVybmluZyBhbiBhcnRpY2xlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQcm9iYWJseVJlYWRlcmFibGUoZG9jLCBvcHRpb25zID0ge30pIHtcbiAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVhc29ucyAnb3B0aW9ucycgY2FuIGVpdGhlciBiZSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIHRoZSBmdW5jdGlvbiB1c2VkXG4gIC8vIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgdmlzaWJsZS5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwiZnVuY3Rpb25cIikge1xuICAgIG9wdGlvbnMgPSB7IHZpc2liaWxpdHlDaGVja2VyOiBvcHRpb25zIH07XG4gIH1cblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7IG1pblNjb3JlOiAyMCwgbWluQ29udGVudExlbmd0aDogMTQwLCB2aXNpYmlsaXR5Q2hlY2tlcjogaXNOb2RlVmlzaWJsZSB9O1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgdmFyIG5vZGVzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLCBwcmUsIGFydGljbGVcIik7XG5cbiAgLy8gR2V0IDxkaXY+IG5vZGVzIHdoaWNoIGhhdmUgPGJyPiBub2RlKHMpIGFuZCBhcHBlbmQgdGhlbSBpbnRvIHRoZSBgbm9kZXNgIHZhcmlhYmxlLlxuICAvLyBTb21lIGFydGljbGVzJyBET00gc3RydWN0dXJlcyBtaWdodCBsb29rIGxpa2VcbiAgLy8gPGRpdj5cbiAgLy8gICBTZW50ZW5jZXM8YnI+XG4gIC8vICAgPGJyPlxuICAvLyAgIFNlbnRlbmNlczxicj5cbiAgLy8gPC9kaXY+XG4gIHZhciBick5vZGVzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJkaXYgPiBiclwiKTtcbiAgaWYgKGJyTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNldCA9IG5ldyBTZXQobm9kZXMpO1xuICAgIFtdLmZvckVhY2guY2FsbChick5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgc2V0LmFkZChub2RlLnBhcmVudE5vZGUpO1xuICAgIH0pO1xuICAgIG5vZGVzID0gQXJyYXkuZnJvbShzZXQpO1xuICB9XG5cbiAgdmFyIHNjb3JlID0gMDtcbiAgLy8gVGhpcyBpcyBhIGxpdHRsZSBjaGVla3ksIHdlIHVzZSB0aGUgYWNjdW11bGF0b3IgJ3Njb3JlJyB0byBkZWNpZGUgd2hhdCB0byByZXR1cm4gZnJvbVxuICAvLyB0aGlzIGNhbGxiYWNrOlxuICByZXR1cm4gW10uc29tZS5jYWxsKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghb3B0aW9ucy52aXNpYmlsaXR5Q2hlY2tlcihub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaFN0cmluZyA9IG5vZGUuY2xhc3NOYW1lICsgXCIgXCIgKyBub2RlLmlkO1xuICAgIGlmIChSRUdFWFBTLnVubGlrZWx5Q2FuZGlkYXRlcy50ZXN0KG1hdGNoU3RyaW5nKSAmJlxuICAgICAgICAhUkVHRVhQUy5va01heWJlSXRzQUNhbmRpZGF0ZS50ZXN0KG1hdGNoU3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLm1hdGNoZXMoXCJsaSBwXCIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250ZW50TGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC50cmltKCkubGVuZ3RoO1xuICAgIGlmICh0ZXh0Q29udGVudExlbmd0aCA8IG9wdGlvbnMubWluQ29udGVudExlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNjb3JlICs9IE1hdGguc3FydCh0ZXh0Q29udGVudExlbmd0aCAtIG9wdGlvbnMubWluQ29udGVudExlbmd0aCk7XG5cbiAgICBpZiAoc2NvcmUgPiBvcHRpb25zLm1pblNjb3JlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgLyogZ2xvYmFsIG1vZHVsZSAqL1xuICBtb2R1bGUuZXhwb3J0cyA9IGlzUHJvYmFibHlSZWFkZXJhYmxlO1xufVxuIiwidmFyIGhpZ2hsaWdodFJlZ0V4cCA9IC9oaWdobGlnaHQtKD86dGV4dHxzb3VyY2UpLShbYS16MC05XSspLztcblxuZnVuY3Rpb24gaGlnaGxpZ2h0ZWRDb2RlQmxvY2sgKHR1cm5kb3duU2VydmljZSkge1xuICB0dXJuZG93blNlcnZpY2UuYWRkUnVsZSgnaGlnaGxpZ2h0ZWRDb2RlQmxvY2snLCB7XG4gICAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBub2RlLm5vZGVOYW1lID09PSAnRElWJyAmJlxuICAgICAgICBoaWdobGlnaHRSZWdFeHAudGVzdChub2RlLmNsYXNzTmFtZSkgJiZcbiAgICAgICAgZmlyc3RDaGlsZCAmJlxuICAgICAgICBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnUFJFJ1xuICAgICAgKVxuICAgIH0sXG4gICAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUgfHwgJyc7XG4gICAgICB2YXIgbGFuZ3VhZ2UgPSAoY2xhc3NOYW1lLm1hdGNoKGhpZ2hsaWdodFJlZ0V4cCkgfHwgW251bGwsICcnXSlbMV07XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICdcXG5cXG4nICsgb3B0aW9ucy5mZW5jZSArIGxhbmd1YWdlICsgJ1xcbicgK1xuICAgICAgICBub2RlLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgK1xuICAgICAgICAnXFxuJyArIG9wdGlvbnMuZmVuY2UgKyAnXFxuXFxuJ1xuICAgICAgKVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlrZXRocm91Z2ggKHR1cm5kb3duU2VydmljZSkge1xuICB0dXJuZG93blNlcnZpY2UuYWRkUnVsZSgnc3RyaWtldGhyb3VnaCcsIHtcbiAgICBmaWx0ZXI6IFsnZGVsJywgJ3MnLCAnc3RyaWtlJ10sXG4gICAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICByZXR1cm4gJ34nICsgY29udGVudCArICd+J1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG52YXIgZXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnk7XG52YXIgcnVsZXMgPSB7fTtcblxucnVsZXMudGFibGVDZWxsID0ge1xuICBmaWx0ZXI6IFsndGgnLCAndGQnXSxcbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgcmV0dXJuIGNlbGwoY29udGVudCwgbm9kZSlcbiAgfVxufTtcblxucnVsZXMudGFibGVSb3cgPSB7XG4gIGZpbHRlcjogJ3RyJyxcbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgdmFyIGJvcmRlckNlbGxzID0gJyc7XG4gICAgdmFyIGFsaWduTWFwID0geyBsZWZ0OiAnOi0tJywgcmlnaHQ6ICctLTonLCBjZW50ZXI6ICc6LTonIH07XG5cbiAgICBpZiAoaXNIZWFkaW5nUm93KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYm9yZGVyID0gJy0tLSc7XG4gICAgICAgIHZhciBhbGlnbiA9IChcbiAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbaV0uZ2V0QXR0cmlidXRlKCdhbGlnbicpIHx8ICcnXG4gICAgICAgICkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoYWxpZ24pIGJvcmRlciA9IGFsaWduTWFwW2FsaWduXSB8fCBib3JkZXI7XG5cbiAgICAgICAgYm9yZGVyQ2VsbHMgKz0gY2VsbChib3JkZXIsIG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnXFxuJyArIGNvbnRlbnQgKyAoYm9yZGVyQ2VsbHMgPyAnXFxuJyArIGJvcmRlckNlbGxzIDogJycpXG4gIH1cbn07XG5cbnJ1bGVzLnRhYmxlID0ge1xuICAvLyBPbmx5IGNvbnZlcnQgdGFibGVzIHdpdGggYSBoZWFkaW5nIHJvdy5cbiAgLy8gVGFibGVzIHdpdGggbm8gaGVhZGluZyByb3cgYXJlIGtlcHQgdXNpbmcgYGtlZXBgIChzZWUgYmVsb3cpLlxuICBmaWx0ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdUQUJMRScgJiYgaXNIZWFkaW5nUm93KG5vZGUucm93c1swXSlcbiAgfSxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAvLyBFbnN1cmUgdGhlcmUgYXJlIG5vIGJsYW5rIGxpbmVzXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgnXFxuXFxuJywgJ1xcbicpO1xuICAgIHJldHVybiAnXFxuXFxuJyArIGNvbnRlbnQgKyAnXFxuXFxuJ1xuICB9XG59O1xuXG5ydWxlcy50YWJsZVNlY3Rpb24gPSB7XG4gIGZpbHRlcjogWyd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCddLFxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudFxuICB9XG59O1xuXG4vLyBBIHRyIGlzIGEgaGVhZGluZyByb3cgaWY6XG4vLyAtIHRoZSBwYXJlbnQgaXMgYSBUSEVBRFxuLy8gLSBvciBpZiBpdHMgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBUQUJMRSBvciB0aGUgZmlyc3QgVEJPRFkgKHBvc3NpYmx5XG4vLyAgIGZvbGxvd2luZyBhIGJsYW5rIFRIRUFEKVxuLy8gLSBhbmQgZXZlcnkgY2VsbCBpcyBhIFRIXG5mdW5jdGlvbiBpc0hlYWRpbmdSb3cgKHRyKSB7XG4gIHZhciBwYXJlbnROb2RlID0gdHIucGFyZW50Tm9kZTtcbiAgcmV0dXJuIChcbiAgICBwYXJlbnROb2RlLm5vZGVOYW1lID09PSAnVEhFQUQnIHx8XG4gICAgKFxuICAgICAgcGFyZW50Tm9kZS5maXJzdENoaWxkID09PSB0ciAmJlxuICAgICAgKHBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdUQUJMRScgfHwgaXNGaXJzdFRib2R5KHBhcmVudE5vZGUpKSAmJlxuICAgICAgZXZlcnkuY2FsbCh0ci5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5ub2RlTmFtZSA9PT0gJ1RIJyB9KVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0ZpcnN0VGJvZHkgKGVsZW1lbnQpIHtcbiAgdmFyIHByZXZpb3VzU2libGluZyA9IGVsZW1lbnQucHJldmlvdXNTaWJsaW5nO1xuICByZXR1cm4gKFxuICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdUQk9EWScgJiYgKFxuICAgICAgIXByZXZpb3VzU2libGluZyB8fFxuICAgICAgKFxuICAgICAgICBwcmV2aW91c1NpYmxpbmcubm9kZU5hbWUgPT09ICdUSEVBRCcgJiZcbiAgICAgICAgL15cXHMqJC9pLnRlc3QocHJldmlvdXNTaWJsaW5nLnRleHRDb250ZW50KVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBjZWxsIChjb250ZW50LCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YuY2FsbChub2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcywgbm9kZSk7XG4gIHZhciBwcmVmaXggPSAnICc7XG4gIGlmIChpbmRleCA9PT0gMCkgcHJlZml4ID0gJ3wgJztcbiAgcmV0dXJuIHByZWZpeCArIGNvbnRlbnQgKyAnIHwnXG59XG5cbmZ1bmN0aW9uIHRhYmxlcyAodHVybmRvd25TZXJ2aWNlKSB7XG4gIHR1cm5kb3duU2VydmljZS5rZWVwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdUQUJMRScgJiYgIWlzSGVhZGluZ1Jvdyhub2RlLnJvd3NbMF0pXG4gIH0pO1xuICBmb3IgKHZhciBrZXkgaW4gcnVsZXMpIHR1cm5kb3duU2VydmljZS5hZGRSdWxlKGtleSwgcnVsZXNba2V5XSk7XG59XG5cbmZ1bmN0aW9uIHRhc2tMaXN0SXRlbXMgKHR1cm5kb3duU2VydmljZSkge1xuICB0dXJuZG93blNlcnZpY2UuYWRkUnVsZSgndGFza0xpc3RJdGVtcycsIHtcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY2hlY2tib3gnICYmIG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ0xJJ1xuICAgIH0sXG4gICAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgICByZXR1cm4gKG5vZGUuY2hlY2tlZCA/ICdbeF0nIDogJ1sgXScpICsgJyAnXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2ZtICh0dXJuZG93blNlcnZpY2UpIHtcbiAgdHVybmRvd25TZXJ2aWNlLnVzZShbXG4gICAgaGlnaGxpZ2h0ZWRDb2RlQmxvY2ssXG4gICAgc3RyaWtldGhyb3VnaCxcbiAgICB0YWJsZXMsXG4gICAgdGFza0xpc3RJdGVtc1xuICBdKTtcbn1cblxuZXhwb3J0IHsgZ2ZtLCBoaWdobGlnaHRlZENvZGVCbG9jaywgc3RyaWtldGhyb3VnaCwgdGFibGVzLCB0YXNrTGlzdEl0ZW1zIH07XG4iLCJmdW5jdGlvbiBleHRlbmQgKGRlc3RpbmF0aW9uKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCAoY2hhcmFjdGVyLCBjb3VudCkge1xuICByZXR1cm4gQXJyYXkoY291bnQgKyAxKS5qb2luKGNoYXJhY3Rlcilcbn1cblxuZnVuY3Rpb24gdHJpbUxlYWRpbmdOZXdsaW5lcyAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxcbiovLCAnJylcbn1cblxuZnVuY3Rpb24gdHJpbVRyYWlsaW5nTmV3bGluZXMgKHN0cmluZykge1xuICAvLyBhdm9pZCBtYXRjaC1hdC1lbmQgcmVnZXhwIGJvdHRsZW5lY2ssIHNlZSAjMzcwXG4gIHZhciBpbmRleEVuZCA9IHN0cmluZy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleEVuZCA+IDAgJiYgc3RyaW5nW2luZGV4RW5kIC0gMV0gPT09ICdcXG4nKSBpbmRleEVuZC0tO1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBpbmRleEVuZClcbn1cblxudmFyIGJsb2NrRWxlbWVudHMgPSBbXG4gICdBRERSRVNTJywgJ0FSVElDTEUnLCAnQVNJREUnLCAnQVVESU8nLCAnQkxPQ0tRVU9URScsICdCT0RZJywgJ0NBTlZBUycsXG4gICdDRU5URVInLCAnREQnLCAnRElSJywgJ0RJVicsICdETCcsICdEVCcsICdGSUVMRFNFVCcsICdGSUdDQVBUSU9OJywgJ0ZJR1VSRScsXG4gICdGT09URVInLCAnRk9STScsICdGUkFNRVNFVCcsICdIMScsICdIMicsICdIMycsICdINCcsICdINScsICdINicsICdIRUFERVInLFxuICAnSEdST1VQJywgJ0hSJywgJ0hUTUwnLCAnSVNJTkRFWCcsICdMSScsICdNQUlOJywgJ01FTlUnLCAnTkFWJywgJ05PRlJBTUVTJyxcbiAgJ05PU0NSSVBUJywgJ09MJywgJ09VVFBVVCcsICdQJywgJ1BSRScsICdTRUNUSU9OJywgJ1RBQkxFJywgJ1RCT0RZJywgJ1REJyxcbiAgJ1RGT09UJywgJ1RIJywgJ1RIRUFEJywgJ1RSJywgJ1VMJ1xuXTtcblxuZnVuY3Rpb24gaXNCbG9jayAobm9kZSkge1xuICByZXR1cm4gaXMobm9kZSwgYmxvY2tFbGVtZW50cylcbn1cblxudmFyIHZvaWRFbGVtZW50cyA9IFtcbiAgJ0FSRUEnLCAnQkFTRScsICdCUicsICdDT0wnLCAnQ09NTUFORCcsICdFTUJFRCcsICdIUicsICdJTUcnLCAnSU5QVVQnLFxuICAnS0VZR0VOJywgJ0xJTksnLCAnTUVUQScsICdQQVJBTScsICdTT1VSQ0UnLCAnVFJBQ0snLCAnV0JSJ1xuXTtcblxuZnVuY3Rpb24gaXNWb2lkIChub2RlKSB7XG4gIHJldHVybiBpcyhub2RlLCB2b2lkRWxlbWVudHMpXG59XG5cbmZ1bmN0aW9uIGhhc1ZvaWQgKG5vZGUpIHtcbiAgcmV0dXJuIGhhcyhub2RlLCB2b2lkRWxlbWVudHMpXG59XG5cbnZhciBtZWFuaW5nZnVsV2hlbkJsYW5rRWxlbWVudHMgPSBbXG4gICdBJywgJ1RBQkxFJywgJ1RIRUFEJywgJ1RCT0RZJywgJ1RGT09UJywgJ1RIJywgJ1REJywgJ0lGUkFNRScsICdTQ1JJUFQnLFxuICAnQVVESU8nLCAnVklERU8nXG5dO1xuXG5mdW5jdGlvbiBpc01lYW5pbmdmdWxXaGVuQmxhbmsgKG5vZGUpIHtcbiAgcmV0dXJuIGlzKG5vZGUsIG1lYW5pbmdmdWxXaGVuQmxhbmtFbGVtZW50cylcbn1cblxuZnVuY3Rpb24gaGFzTWVhbmluZ2Z1bFdoZW5CbGFuayAobm9kZSkge1xuICByZXR1cm4gaGFzKG5vZGUsIG1lYW5pbmdmdWxXaGVuQmxhbmtFbGVtZW50cylcbn1cblxuZnVuY3Rpb24gaXMgKG5vZGUsIHRhZ05hbWVzKSB7XG4gIHJldHVybiB0YWdOYW1lcy5pbmRleE9mKG5vZGUubm9kZU5hbWUpID49IDBcbn1cblxuZnVuY3Rpb24gaGFzIChub2RlLCB0YWdOYW1lcykge1xuICByZXR1cm4gKFxuICAgIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgJiZcbiAgICB0YWdOYW1lcy5zb21lKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKS5sZW5ndGhcbiAgICB9KVxuICApXG59XG5cbnZhciBydWxlcyA9IHt9O1xuXG5ydWxlcy5wYXJhZ3JhcGggPSB7XG4gIGZpbHRlcjogJ3AnLFxuXG4gIHJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHJldHVybiAnXFxuXFxuJyArIGNvbnRlbnQgKyAnXFxuXFxuJ1xuICB9XG59O1xuXG5ydWxlcy5saW5lQnJlYWsgPSB7XG4gIGZpbHRlcjogJ2JyJyxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iciArICdcXG4nXG4gIH1cbn07XG5cbnJ1bGVzLmhlYWRpbmcgPSB7XG4gIGZpbHRlcjogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddLFxuXG4gIHJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciBoTGV2ZWwgPSBOdW1iZXIobm9kZS5ub2RlTmFtZS5jaGFyQXQoMSkpO1xuXG4gICAgaWYgKG9wdGlvbnMuaGVhZGluZ1N0eWxlID09PSAnc2V0ZXh0JyAmJiBoTGV2ZWwgPCAzKSB7XG4gICAgICB2YXIgdW5kZXJsaW5lID0gcmVwZWF0KChoTGV2ZWwgPT09IDEgPyAnPScgOiAnLScpLCBjb250ZW50Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnXFxuXFxuJyArIGNvbnRlbnQgKyAnXFxuJyArIHVuZGVybGluZSArICdcXG5cXG4nXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnXFxuXFxuJyArIHJlcGVhdCgnIycsIGhMZXZlbCkgKyAnICcgKyBjb250ZW50ICsgJ1xcblxcbidcbiAgICB9XG4gIH1cbn07XG5cbnJ1bGVzLmJsb2NrcXVvdGUgPSB7XG4gIGZpbHRlcjogJ2Jsb2NrcXVvdGUnLFxuXG4gIHJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL15cXG4rfFxcbiskL2csICcnKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9eL2dtLCAnPiAnKTtcbiAgICByZXR1cm4gJ1xcblxcbicgKyBjb250ZW50ICsgJ1xcblxcbidcbiAgfVxufTtcblxucnVsZXMubGlzdCA9IHtcbiAgZmlsdGVyOiBbJ3VsJywgJ29sJ10sXG5cbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnTEknICYmIHBhcmVudC5sYXN0RWxlbWVudENoaWxkID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gJ1xcbicgKyBjb250ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnXFxuXFxuJyArIGNvbnRlbnQgKyAnXFxuXFxuJ1xuICAgIH1cbiAgfVxufTtcblxucnVsZXMubGlzdEl0ZW0gPSB7XG4gIGZpbHRlcjogJ2xpJyxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICBjb250ZW50ID0gY29udGVudFxuICAgICAgLnJlcGxhY2UoL15cXG4rLywgJycpIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmVzXG4gICAgICAucmVwbGFjZSgvXFxuKyQvLCAnXFxuJykgLy8gcmVwbGFjZSB0cmFpbGluZyBuZXdsaW5lcyB3aXRoIGp1c3QgYSBzaW5nbGUgb25lXG4gICAgICAucmVwbGFjZSgvXFxuL2dtLCAnXFxuICAgICcpOyAvLyBpbmRlbnRcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5idWxsZXRMaXN0TWFya2VyICsgJyAgICc7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnT0wnKSB7XG4gICAgICB2YXIgc3RhcnQgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCdzdGFydCcpO1xuICAgICAgdmFyIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgcHJlZml4ID0gKHN0YXJ0ID8gTnVtYmVyKHN0YXJ0KSArIGluZGV4IDogaW5kZXggKyAxKSArICcuICAnO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgcHJlZml4ICsgY29udGVudCArIChub2RlLm5leHRTaWJsaW5nICYmICEvXFxuJC8udGVzdChjb250ZW50KSA/ICdcXG4nIDogJycpXG4gICAgKVxuICB9XG59O1xuXG5ydWxlcy5pbmRlbnRlZENvZGVCbG9jayA9IHtcbiAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoXG4gICAgICBvcHRpb25zLmNvZGVCbG9ja1N0eWxlID09PSAnaW5kZW50ZWQnICYmXG4gICAgICBub2RlLm5vZGVOYW1lID09PSAnUFJFJyAmJlxuICAgICAgbm9kZS5maXJzdENoaWxkICYmXG4gICAgICBub2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdDT0RFJ1xuICAgIClcbiAgfSxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ1xcblxcbiAgICAnICtcbiAgICAgIG5vZGUuZmlyc3RDaGlsZC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXG4vZywgJ1xcbiAgICAnKSArXG4gICAgICAnXFxuXFxuJ1xuICAgIClcbiAgfVxufTtcblxucnVsZXMuZmVuY2VkQ29kZUJsb2NrID0ge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9wdGlvbnMuY29kZUJsb2NrU3R5bGUgPT09ICdmZW5jZWQnICYmXG4gICAgICBub2RlLm5vZGVOYW1lID09PSAnUFJFJyAmJlxuICAgICAgbm9kZS5maXJzdENoaWxkICYmXG4gICAgICBub2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdDT0RFJ1xuICAgIClcbiAgfSxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gbm9kZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICB2YXIgbGFuZ3VhZ2UgPSAoY2xhc3NOYW1lLm1hdGNoKC9sYW5ndWFnZS0oXFxTKykvKSB8fCBbbnVsbCwgJyddKVsxXTtcbiAgICB2YXIgY29kZSA9IG5vZGUuZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcblxuICAgIHZhciBmZW5jZUNoYXIgPSBvcHRpb25zLmZlbmNlLmNoYXJBdCgwKTtcbiAgICB2YXIgZmVuY2VTaXplID0gMztcbiAgICB2YXIgZmVuY2VJbkNvZGVSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZmVuY2VDaGFyICsgJ3szLH0nLCAnZ20nKTtcblxuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gZmVuY2VJbkNvZGVSZWdleC5leGVjKGNvZGUpKSkge1xuICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA+PSBmZW5jZVNpemUpIHtcbiAgICAgICAgZmVuY2VTaXplID0gbWF0Y2hbMF0ubGVuZ3RoICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmVuY2UgPSByZXBlYXQoZmVuY2VDaGFyLCBmZW5jZVNpemUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICdcXG5cXG4nICsgZmVuY2UgKyBsYW5ndWFnZSArICdcXG4nICtcbiAgICAgIGNvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArXG4gICAgICAnXFxuJyArIGZlbmNlICsgJ1xcblxcbidcbiAgICApXG4gIH1cbn07XG5cbnJ1bGVzLmhvcml6b250YWxSdWxlID0ge1xuICBmaWx0ZXI6ICdocicsXG5cbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICdcXG5cXG4nICsgb3B0aW9ucy5ociArICdcXG5cXG4nXG4gIH1cbn07XG5cbnJ1bGVzLmlubGluZUxpbmsgPSB7XG4gIGZpbHRlcjogZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb3B0aW9ucy5saW5rU3R5bGUgPT09ICdpbmxpbmVkJyAmJlxuICAgICAgbm9kZS5ub2RlTmFtZSA9PT0gJ0EnICYmXG4gICAgICBub2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpXG4gICAgKVxuICB9LFxuXG4gIHJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCwgbm9kZSkge1xuICAgIHZhciBocmVmID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBpZiAoaHJlZikgaHJlZiA9IGhyZWYucmVwbGFjZSgvKFsoKV0pL2csICdcXFxcJDEnKTtcbiAgICB2YXIgdGl0bGUgPSBjbGVhbkF0dHJpYnV0ZShub2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKSk7XG4gICAgaWYgKHRpdGxlKSB0aXRsZSA9ICcgXCInICsgdGl0bGUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICByZXR1cm4gJ1snICsgY29udGVudCArICddKCcgKyBocmVmICsgdGl0bGUgKyAnKSdcbiAgfVxufTtcblxucnVsZXMucmVmZXJlbmNlTGluayA9IHtcbiAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoXG4gICAgICBvcHRpb25zLmxpbmtTdHlsZSA9PT0gJ3JlZmVyZW5jZWQnICYmXG4gICAgICBub2RlLm5vZGVOYW1lID09PSAnQScgJiZcbiAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICApXG4gIH0sXG5cbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIGhyZWYgPSBub2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIHZhciB0aXRsZSA9IGNsZWFuQXR0cmlidXRlKG5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpKTtcbiAgICBpZiAodGl0bGUpIHRpdGxlID0gJyBcIicgKyB0aXRsZSArICdcIic7XG4gICAgdmFyIHJlcGxhY2VtZW50O1xuICAgIHZhciByZWZlcmVuY2U7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMubGlua1JlZmVyZW5jZVN0eWxlKSB7XG4gICAgICBjYXNlICdjb2xsYXBzZWQnOlxuICAgICAgICByZXBsYWNlbWVudCA9ICdbJyArIGNvbnRlbnQgKyAnXVtdJztcbiAgICAgICAgcmVmZXJlbmNlID0gJ1snICsgY29udGVudCArICddOiAnICsgaHJlZiArIHRpdGxlO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc2hvcnRjdXQnOlxuICAgICAgICByZXBsYWNlbWVudCA9ICdbJyArIGNvbnRlbnQgKyAnXSc7XG4gICAgICAgIHJlZmVyZW5jZSA9ICdbJyArIGNvbnRlbnQgKyAnXTogJyArIGhyZWYgKyB0aXRsZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBpZCA9IHRoaXMucmVmZXJlbmNlcy5sZW5ndGggKyAxO1xuICAgICAgICByZXBsYWNlbWVudCA9ICdbJyArIGNvbnRlbnQgKyAnXVsnICsgaWQgKyAnXSc7XG4gICAgICAgIHJlZmVyZW5jZSA9ICdbJyArIGlkICsgJ106ICcgKyBocmVmICsgdGl0bGU7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZlcmVuY2VzLnB1c2gocmVmZXJlbmNlKTtcbiAgICByZXR1cm4gcmVwbGFjZW1lbnRcbiAgfSxcblxuICByZWZlcmVuY2VzOiBbXSxcblxuICBhcHBlbmQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSAnJztcbiAgICBpZiAodGhpcy5yZWZlcmVuY2VzLmxlbmd0aCkge1xuICAgICAgcmVmZXJlbmNlcyA9ICdcXG5cXG4nICsgdGhpcy5yZWZlcmVuY2VzLmpvaW4oJ1xcbicpICsgJ1xcblxcbic7XG4gICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTsgLy8gUmVzZXQgcmVmZXJlbmNlc1xuICAgIH1cbiAgICByZXR1cm4gcmVmZXJlbmNlc1xuICB9XG59O1xuXG5ydWxlcy5lbXBoYXNpcyA9IHtcbiAgZmlsdGVyOiBbJ2VtJywgJ2knXSxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWNvbnRlbnQudHJpbSgpKSByZXR1cm4gJydcbiAgICByZXR1cm4gb3B0aW9ucy5lbURlbGltaXRlciArIGNvbnRlbnQgKyBvcHRpb25zLmVtRGVsaW1pdGVyXG4gIH1cbn07XG5cbnJ1bGVzLnN0cm9uZyA9IHtcbiAgZmlsdGVyOiBbJ3N0cm9uZycsICdiJ10sXG5cbiAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFjb250ZW50LnRyaW0oKSkgcmV0dXJuICcnXG4gICAgcmV0dXJuIG9wdGlvbnMuc3Ryb25nRGVsaW1pdGVyICsgY29udGVudCArIG9wdGlvbnMuc3Ryb25nRGVsaW1pdGVyXG4gIH1cbn07XG5cbnJ1bGVzLmNvZGUgPSB7XG4gIGZpbHRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgaGFzU2libGluZ3MgPSBub2RlLnByZXZpb3VzU2libGluZyB8fCBub2RlLm5leHRTaWJsaW5nO1xuICAgIHZhciBpc0NvZGVCbG9jayA9IG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ1BSRScgJiYgIWhhc1NpYmxpbmdzO1xuXG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdDT0RFJyAmJiAhaXNDb2RlQmxvY2tcbiAgfSxcblxuICByZXBsYWNlbWVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJ1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJyk7XG5cbiAgICB2YXIgZXh0cmFTcGFjZSA9IC9eYHxeIC4qP1teIF0uKiAkfGAkLy50ZXN0KGNvbnRlbnQpID8gJyAnIDogJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICdgJztcbiAgICB2YXIgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goL2ArL2dtKSB8fCBbXTtcbiAgICB3aGlsZSAobWF0Y2hlcy5pbmRleE9mKGRlbGltaXRlcikgIT09IC0xKSBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgKyAnYCc7XG5cbiAgICByZXR1cm4gZGVsaW1pdGVyICsgZXh0cmFTcGFjZSArIGNvbnRlbnQgKyBleHRyYVNwYWNlICsgZGVsaW1pdGVyXG4gIH1cbn07XG5cbnJ1bGVzLmltYWdlID0ge1xuICBmaWx0ZXI6ICdpbWcnLFxuXG4gIHJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCwgbm9kZSkge1xuICAgIHZhciBhbHQgPSBjbGVhbkF0dHJpYnV0ZShub2RlLmdldEF0dHJpYnV0ZSgnYWx0JykpO1xuICAgIHZhciBzcmMgPSBub2RlLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XG4gICAgdmFyIHRpdGxlID0gY2xlYW5BdHRyaWJ1dGUobm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpO1xuICAgIHZhciB0aXRsZVBhcnQgPSB0aXRsZSA/ICcgXCInICsgdGl0bGUgKyAnXCInIDogJyc7XG4gICAgcmV0dXJuIHNyYyA/ICchWycgKyBhbHQgKyAnXScgKyAnKCcgKyBzcmMgKyB0aXRsZVBhcnQgKyAnKScgOiAnJ1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGVhbkF0dHJpYnV0ZSAoYXR0cmlidXRlKSB7XG4gIHJldHVybiBhdHRyaWJ1dGUgPyBhdHRyaWJ1dGUucmVwbGFjZSgvKFxcbitcXHMqKSsvZywgJ1xcbicpIDogJydcbn1cblxuLyoqXG4gKiBNYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiBydWxlcyB1c2VkIHRvIGNvbnZlcnQgSFRNTCB0byBNYXJrZG93blxuICovXG5cbmZ1bmN0aW9uIFJ1bGVzIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX2tlZXAgPSBbXTtcbiAgdGhpcy5fcmVtb3ZlID0gW107XG5cbiAgdGhpcy5ibGFua1J1bGUgPSB7XG4gICAgcmVwbGFjZW1lbnQ6IG9wdGlvbnMuYmxhbmtSZXBsYWNlbWVudFxuICB9O1xuXG4gIHRoaXMua2VlcFJlcGxhY2VtZW50ID0gb3B0aW9ucy5rZWVwUmVwbGFjZW1lbnQ7XG5cbiAgdGhpcy5kZWZhdWx0UnVsZSA9IHtcbiAgICByZXBsYWNlbWVudDogb3B0aW9ucy5kZWZhdWx0UmVwbGFjZW1lbnRcbiAgfTtcblxuICB0aGlzLmFycmF5ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnJ1bGVzKSB0aGlzLmFycmF5LnB1c2gob3B0aW9ucy5ydWxlc1trZXldKTtcbn1cblxuUnVsZXMucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIChrZXksIHJ1bGUpIHtcbiAgICB0aGlzLmFycmF5LnVuc2hpZnQocnVsZSk7XG4gIH0sXG5cbiAga2VlcDogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgIHRoaXMuX2tlZXAudW5zaGlmdCh7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIHJlcGxhY2VtZW50OiB0aGlzLmtlZXBSZXBsYWNlbWVudFxuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgIHRoaXMuX3JlbW92ZS51bnNoaWZ0KHtcbiAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgcmVwbGFjZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgZm9yTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pc0JsYW5rKSByZXR1cm4gdGhpcy5ibGFua1J1bGVcbiAgICB2YXIgcnVsZTtcblxuICAgIGlmICgocnVsZSA9IGZpbmRSdWxlKHRoaXMuYXJyYXksIG5vZGUsIHRoaXMub3B0aW9ucykpKSByZXR1cm4gcnVsZVxuICAgIGlmICgocnVsZSA9IGZpbmRSdWxlKHRoaXMuX2tlZXAsIG5vZGUsIHRoaXMub3B0aW9ucykpKSByZXR1cm4gcnVsZVxuICAgIGlmICgocnVsZSA9IGZpbmRSdWxlKHRoaXMuX3JlbW92ZSwgbm9kZSwgdGhpcy5vcHRpb25zKSkpIHJldHVybiBydWxlXG5cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UnVsZVxuICB9LFxuXG4gIGZvckVhY2g6IGZ1bmN0aW9uIChmbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnJheS5sZW5ndGg7IGkrKykgZm4odGhpcy5hcnJheVtpXSwgaSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRSdWxlIChydWxlcywgbm9kZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcbiAgICBpZiAoZmlsdGVyVmFsdWUocnVsZSwgbm9kZSwgb3B0aW9ucykpIHJldHVybiBydWxlXG4gIH1cbiAgcmV0dXJuIHZvaWQgMFxufVxuXG5mdW5jdGlvbiBmaWx0ZXJWYWx1ZSAocnVsZSwgbm9kZSwgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gcnVsZS5maWx0ZXI7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgIGlmIChmaWx0ZXIgPT09IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICBpZiAoZmlsdGVyLmluZGV4T2Yobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xKSByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmlsdGVyLmNhbGwocnVsZSwgbm9kZSwgb3B0aW9ucykpIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGZpbHRlcmAgbmVlZHMgdG8gYmUgYSBzdHJpbmcsIGFycmF5LCBvciBmdW5jdGlvbicpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29sbGFwc2VXaGl0ZXNwYWNlIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBjb2xsYXBzZS13aGl0ZXNwYWNlXG4gKiBieSBMdWMgVGhldmVuYXJkLlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBMdWMgVGhldmVuYXJkIDxsdWN0aGV2ZW5hcmRAZ21haWwuY29tPlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBjb2xsYXBzZVdoaXRlc3BhY2Uob3B0aW9ucykgcmVtb3ZlcyBleHRyYW5lb3VzIHdoaXRlc3BhY2UgZnJvbSBhbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjb2xsYXBzZVdoaXRlc3BhY2UgKG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gIHZhciBpc0Jsb2NrID0gb3B0aW9ucy5pc0Jsb2NrO1xuICB2YXIgaXNWb2lkID0gb3B0aW9ucy5pc1ZvaWQ7XG4gIHZhciBpc1ByZSA9IG9wdGlvbnMuaXNQcmUgfHwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJ1BSRSdcbiAgfTtcblxuICBpZiAoIWVsZW1lbnQuZmlyc3RDaGlsZCB8fCBpc1ByZShlbGVtZW50KSkgcmV0dXJuXG5cbiAgdmFyIHByZXZUZXh0ID0gbnVsbDtcbiAgdmFyIGtlZXBMZWFkaW5nV3MgPSBmYWxzZTtcblxuICB2YXIgcHJldiA9IG51bGw7XG4gIHZhciBub2RlID0gbmV4dChwcmV2LCBlbGVtZW50LCBpc1ByZSk7XG5cbiAgd2hpbGUgKG5vZGUgIT09IGVsZW1lbnQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyB8fCBub2RlLm5vZGVUeXBlID09PSA0KSB7IC8vIE5vZGUuVEVYVF9OT0RFIG9yIE5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFXG4gICAgICB2YXIgdGV4dCA9IG5vZGUuZGF0YS5yZXBsYWNlKC9bIFxcclxcblxcdF0rL2csICcgJyk7XG5cbiAgICAgIGlmICgoIXByZXZUZXh0IHx8IC8gJC8udGVzdChwcmV2VGV4dC5kYXRhKSkgJiZcbiAgICAgICAgICAha2VlcExlYWRpbmdXcyAmJiB0ZXh0WzBdID09PSAnICcpIHtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDEpO1xuICAgICAgfVxuXG4gICAgICAvLyBgdGV4dGAgbWlnaHQgYmUgZW1wdHkgYXQgdGhpcyBwb2ludC5cbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICBub2RlID0gcmVtb3ZlKG5vZGUpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBub2RlLmRhdGEgPSB0ZXh0O1xuXG4gICAgICBwcmV2VGV4dCA9IG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7IC8vIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICBpZiAoaXNCbG9jayhub2RlKSB8fCBub2RlLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICAgIGlmIChwcmV2VGV4dCkge1xuICAgICAgICAgIHByZXZUZXh0LmRhdGEgPSBwcmV2VGV4dC5kYXRhLnJlcGxhY2UoLyAkLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlRleHQgPSBudWxsO1xuICAgICAgICBrZWVwTGVhZGluZ1dzID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzVm9pZChub2RlKSB8fCBpc1ByZShub2RlKSkge1xuICAgICAgICAvLyBBdm9pZCB0cmltbWluZyBzcGFjZSBhcm91bmQgbm9uLWJsb2NrLCBub24tQlIgdm9pZCBlbGVtZW50cyBhbmQgaW5saW5lIFBSRS5cbiAgICAgICAgcHJldlRleHQgPSBudWxsO1xuICAgICAgICBrZWVwTGVhZGluZ1dzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlRleHQpIHtcbiAgICAgICAgLy8gRHJvcCBwcm90ZWN0aW9uIGlmIHNldCBwcmV2aW91c2x5LlxuICAgICAgICBrZWVwTGVhZGluZ1dzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSByZW1vdmUobm9kZSk7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0Tm9kZSA9IG5leHQocHJldiwgbm9kZSwgaXNQcmUpO1xuICAgIHByZXYgPSBub2RlO1xuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxuXG4gIGlmIChwcmV2VGV4dCkge1xuICAgIHByZXZUZXh0LmRhdGEgPSBwcmV2VGV4dC5kYXRhLnJlcGxhY2UoLyAkLywgJycpO1xuICAgIGlmICghcHJldlRleHQuZGF0YSkge1xuICAgICAgcmVtb3ZlKHByZXZUZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUobm9kZSkgcmVtb3ZlcyB0aGUgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBET00gYW5kIHJldHVybnMgdGhlXG4gKiBuZXh0IG5vZGUgaW4gdGhlIHNlcXVlbmNlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICovXG5mdW5jdGlvbiByZW1vdmUgKG5vZGUpIHtcbiAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nIHx8IG5vZGUucGFyZW50Tm9kZTtcblxuICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgcmV0dXJuIG5leHRcbn1cblxuLyoqXG4gKiBuZXh0KHByZXYsIGN1cnJlbnQsIGlzUHJlKSByZXR1cm5zIHRoZSBuZXh0IG5vZGUgaW4gdGhlIHNlcXVlbmNlLCBnaXZlbiB0aGVcbiAqIGN1cnJlbnQgYW5kIHByZXZpb3VzIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gcHJldlxuICogQHBhcmFtIHtOb2RlfSBjdXJyZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpc1ByZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZnVuY3Rpb24gbmV4dCAocHJldiwgY3VycmVudCwgaXNQcmUpIHtcbiAgaWYgKChwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PT0gY3VycmVudCkgfHwgaXNQcmUoY3VycmVudCkpIHtcbiAgICByZXR1cm4gY3VycmVudC5uZXh0U2libGluZyB8fCBjdXJyZW50LnBhcmVudE5vZGVcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50LmZpcnN0Q2hpbGQgfHwgY3VycmVudC5uZXh0U2libGluZyB8fCBjdXJyZW50LnBhcmVudE5vZGVcbn1cblxuLypcbiAqIFNldCB1cCB3aW5kb3cgZm9yIE5vZGUuanNcbiAqL1xuXG52YXIgcm9vdCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KTtcblxuLypcbiAqIFBhcnNpbmcgSFRNTCBzdHJpbmdzXG4gKi9cblxuZnVuY3Rpb24gY2FuUGFyc2VIVE1MTmF0aXZlbHkgKCkge1xuICB2YXIgUGFyc2VyID0gcm9vdC5ET01QYXJzZXI7XG4gIHZhciBjYW5QYXJzZSA9IGZhbHNlO1xuXG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMTI5MDMxXG4gIC8vIEZpcmVmb3gvT3BlcmEvSUUgdGhyb3cgZXJyb3JzIG9uIHVuc3VwcG9ydGVkIHR5cGVzXG4gIHRyeSB7XG4gICAgLy8gV2ViS2l0IHJldHVybnMgbnVsbCBvbiB1bnN1cHBvcnRlZCB0eXBlc1xuICAgIGlmIChuZXcgUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCcnLCAndGV4dC9odG1sJykpIHtcbiAgICAgIGNhblBhcnNlID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIGNhblBhcnNlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhUTUxQYXJzZXIgKCkge1xuICB2YXIgUGFyc2VyID0gZnVuY3Rpb24gKCkge307XG5cbiAge1xuICAgIGlmIChzaG91bGRVc2VBY3RpdmVYKCkpIHtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB2YXIgZG9jID0gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICAgICAgICBkb2MuZGVzaWduTW9kZSA9ICdvbic7IC8vIGRpc2FibGUgb24tcGFnZSBzY3JpcHRzXG4gICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgIGRvYy53cml0ZShzdHJpbmcpO1xuICAgICAgICBkb2MuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRvY1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICAgICAgICBkb2Mub3BlbigpO1xuICAgICAgICBkb2Mud3JpdGUoc3RyaW5nKTtcbiAgICAgICAgZG9jLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBkb2NcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBQYXJzZXJcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlQWN0aXZlWCAoKSB7XG4gIHZhciB1c2VBY3RpdmVYID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKS5vcGVuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocm9vdC5BY3RpdmVYT2JqZWN0KSB1c2VBY3RpdmVYID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdXNlQWN0aXZlWFxufVxuXG52YXIgSFRNTFBhcnNlciA9IGNhblBhcnNlSFRNTE5hdGl2ZWx5KCkgPyByb290LkRPTVBhcnNlciA6IGNyZWF0ZUhUTUxQYXJzZXIoKTtcblxuZnVuY3Rpb24gUm9vdE5vZGUgKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciByb290O1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBkb2MgPSBodG1sUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFxuICAgICAgLy8gRE9NIHBhcnNlcnMgYXJyYW5nZSBlbGVtZW50cyBpbiB0aGUgPGhlYWQ+IGFuZCA8Ym9keT4uXG4gICAgICAvLyBXcmFwcGluZyBpbiBhIGN1c3RvbSBlbGVtZW50IGVuc3VyZXMgZWxlbWVudHMgYXJlIHJlbGlhYmx5IGFycmFuZ2VkIGluXG4gICAgICAvLyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgJzx4LXR1cm5kb3duIGlkPVwidHVybmRvd24tcm9vdFwiPicgKyBpbnB1dCArICc8L3gtdHVybmRvd24+JyxcbiAgICAgICd0ZXh0L2h0bWwnXG4gICAgKTtcbiAgICByb290ID0gZG9jLmdldEVsZW1lbnRCeUlkKCd0dXJuZG93bi1yb290Jyk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdCA9IGlucHV0LmNsb25lTm9kZSh0cnVlKTtcbiAgfVxuICBjb2xsYXBzZVdoaXRlc3BhY2Uoe1xuICAgIGVsZW1lbnQ6IHJvb3QsXG4gICAgaXNCbG9jazogaXNCbG9jayxcbiAgICBpc1ZvaWQ6IGlzVm9pZCxcbiAgICBpc1ByZTogb3B0aW9ucy5wcmVmb3JtYXR0ZWRDb2RlID8gaXNQcmVPckNvZGUgOiBudWxsXG4gIH0pO1xuXG4gIHJldHVybiByb290XG59XG5cbnZhciBfaHRtbFBhcnNlcjtcbmZ1bmN0aW9uIGh0bWxQYXJzZXIgKCkge1xuICBfaHRtbFBhcnNlciA9IF9odG1sUGFyc2VyIHx8IG5ldyBIVE1MUGFyc2VyKCk7XG4gIHJldHVybiBfaHRtbFBhcnNlclxufVxuXG5mdW5jdGlvbiBpc1ByZU9yQ29kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJ1BSRScgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ0NPREUnXG59XG5cbmZ1bmN0aW9uIE5vZGUgKG5vZGUsIG9wdGlvbnMpIHtcbiAgbm9kZS5pc0Jsb2NrID0gaXNCbG9jayhub2RlKTtcbiAgbm9kZS5pc0NvZGUgPSBub2RlLm5vZGVOYW1lID09PSAnQ09ERScgfHwgbm9kZS5wYXJlbnROb2RlLmlzQ29kZTtcbiAgbm9kZS5pc0JsYW5rID0gaXNCbGFuayhub2RlKTtcbiAgbm9kZS5mbGFua2luZ1doaXRlc3BhY2UgPSBmbGFua2luZ1doaXRlc3BhY2Uobm9kZSwgb3B0aW9ucyk7XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsgKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAhaXNWb2lkKG5vZGUpICYmXG4gICAgIWlzTWVhbmluZ2Z1bFdoZW5CbGFuayhub2RlKSAmJlxuICAgIC9eXFxzKiQvaS50ZXN0KG5vZGUudGV4dENvbnRlbnQpICYmXG4gICAgIWhhc1ZvaWQobm9kZSkgJiZcbiAgICAhaGFzTWVhbmluZ2Z1bFdoZW5CbGFuayhub2RlKVxuICApXG59XG5cbmZ1bmN0aW9uIGZsYW5raW5nV2hpdGVzcGFjZSAobm9kZSwgb3B0aW9ucykge1xuICBpZiAobm9kZS5pc0Jsb2NrIHx8IChvcHRpb25zLnByZWZvcm1hdHRlZENvZGUgJiYgbm9kZS5pc0NvZGUpKSB7XG4gICAgcmV0dXJuIHsgbGVhZGluZzogJycsIHRyYWlsaW5nOiAnJyB9XG4gIH1cblxuICB2YXIgZWRnZXMgPSBlZGdlV2hpdGVzcGFjZShub2RlLnRleHRDb250ZW50KTtcblxuICAvLyBhYmFuZG9uIGxlYWRpbmcgQVNDSUkgV1MgaWYgbGVmdC1mbGFua2VkIGJ5IEFTQ0lJIFdTXG4gIGlmIChlZGdlcy5sZWFkaW5nQXNjaWkgJiYgaXNGbGFua2VkQnlXaGl0ZXNwYWNlKCdsZWZ0Jywgbm9kZSwgb3B0aW9ucykpIHtcbiAgICBlZGdlcy5sZWFkaW5nID0gZWRnZXMubGVhZGluZ05vbkFzY2lpO1xuICB9XG5cbiAgLy8gYWJhbmRvbiB0cmFpbGluZyBBU0NJSSBXUyBpZiByaWdodC1mbGFua2VkIGJ5IEFTQ0lJIFdTXG4gIGlmIChlZGdlcy50cmFpbGluZ0FzY2lpICYmIGlzRmxhbmtlZEJ5V2hpdGVzcGFjZSgncmlnaHQnLCBub2RlLCBvcHRpb25zKSkge1xuICAgIGVkZ2VzLnRyYWlsaW5nID0gZWRnZXMudHJhaWxpbmdOb25Bc2NpaTtcbiAgfVxuXG4gIHJldHVybiB7IGxlYWRpbmc6IGVkZ2VzLmxlYWRpbmcsIHRyYWlsaW5nOiBlZGdlcy50cmFpbGluZyB9XG59XG5cbmZ1bmN0aW9uIGVkZ2VXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgdmFyIG0gPSBzdHJpbmcubWF0Y2goL14oKFsgXFx0XFxyXFxuXSopKFxccyopKSg/Oig/PVxcUylbXFxzXFxTXSpcXFMpPygoXFxzKj8pKFsgXFx0XFxyXFxuXSopKSQvKTtcbiAgcmV0dXJuIHtcbiAgICBsZWFkaW5nOiBtWzFdLCAvLyB3aG9sZSBzdHJpbmcgZm9yIHdoaXRlc3BhY2Utb25seSBzdHJpbmdzXG4gICAgbGVhZGluZ0FzY2lpOiBtWzJdLFxuICAgIGxlYWRpbmdOb25Bc2NpaTogbVszXSxcbiAgICB0cmFpbGluZzogbVs0XSwgLy8gZW1wdHkgZm9yIHdoaXRlc3BhY2Utb25seSBzdHJpbmdzXG4gICAgdHJhaWxpbmdOb25Bc2NpaTogbVs1XSxcbiAgICB0cmFpbGluZ0FzY2lpOiBtWzZdXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGbGFua2VkQnlXaGl0ZXNwYWNlIChzaWRlLCBub2RlLCBvcHRpb25zKSB7XG4gIHZhciBzaWJsaW5nO1xuICB2YXIgcmVnRXhwO1xuICB2YXIgaXNGbGFua2VkO1xuXG4gIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVnRXhwID0gLyAkLztcbiAgfSBlbHNlIHtcbiAgICBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICByZWdFeHAgPSAvXiAvO1xuICB9XG5cbiAgaWYgKHNpYmxpbmcpIHtcbiAgICBpZiAoc2libGluZy5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgaXNGbGFua2VkID0gcmVnRXhwLnRlc3Qoc2libGluZy5ub2RlVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wcmVmb3JtYXR0ZWRDb2RlICYmIHNpYmxpbmcubm9kZU5hbWUgPT09ICdDT0RFJykge1xuICAgICAgaXNGbGFua2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzaWJsaW5nLm5vZGVUeXBlID09PSAxICYmICFpc0Jsb2NrKHNpYmxpbmcpKSB7XG4gICAgICBpc0ZsYW5rZWQgPSByZWdFeHAudGVzdChzaWJsaW5nLnRleHRDb250ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzRmxhbmtlZFxufVxuXG52YXIgcmVkdWNlID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZTtcbnZhciBlc2NhcGVzID0gW1xuICBbL1xcXFwvZywgJ1xcXFxcXFxcJ10sXG4gIFsvXFwqL2csICdcXFxcKiddLFxuICBbL14tL2csICdcXFxcLSddLFxuICBbL15cXCsgL2csICdcXFxcKyAnXSxcbiAgWy9eKD0rKS9nLCAnXFxcXCQxJ10sXG4gIFsvXigjezEsNn0pIC9nLCAnXFxcXCQxICddLFxuICBbL2AvZywgJ1xcXFxgJ10sXG4gIFsvXn5+fi9nLCAnXFxcXH5+fiddLFxuICBbL1xcWy9nLCAnXFxcXFsnXSxcbiAgWy9cXF0vZywgJ1xcXFxdJ10sXG4gIFsvXj4vZywgJ1xcXFw+J10sXG4gIFsvXy9nLCAnXFxcXF8nXSxcbiAgWy9eKFxcZCspXFwuIC9nLCAnJDFcXFxcLiAnXVxuXTtcblxuZnVuY3Rpb24gVHVybmRvd25TZXJ2aWNlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUdXJuZG93blNlcnZpY2UpKSByZXR1cm4gbmV3IFR1cm5kb3duU2VydmljZShvcHRpb25zKVxuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBydWxlczogcnVsZXMsXG4gICAgaGVhZGluZ1N0eWxlOiAnc2V0ZXh0JyxcbiAgICBocjogJyogKiAqJyxcbiAgICBidWxsZXRMaXN0TWFya2VyOiAnKicsXG4gICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgZmVuY2U6ICdgYGAnLFxuICAgIGVtRGVsaW1pdGVyOiAnXycsXG4gICAgc3Ryb25nRGVsaW1pdGVyOiAnKionLFxuICAgIGxpbmtTdHlsZTogJ2lubGluZWQnLFxuICAgIGxpbmtSZWZlcmVuY2VTdHlsZTogJ2Z1bGwnLFxuICAgIGJyOiAnICAnLFxuICAgIHByZWZvcm1hdHRlZENvZGU6IGZhbHNlLFxuICAgIGJsYW5rUmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pc0Jsb2NrID8gJ1xcblxcbicgOiAnJ1xuICAgIH0sXG4gICAga2VlcFJlcGxhY2VtZW50OiBmdW5jdGlvbiAoY29udGVudCwgbm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaXNCbG9jayA/ICdcXG5cXG4nICsgbm9kZS5vdXRlckhUTUwgKyAnXFxuXFxuJyA6IG5vZGUub3V0ZXJIVE1MXG4gICAgfSxcbiAgICBkZWZhdWx0UmVwbGFjZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pc0Jsb2NrID8gJ1xcblxcbicgKyBjb250ZW50ICsgJ1xcblxcbicgOiBjb250ZW50XG4gICAgfVxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlcyh0aGlzLm9wdGlvbnMpO1xufVxuXG5UdXJuZG93blNlcnZpY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogVGhlIGVudHJ5IHBvaW50IGZvciBjb252ZXJ0aW5nIGEgc3RyaW5nIG9yIERPTSBub2RlIHRvIE1hcmtkb3duXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlucHV0IFRoZSBzdHJpbmcgb3IgRE9NIG5vZGUgdG8gY29udmVydFxuICAgKiBAcmV0dXJucyBBIE1hcmtkb3duIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dFxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG5cbiAgdHVybmRvd246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghY2FuQ29udmVydChpbnB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGlucHV0ICsgJyBpcyBub3QgYSBzdHJpbmcsIG9yIGFuIGVsZW1lbnQvZG9jdW1lbnQvZnJhZ21lbnQgbm9kZS4nXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGlucHV0ID09PSAnJykgcmV0dXJuICcnXG5cbiAgICB2YXIgb3V0cHV0ID0gcHJvY2Vzcy5jYWxsKHRoaXMsIG5ldyBSb290Tm9kZShpbnB1dCwgdGhpcy5vcHRpb25zKSk7XG4gICAgcmV0dXJuIHBvc3RQcm9jZXNzLmNhbGwodGhpcywgb3V0cHV0KVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgcGx1Z2luc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258QXJyYXl9IHBsdWdpbiBUaGUgcGx1Z2luIG9yIGFycmF5IG9mIHBsdWdpbnMgdG8gYWRkXG4gICAqIEByZXR1cm5zIFRoZSBUdXJuZG93biBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuXG4gIHVzZTogZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2luLmxlbmd0aDsgaSsrKSB0aGlzLnVzZShwbHVnaW5baV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwbHVnaW4gbXVzdCBiZSBhIEZ1bmN0aW9uIG9yIGFuIEFycmF5IG9mIEZ1bmN0aW9ucycpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBydWxlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdW5pcXVlIGtleSBvZiB0aGUgcnVsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcnVsZSBUaGUgcnVsZVxuICAgKiBAcmV0dXJucyBUaGUgVHVybmRvd24gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cblxuICBhZGRSdWxlOiBmdW5jdGlvbiAoa2V5LCBydWxlKSB7XG4gICAgdGhpcy5ydWxlcy5hZGQoa2V5LCBydWxlKTtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8qKlxuICAgKiBLZWVwIGEgbm9kZSAoYXMgSFRNTCkgdGhhdCBtYXRjaGVzIHRoZSBmaWx0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxGdW5jdGlvbn0gZmlsdGVyIFRoZSB1bmlxdWUga2V5IG9mIHRoZSBydWxlXG4gICAqIEByZXR1cm5zIFRoZSBUdXJuZG93biBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuXG4gIGtlZXA6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICB0aGlzLnJ1bGVzLmtlZXAoZmlsdGVyKTtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZmlsdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8RnVuY3Rpb259IGZpbHRlciBUaGUgdW5pcXVlIGtleSBvZiB0aGUgcnVsZVxuICAgKiBAcmV0dXJucyBUaGUgVHVybmRvd24gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShmaWx0ZXIpO1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgTWFya2Rvd24gc3ludGF4XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJucyBBIHN0cmluZyB3aXRoIE1hcmtkb3duIHN5bnRheCBlc2NhcGVkXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cblxuICBlc2NhcGU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gZXNjYXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBlc2NhcGUpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvci5yZXBsYWNlKGVzY2FwZVswXSwgZXNjYXBlWzFdKVxuICAgIH0sIHN0cmluZylcbiAgfVxufTtcblxuLyoqXG4gKiBSZWR1Y2VzIGEgRE9NIG5vZGUgZG93biB0byBpdHMgTWFya2Rvd24gc3RyaW5nIGVxdWl2YWxlbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnROb2RlIFRoZSBub2RlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEEgTWFya2Rvd24gcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGVcbiAqIEB0eXBlIFN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3MgKHBhcmVudE5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gcmVkdWNlLmNhbGwocGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAob3V0cHV0LCBub2RlKSB7XG4gICAgbm9kZSA9IG5ldyBOb2RlKG5vZGUsIHNlbGYub3B0aW9ucyk7XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSAnJztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmlzQ29kZSA/IG5vZGUubm9kZVZhbHVlIDogc2VsZi5lc2NhcGUobm9kZS5ub2RlVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudEZvck5vZGUuY2FsbChzZWxmLCBub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gam9pbihvdXRwdXQsIHJlcGxhY2VtZW50KVxuICB9LCAnJylcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHN0cmluZ3MgYXMgZWFjaCBydWxlIHJlcXVpcmVzIGFuZCB0cmltcyB0aGUgb3V0cHV0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dCBUaGUgY29udmVyc2lvbiBvdXRwdXRcbiAqIEByZXR1cm5zIEEgdHJpbW1lZCB2ZXJzaW9uIG9mIHRoZSBvdXB1dFxuICogQHR5cGUgU3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3MgKG91dHB1dCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICh0eXBlb2YgcnVsZS5hcHBlbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG91dHB1dCA9IGpvaW4ob3V0cHV0LCBydWxlLmFwcGVuZChzZWxmLm9wdGlvbnMpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQucmVwbGFjZSgvXltcXHRcXHJcXG5dKy8sICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxzXSskLywgJycpXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gZWxlbWVudCBub2RlIHRvIGl0cyBNYXJrZG93biBlcXVpdmFsZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBIE1hcmtkb3duIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlXG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlbWVudEZvck5vZGUgKG5vZGUpIHtcbiAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmZvck5vZGUobm9kZSk7XG4gIHZhciBjb250ZW50ID0gcHJvY2Vzcy5jYWxsKHRoaXMsIG5vZGUpO1xuICB2YXIgd2hpdGVzcGFjZSA9IG5vZGUuZmxhbmtpbmdXaGl0ZXNwYWNlO1xuICBpZiAod2hpdGVzcGFjZS5sZWFkaW5nIHx8IHdoaXRlc3BhY2UudHJhaWxpbmcpIGNvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcbiAgcmV0dXJuIChcbiAgICB3aGl0ZXNwYWNlLmxlYWRpbmcgK1xuICAgIHJ1bGUucmVwbGFjZW1lbnQoY29udGVudCwgbm9kZSwgdGhpcy5vcHRpb25zKSArXG4gICAgd2hpdGVzcGFjZS50cmFpbGluZ1xuICApXG59XG5cbi8qKlxuICogSm9pbnMgcmVwbGFjZW1lbnQgdG8gdGhlIGN1cnJlbnQgb3V0cHV0IHdpdGggYXBwcm9wcmlhdGUgbnVtYmVyIG9mIG5ldyBsaW5lc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXQgVGhlIGN1cnJlbnQgY29udmVyc2lvbiBvdXRwdXRcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIGFwcGVuZCB0byB0aGUgb3V0cHV0XG4gKiBAcmV0dXJucyBKb2luZWQgb3V0cHV0XG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBqb2luIChvdXRwdXQsIHJlcGxhY2VtZW50KSB7XG4gIHZhciBzMSA9IHRyaW1UcmFpbGluZ05ld2xpbmVzKG91dHB1dCk7XG4gIHZhciBzMiA9IHRyaW1MZWFkaW5nTmV3bGluZXMocmVwbGFjZW1lbnQpO1xuICB2YXIgbmxzID0gTWF0aC5tYXgob3V0cHV0Lmxlbmd0aCAtIHMxLmxlbmd0aCwgcmVwbGFjZW1lbnQubGVuZ3RoIC0gczIubGVuZ3RoKTtcbiAgdmFyIHNlcGFyYXRvciA9ICdcXG5cXG4nLnN1YnN0cmluZygwLCBubHMpO1xuXG4gIHJldHVybiBzMSArIHNlcGFyYXRvciArIHMyXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGlucHV0IGNhbiBiZSBjb252ZXJ0ZWRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gaW5wdXQgRGVzY3JpYmUgdGhpcyBwYXJhbWV0ZXJcbiAqIEByZXR1cm5zIERlc2NyaWJlIHdoYXQgaXQgcmV0dXJuc1xuICogQHR5cGUgU3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufE51bWJlclxuICovXG5cbmZ1bmN0aW9uIGNhbkNvbnZlcnQgKGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQgIT0gbnVsbCAmJiAoXG4gICAgICB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAoaW5wdXQubm9kZVR5cGUgJiYgKFxuICAgICAgICBpbnB1dC5ub2RlVHlwZSA9PT0gMSB8fCBpbnB1dC5ub2RlVHlwZSA9PT0gOSB8fCBpbnB1dC5ub2RlVHlwZSA9PT0gMTFcbiAgICAgICkpXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFR1cm5kb3duU2VydmljZTtcbiIsImltcG9ydCB7IHRhYmxlcyB9IGZyb20gJ3R1cm5kb3duLXBsdWdpbi1nZm0nO1xuaW1wb3J0IFR1cm5kb3duU2VydmljZSBmcm9tICd0dXJuZG93bic7XG5cbmV4cG9ydCB0eXBlIEZvcm1hdE1vZGUgPVxuICB8ICdyZW5kZXInIC8vIEZvciBtYXJrZG93biByZW5kZXJpbmdcbiAgfCAnaW5nZXN0JyAvLyBGb3IgY29uc3VtcHRpb24gYnkgTExNc1xuICB8ICd2YW5pbGxhJzsgLy8gV2l0aG91dCBhbnkgcHJvY2Vzc2luZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRpZHlNYXJrZG93bihtYXJrZG93bjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gU3RlcCAxOiBIYW5kbGUgY29tcGxleCBicm9rZW4gbGlua3Mgd2l0aCB0ZXh0IGFuZCBvcHRpb25hbCBpbWFnZXMgc3ByZWFkIGFjcm9zcyBtdWx0aXBsZSBsaW5lc1xuICBsZXQgbm9ybWFsaXplZE1hcmtkb3duID0gbWFya2Rvd24ucmVwbGFjZShcbiAgICAvXFxbXFxzKihbXlxcXVxcbl0rPylcXHMqXFxdXFxzKlxcKFxccyooW14pXSspXFxzKlxcKS9nLFxuICAgIChfbWF0Y2gsIHRleHQsIHVybCkgPT4ge1xuICAgICAgY29uc3QgY2xlYW5UZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgY29uc3QgY2xlYW5VcmwgPSB1cmwucmVwbGFjZSgvXFxzKy9nLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIGBbJHtjbGVhblRleHR9XSgke2NsZWFuVXJsfSlgO1xuICAgIH0sXG4gICk7XG5cbiAgbm9ybWFsaXplZE1hcmtkb3duID0gbm9ybWFsaXplZE1hcmtkb3duLnJlcGxhY2UoXG4gICAgL1xcW1xccyooW15cXF1cXG4hXSo/KVxccypcXG4qKD86IVxcWyhbXlxcXV0qKVxcXVxcKCguKj8pXFwpKT9cXHMqXFxuKlxcXVxccypcXChcXHMqKFteKV0rKVxccypcXCkvZyxcbiAgICAoX21hdGNoLCB0ZXh0LCBhbHQsIGltZ1VybCwgbGlua1VybCkgPT4ge1xuICAgICAgY29uc3QgY2xlYW5UZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgY29uc3QgY2xlYW5BbHQgPSBhbHQgPyBhbHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKSA6ICcnO1xuICAgICAgY29uc3QgY2xlYW5JbWdVcmwgPSBpbWdVcmwgPyBpbWdVcmwucmVwbGFjZSgvXFxzKy9nLCAnJykudHJpbSgpIDogJyc7XG4gICAgICBjb25zdCBjbGVhbkxpbmtVcmwgPSBsaW5rVXJsLnJlcGxhY2UoL1xccysvZywgJycpLnRyaW0oKTtcbiAgICAgIGlmIChjbGVhbkltZ1VybCkge1xuICAgICAgICByZXR1cm4gYFske2NsZWFuVGV4dH0gIVske2NsZWFuQWx0fV0oJHtjbGVhbkltZ1VybH0pXSgke2NsZWFuTGlua1VybH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgWyR7Y2xlYW5UZXh0fV0oJHtjbGVhbkxpbmtVcmx9KWA7XG4gICAgfSxcbiAgKTtcblxuICAvLyBTdGVwIDI6IE5vcm1hbGl6ZSByZWd1bGFyIGxpbmtzIHRoYXQgbWF5IGJlIGJyb2tlbiBhY3Jvc3MgbGluZXNcbiAgbm9ybWFsaXplZE1hcmtkb3duID0gbm9ybWFsaXplZE1hcmtkb3duLnJlcGxhY2UoXG4gICAgL1xcW1xccyooW15cXF1dKylcXF1cXHMqXFwoXFxzKihbXildKylcXCkvZyxcbiAgICAoX21hdGNoLCB0ZXh0LCB1cmwpID0+IHtcbiAgICAgIGNvbnN0IGNsZWFuVGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGNsZWFuVXJsID0gdXJsLnJlcGxhY2UoL1xccysvZywgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiBgWyR7Y2xlYW5UZXh0fV0oJHtjbGVhblVybH0pYDtcbiAgICB9LFxuICApO1xuXG4gIC8vIFN0ZXAgMzogUmVtb3ZlIGxlYWRpbmcgc3BhY2VzIGZyb20gZWFjaCBsaW5lXG4gIG5vcm1hbGl6ZWRNYXJrZG93biA9IG5vcm1hbGl6ZWRNYXJrZG93bi5yZXBsYWNlKC9eWyBcXHRdKy9nbSwgJycpO1xuXG4gIC8vIFN0ZXAgNDogUmVwbGFjZSBtb3JlIHRoYW4gdHdvIGNvbnNlY3V0aXZlIGVtcHR5IGxpbmVzIHdpdGggZXhhY3RseSB0d28gZW1wdHkgbGluZXNcbiAgbm9ybWFsaXplZE1hcmtkb3duID0gbm9ybWFsaXplZE1hcmtkb3duLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpO1xuXG4gIHJldHVybiBub3JtYWxpemVkTWFya2Rvd24udHJpbSgpO1xufVxuXG4vKipcbiAqIENsZWFuIG1hcmtkb3duIGZvciBjb25zdW1wdGlvbiBieSBMTE0sIGJ5IHJlbW92aW5nIGltYWdlcyBhbmQgbGlua3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbk1hcmtkb3duRm9ySW5nZXN0KG1hcmtkb3duOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBSZW1vdmUgaW1hZ2VzXG4gIGxldCBwbGFpblRleHQgPSBtYXJrZG93bi5yZXBsYWNlKC8hXFxbLio/XFxdXFwoLio/XFwpL2csICcnKTtcblxuICAvLyBDb252ZXJ0IGxpbmtzIHRvIHBsYWluIHRleHRcbiAgcGxhaW5UZXh0ID0gcGxhaW5UZXh0LnJlcGxhY2UoL1xcWyguKz8pXFxdXFwoLio/XFwpL2csICckMScpO1xuXG4gIHJldHVybiBwbGFpblRleHQ7XG59XG5cbmNvbnN0IGdldFR1cm5kb3duID0gKG1vZGU6IEZvcm1hdE1vZGUpID0+IHtcbiAgY29uc3QgdHVybkRvd25TZXJ2aWNlID0gbmV3IFR1cm5kb3duU2VydmljZSh7XG4gICAgaGVhZGluZ1N0eWxlOiAnYXR4JyxcbiAgICBidWxsZXRMaXN0TWFya2VyOiAnLScsXG4gICAgY29kZUJsb2NrU3R5bGU6ICdmZW5jZWQnLFxuICB9KTtcbiAgaWYgKG1vZGUgPT09ICdyZW5kZXInKSB7XG4gICAgdHVybkRvd25TZXJ2aWNlLmFkZFJ1bGUoJ3JlbW92ZS1pcnJlbGV2YW50Jywge1xuICAgICAgZmlsdGVyOiBbJ21ldGEnLCAnc3R5bGUnLCAnc2NyaXB0JywgJ25vc2NyaXB0JywgJ2xpbmsnLCAndGV4dGFyZWEnXSxcbiAgICAgIHJlcGxhY2VtZW50OiAoKSA9PiAnJyxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnaW5nZXN0Jykge1xuICAgIHR1cm5Eb3duU2VydmljZS5hZGRSdWxlKCdyZW1vdmUtaXJyZWxldmFudCcsIHtcbiAgICAgIGZpbHRlcjogWydtZXRhJywgJ3N0eWxlJywgJ3NjcmlwdCcsICdub3NjcmlwdCcsICdsaW5rJywgJ3RleHRhcmVhJywgJ2ltZyddLFxuICAgICAgcmVwbGFjZW1lbnQ6ICgpID0+ICcnLFxuICAgIH0pO1xuICAgIHR1cm5Eb3duU2VydmljZS5hZGRSdWxlKCd1bmxpbmsnLCB7XG4gICAgICBmaWx0ZXI6IFsnYSddLFxuICAgICAgcmVwbGFjZW1lbnQ6IChfY29udGVudCwgbm9kZSkgPT4gbm9kZS50ZXh0Q29udGVudCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0dXJuRG93blNlcnZpY2U7XG59O1xuXG5leHBvcnQgY29uc3QgY29udmVydEhUTUxUb01hcmtkb3duID0gKG1vZGU6IEZvcm1hdE1vZGUsIGh0bWw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHR1cm5Eb3duUGx1Z2lucyA9IFt0YWJsZXNdO1xuICBjb25zdCB0b0JlVHVybmVkVG9NZCA9IGh0bWw7XG4gIGxldCB0dXJuRG93blNlcnZpY2UgPSBnZXRUdXJuZG93bihtb2RlKTtcbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgdHVybkRvd25QbHVnaW5zKSB7XG4gICAgdHVybkRvd25TZXJ2aWNlID0gdHVybkRvd25TZXJ2aWNlLnVzZShwbHVnaW4pO1xuICB9XG5cbiAgbGV0IGNvbnRlbnRUZXh0ID0gJyc7XG4gIGlmICh0b0JlVHVybmVkVG9NZCkge1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VGV4dCA9IHR1cm5Eb3duU2VydmljZS50dXJuZG93bih0b0JlVHVybmVkVG9NZCkudHJpbSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVHVybmRvd24gZmFpbGVkIHRvIHJ1biwgcmV0cnlpbmcgd2l0aG91dCBwbHVnaW5zOiAke2Vycn1gKTtcbiAgICAgIGNvbnN0IHZhbmlsbGFUdXJuRG93blNlcnZpY2UgPSBnZXRUdXJuZG93bigndmFuaWxsYScpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudFRleHQgPSB2YW5pbGxhVHVybkRvd25TZXJ2aWNlLnR1cm5kb3duKHRvQmVUdXJuZWRUb01kKS50cmltKCk7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFR1cm5kb3duIGZhaWxlZCB0byBydW4sIGdpdmluZyB1cDogJHtlcnIyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICAhY29udGVudFRleHQgfHxcbiAgICAoY29udGVudFRleHQuc3RhcnRzV2l0aCgnPCcpICYmIGNvbnRlbnRUZXh0LmVuZHNXaXRoKCc+JykgJiYgdG9CZVR1cm5lZFRvTWQgIT09IGh0bWwpXG4gICkge1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VGV4dCA9IHR1cm5Eb3duU2VydmljZS50dXJuZG93bihodG1sKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybignVHVybmRvd24gZmFpbGVkIHRvIHJ1biwgcmV0cnlpbmcgd2l0aG91dCBwbHVnaW5zJywgeyBlcnIgfSk7XG4gICAgICBjb25zdCB2YW5pbGxhVHVybkRvd25TZXJ2aWNlID0gZ2V0VHVybmRvd24oJ3ZhbmlsbGEnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRUZXh0ID0gdmFuaWxsYVR1cm5Eb3duU2VydmljZS50dXJuZG93bihodG1sKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUdXJuZG93biBmYWlsZWQgdG8gcnVuLCBnaXZpbmcgdXAnLCB7IGVycjogZXJyMiB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGlkeU1hcmtkb3duKGNvbnRlbnRUZXh0IHx8ICcnKS50cmltKCk7XG59O1xuIiwiaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdub2RlLWh0bWwtcGFyc2VyJztcbmltcG9ydCB7IFJlYWRhYmlsaXR5IH0gZnJvbSAnQG1vemlsbGEvcmVhZGFiaWxpdHknO1xuaW1wb3J0IHsgY29udmVydEhUTUxUb01hcmtkb3duIH0gZnJvbSAnLi9tYXJrZG93bic7XG5cbi8vIEhUTUwgcHJlcHJvY2Vzc2luZyB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBjbGVhbkh0bWwgPSAoaHRtbENvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCBjbGVhbmVkSHRtbCA9IGh0bWxDb250ZW50O1xuXG4gIC8vIFJlbW92ZSBhbGwgY29tbWVudHNcbiAgY2xlYW5lZEh0bWwgPSBjbGVhbmVkSHRtbC5yZXBsYWNlKC88IS0tW1xcc1xcU10qPy0tPi9nLCAnJyk7XG5cbiAgLy8gUmVtb3ZlIGFsbCBzY3JpcHQgYW5kIHN0eWxlIHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50XG4gIGNsZWFuZWRIdG1sID0gY2xlYW5lZEh0bWwucmVwbGFjZSgvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSwgJycpO1xuICBjbGVhbmVkSHRtbCA9IGNsZWFuZWRIdG1sLnJlcGxhY2UoLzxzdHlsZVxcYltePF0qKD86KD8hPFxcL3N0eWxlPik8W148XSopKjxcXC9zdHlsZT4vZ2ksICcnKTtcblxuICAvLyBSZW1vdmUgYmFzZTY0IGltYWdlc1xuICBjbGVhbmVkSHRtbCA9IGNsZWFuZWRIdG1sLnJlcGxhY2UoLzxpbWdbXj5dK3NyYz1cImRhdGE6aW1hZ2VcXC9bXj5dK1wiW14+XSo+L2csICcnKTtcblxuICAvLyBSZW1vdmUgZW1wdHkgdGFncyBleGNlcHQgZm9yIHNwZWNpZmljIG9uZXMgd2Ugd2FudCB0byBrZWVwXG4gIGNvbnN0IGtlZXBUYWdzID0gWydpbWcnLCAnYnInLCAnaHInXTtcbiAgY29uc3QgZW1wdHlUYWdQYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICBgPCg/ISg/OiR7a2VlcFRhZ3Muam9pbignfCcpfSlcXGIpW14+XSs/PltcXHNcXHJcXG5dKjwvW14+XSs/PmAsXG4gICAgJ2cnLFxuICApO1xuICBjbGVhbmVkSHRtbCA9IGNsZWFuZWRIdG1sLnJlcGxhY2UoZW1wdHlUYWdQYXR0ZXJuLCAnJyk7XG5cbiAgLy8gQ2xlYW4gdXAgZXhjZXNzaXZlIHdoaXRlc3BhY2VcbiAgY2xlYW5lZEh0bWwgPSBjbGVhbmVkSHRtbC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuXG4gIHJldHVybiBjbGVhbmVkSHRtbDtcbn07XG5cbi8vIE1hcmtkb3duIHBvc3Rwcm9jZXNzaW5nIHV0aWxpdGllc1xuY29uc3QgY2xlYW5NYXJrZG93biA9IChtYXJrZG93bkNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCBjbGVhbmVkTWFya2Rvd24gPSBtYXJrZG93bkNvbnRlbnQ7XG5cbiAgLy8gUmVtb3ZlIG11bHRpcGxlIGNvbnNlY3V0aXZlIGVtcHR5IGxpbmVzIChidXQga2VlcCBkb3VibGUgbmV3bGluZXMpXG4gIGNsZWFuZWRNYXJrZG93biA9IGNsZWFuZWRNYXJrZG93bi5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKTtcblxuICAvLyBSZW1vdmUgdHJhaWxpbmcgc3BhY2VzIGF0IHRoZSBlbmQgb2YgbGluZXMgKGJ1dCBrZWVwIG5ld2xpbmVzKVxuICBjbGVhbmVkTWFya2Rvd24gPSBjbGVhbmVkTWFya2Rvd24ucmVwbGFjZSgvWyBcXHRdKyQvZ20sICcnKTtcblxuICAvLyBDbGVhbiB1cCBjb2RlIGJsb2NrcyAoZW5zdXJlIHByb3BlciBzcGFjaW5nKVxuICBjbGVhbmVkTWFya2Rvd24gPSBjbGVhbmVkTWFya2Rvd24ucmVwbGFjZSgvYGBgKFxcdyopXFxuXFxuL2csICdgYGAkMVxcbicpO1xuXG4gIC8vIFJlbW92ZSBiYXNlNjQgaW1hZ2UgbWFya2Rvd25cbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoLyFcXFtbXlxcXV0qXFxdXFwoZGF0YTppbWFnZVxcL1teKV0rXFwpL2csICcnKTtcblxuICAvLyBSZW1vdmUgamF2YXNjcmlwdDogbGlua3NcbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoL1xcW1teXFxdXSpcXF1cXChqYXZhc2NyaXB0OlteKV0qXFwpL2csICcnKTtcbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoL1xcKGphdmFzY3JpcHQ6W14pXSpcXCkvZywgJycpO1xuXG4gIC8vIFJlbW92ZSBlbXB0eSBsaW5rc1xuICBjbGVhbmVkTWFya2Rvd24gPSBjbGVhbmVkTWFya2Rvd24ucmVwbGFjZSgvXFxbKFteXFxdXSopXFxdXFwoXFxzKlxcKS9nLCAnJDEnKTtcbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoLyFcXFsoW15cXF1dKilcXF1cXChcXHMqXFwpL2csICcnKTtcblxuICAvLyBDbGVhbiB1cCBleGNlc3NpdmUgc3BhY2VzIGFyb3VuZCBib2xkL2l0YWxpYyBtYXJrZXJzXG4gIGNsZWFuZWRNYXJrZG93biA9IGNsZWFuZWRNYXJrZG93bi5yZXBsYWNlKC9cXCpcXHMrKFxcUykvZywgJyokMScpO1xuICBjbGVhbmVkTWFya2Rvd24gPSBjbGVhbmVkTWFya2Rvd24ucmVwbGFjZSgvKFxcUylcXHMrXFwqL2csICckMSonKTtcblxuICAvLyBSZW1vdmUgemVyby13aWR0aCBzcGFjZXMgYW5kIG90aGVyIGludmlzaWJsZSBjaGFyYWN0ZXJzXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9NaXNsZWFkaW5nQ2hhcmFjdGVyQ2xhc3M6IDxleHBsYW5hdGlvbj5cbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoL1tcXHUyMDBCXFx1MjAwQ1xcdTIwMERcXHVGRUZGXS9nLCAnJyk7XG5cbiAgLy8gUmVtb3ZlIGVtcHR5IGxpbmVzIHRoYXQgb25seSBjb250YWluIHNwYWNlcyBvciBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoL15cXHMqW1xcW1xcXVxcKFxcKVxcKlxcLVxcX1xcI1xcflxcYF0rXFxzKiQvZ20sICcnKTtcblxuICAvLyBjbGVhbiB1cCBtdWx0aXBsZSBzcGFjZXMgYmV0d2VlbiB3b3Jkc1xuICBjbGVhbmVkTWFya2Rvd24gPSBjbGVhbmVkTWFya2Rvd24ucmVwbGFjZSgvW15cXFNcXG5dezIsfS9nLCAnICcpO1xuXG4gIC8vIGVuc3VyZSBwYXJhZ3JhcGhzIGhhdmUgYXBwcm9wcmlhdGUgbmV3bGluZXNcbiAgY2xlYW5lZE1hcmtkb3duID0gY2xlYW5lZE1hcmtkb3duLnJlcGxhY2UoLyhcXFMpXFxuXFxuKFxcUykvZywgJyQxXFxuXFxuJDInKTtcblxuICAvLyBlbnN1cmUgbGlzdCBpdGVtcyBoYXZlIGFwcHJvcHJpYXRlIG5ld2xpbmVzXG4gIGNsZWFuZWRNYXJrZG93biA9IGNsZWFuZWRNYXJrZG93bi5yZXBsYWNlKC8oXFxuWypcXC0rXSAuKylcXG4oW14qXFwtK1xcbl0pL2csICckMVxcblxcbiQyJyk7XG5cbiAgcmV0dXJuIGNsZWFuZWRNYXJrZG93bi50cmltKCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlVW51c2VkSHRtbE5vZGUgPSAoKSA9PiB7XG4gIGNvbnN0ICQgPSBwYXJzZShkb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50Py5pbm5lckhUTUwpO1xuXG4gIGZvciAoY29uc3QgaXRlbSBvZiAkLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJykpIHtcbiAgICBpdGVtLmlubmVySFRNTCA9ICdwe2NvbG9yOiByZWQ7fSc7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mICQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0JykpIHtcbiAgICBpdGVtLmlubmVySFRNTCA9IGBjb25zb2xlLmxvZygnc2NyaXB0JylgO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiAkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmsnKSkge1xuICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdocmVmJywgJycpO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiAkLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpKSB7XG4gICAgaXRlbS5pbm5lckhUTUwgPSBgPHN2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIGZpbGw9XCIjMDA3N2I2XCIgLz5cbjwvc3ZnPmA7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mICQucXVlcnlTZWxlY3RvckFsbCgnaW1nJykpIHtcbiAgICAvLyBSZW1vdmUgYmFzZTY0IGltYWdlcyBhbmQga2VlcCBvbmx5IHZhbGlkIFVSTCBpbWFnZXNcbiAgICBjb25zdCBzcmMgPSBpdGVtLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnYWxsJywgJ3Vuc2V0Jyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiAkLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BsYXNtby1jc3VpJykpIHtcbiAgICBpdGVtLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gIH1cblxuICBjb25zdCBjb21tZW50Tm9kZXMgPSAkLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKS5maWx0ZXIoXG4gICAgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFLFxuICApO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29tbWVudE5vZGVzKSB7XG4gICAgaXRlbS5yZW1vdmUoKTtcbiAgfVxuXG4gIGNvbnN0IGh0bWwgPSAkLmlubmVySFRNTDtcbiAgcmV0dXJuIGNsZWFuSHRtbChodG1sKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRSZWFkYWJpbGl0eUh0bWwgPSAobm9kZTogRG9jdW1lbnQgfCBIVE1MRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgUmVhZGFiaWxpdHkobm9kZS5jbG9uZU5vZGUodHJ1ZSkgYXMgRG9jdW1lbnQpLnBhcnNlKCk7XG4gICAgcmV0dXJuIHBhcnNlZD8uY29udGVudCA/IGNsZWFuSHRtbChwYXJzZWQuY29udGVudCkgOiByZW1vdmVVbnVzZWRIdG1sTm9kZSgpO1xuICB9IGNhdGNoIChfZXJyKSB7XG4gICAgcmV0dXJuIHJlbW92ZVVudXNlZEh0bWxOb2RlKCk7XG4gIH1cbn07XG5cbi8vIENvbW1vbiBwcmVwcm9jZXNzaW5nIG1ldGhvZCBmb3IgSFRNTCBjb250ZW50XG5leHBvcnQgY29uc3QgcHJlcHJvY2Vzc0h0bWxDb250ZW50ID0gKFxuICBodG1sQ29udGVudDogc3RyaW5nIHwgRG9jdW1lbnQgfCBIVE1MRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnQsXG4pOiBzdHJpbmcgPT4ge1xuICBsZXQgY29udGVudCA9ICcnO1xuXG4gIC8vIEhhbmRsZSBkaWZmZXJlbnQgaW5wdXQgdHlwZXNcbiAgaWYgKHR5cGVvZiBodG1sQ29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb250ZW50ID0gaHRtbENvbnRlbnQ7XG4gIH0gZWxzZSBpZiAoXG4gICAgaHRtbENvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCB8fFxuICAgIGh0bWxDb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICBodG1sQ29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGh0bWxDb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgY29udGVudCA9IGRpdi5pbm5lckhUTUw7XG4gIH1cblxuICAvLyBPbmx5IGRvIG1pbmltYWwgY2xlYW5pbmcgdG8gcHJlc2VydmUgSFRNTCBzdHJ1Y3R1cmVcbiAgY29udGVudCA9IGNvbnRlbnRcbiAgICAvLyBSZW1vdmUgc2NyaXB0IHRhZ3NcbiAgICAucmVwbGFjZSgvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSwgJycpXG4gICAgLy8gUmVtb3ZlIHN0eWxlIHRhZ3NcbiAgICAucmVwbGFjZSgvPHN0eWxlXFxiW148XSooPzooPyE8XFwvc3R5bGU+KTxbXjxdKikqPFxcL3N0eWxlPi9naSwgJycpXG4gICAgLy8gUmVtb3ZlIGNvbW1lbnRzXG4gICAgLnJlcGxhY2UoLzwhLS1bXFxzXFxTXSo/LS0+L2csICcnKTtcblxuICByZXR1cm4gY29udGVudDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRNYXJrZG93biA9IChlbGVtZW50OiBEb2N1bWVudCB8IEhUTUxFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudCkgPT4ge1xuICBjb25zdCBodG1sID0gcHJlcHJvY2Vzc0h0bWxDb250ZW50KGVsZW1lbnQpO1xuICBjb25zdCBtZCA9IGNvbnZlcnRIVE1MVG9NYXJrZG93bigncmVuZGVyJywgaHRtbCk7XG4gIHJldHVybiBjbGVhbk1hcmtkb3duKG1kKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRSZWFkYWJpbGl0eU1hcmtkb3duID0gKGVsZW1lbnQ6IERvY3VtZW50IHwgSFRNTEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50KSA9PiB7XG4gIGNvbnN0IGh0bWwgPSBwcmVwcm9jZXNzSHRtbENvbnRlbnQoZWxlbWVudCk7XG4gIGNvbnN0IG1kID0gY29udmVydEhUTUxUb01hcmtkb3duKCdyZW5kZXInLCBodG1sKTtcbiAgcmV0dXJuIGNsZWFuTWFya2Rvd24obWQpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvbk5vZGVzTWFya2Rvd24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24/LmdldFJhbmdlQXQoMCk7XG4gIGNvbnN0IHRleHQgPSBzZWxlY3Rpb24/LnRvU3RyaW5nKCk7XG5cbiAgY29uc3QgZnJhZ21lbnQgPSByYW5nZT8uY2xvbmVSYW5nZSgpLmNsb25lQ29udGVudHMoKTtcbiAgaWYgKCFmcmFnbWVudCkgcmV0dXJuIHRleHQgfHwgJyc7XG5cbiAgY29uc3QgbWRUZXh0ID0gZ2V0TWFya2Rvd24oZnJhZ21lbnQpO1xuICByZXR1cm4gbWRUZXh0IHx8IHRleHQgfHwgJyc7IC8vIGNvbXBhdGlibGUgd2l0aCBlbXB0eSBtYXJrZG93biB0ZXh0XG59XG4iLCJpbXBvcnQgeyBnZXRNYXJrZG93biB9IGZyb20gJ0ByZWZseS91dGlscy9odG1sMm1kJztcbmltcG9ydCB7IHNlbmRNZXNzYWdlIH0gZnJvbSAnQHJlZmx5LXBhY2thZ2VzL2FpLXdvcmtzcGFjZS1jb21tb24vdXRpbHMvZXh0ZW5zaW9uL21lc3NhZ2luZyc7XG5pbXBvcnQgeyBnZXRSdW50aW1lIH0gZnJvbSAnQHJlZmx5L3V0aWxzL2Vudic7XG5cbmV4cG9ydCBjb25zdCBzYXZlTW9ja2VkUmVzb3VyY2UgPSBhc3luYyAoKSA9PiB7XG4gIC8qKlxuICAgKiBUT0RPOiBAbXJjZnBzIHJlcGxhY2UgcGFnZUNvbnRlbnQgdG8gbWFya2Rvd25cbiAgICovXG4gIGNvbnN0IHBhZ2VDb250ZW50ID0gZ2V0TWFya2Rvd24oZG9jdW1lbnQ/LmJvZHkpO1xuICBjb25zdCByZXNvdXJjZSA9IHtcbiAgICByZXNvdXJjZUlkOiAndGVtcFJlc0lkJyxcbiAgICB0aXRsZTogZG9jdW1lbnQ/LnRpdGxlIHx8ICcnLFxuICAgIGRhdGE6IHtcbiAgICAgIHVybDogbG9jYXRpb24uaHJlZixcbiAgICAgIHRpdGxlOiBkb2N1bWVudD8udGl0bGUgfHwgJycsXG4gICAgfSxcbiAgICByZXNvdXJjZVR5cGU6ICd3ZWJsaW5rJyxcbiAgICBpc1B1YmxpYzogZmFsc2UsXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgY29sbGFiRW5hYmxlZDogZmFsc2UsXG4gICAgY29udGVudDogcGFnZUNvbnRlbnQgfHwgJycsXG4gIH07XG5cbiAgc2VuZE1lc3NhZ2UoXG4gICAge1xuICAgICAgbmFtZTogJ2N1cnJlbnRNb2NrUmVzb3VyY2UnLFxuICAgICAgdHlwZTogJ3N5bmNJbmZvJyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgY3VycmVudE1vY2tSZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICB9LFxuICAgICAgc291cmNlOiBnZXRSdW50aW1lKCksXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgKTtcblxuICByZXR1cm4gcmVzb3VyY2U7XG59O1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXRSdW50aW1lIH0gZnJvbSAnQHJlZmx5L3V0aWxzL2Vudic7XG5pbXBvcnQgeyBvbk1lc3NhZ2UgfSBmcm9tICdAcmVmbHktcGFja2FnZXMvYWktd29ya3NwYWNlLWNvbW1vbi91dGlscy9leHRlbnNpb24vbWVzc2FnaW5nJztcblxuLy8gdXRpbHNcbmltcG9ydCB7IHNhdmVNb2NrZWRSZXNvdXJjZSB9IGZyb20gJ0AvdXRpbHMvc2F2ZS1tb2NrZWQtcmVzb3VyY2UnO1xuaW1wb3J0IHsgQmFja2dyb3VuZE1lc3NhZ2UgfSBmcm9tICdAcmVmbHkvY29tbW9uLXR5cGVzJztcblxuLyoqXG4gKiDlj6rlnKggQ29udGVudCBTY3JpcHQgVUkg5Lit6LCD55SoXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTeW5jV2VibGlua1Jlc291cmNlTWV0YSA9ICgpID0+IHtcbiAgY29uc3QgbWVzc2FnZUxpc3RlbmVyRXZlbnRSZWYgPSB1c2VSZWY8YW55PigpO1xuXG4gIGNvbnN0IG1ha2VUZW1wUmVzb3VyY2VBbmRTYXZlID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNhdmVNb2NrZWRSZXNvdXJjZSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uTWVzc2FnZUhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudDxhbnk+KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50IGFzIGFueSBhcyBCYWNrZ3JvdW5kTWVzc2FnZTtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGRhdGEgfHwge307XG5cbiAgICBpZiAoXG4gICAgICBuYW1lID09PSAncmVmbHlTdGF0dXNDaGVjaycgJiZcbiAgICAgIGRhdGE/LnR5cGUgPT09ICdvdGhlcnMnICYmXG4gICAgICBnZXRSdW50aW1lKCkgPT09ICdleHRlbnNpb24tY3N1aSdcbiAgICApIHtcbiAgICAgIG1ha2VUZW1wUmVzb3VyY2VBbmRTYXZlKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGluaXRNZXNzYWdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgb25NZXNzYWdlKG9uTWVzc2FnZUhhbmRsZXIsIGdldFJ1bnRpbWUoKSkudGhlbigoY2xlYXJFdmVudCkgPT4ge1xuICAgICAgbWVzc2FnZUxpc3RlbmVyRXZlbnRSZWYuY3VycmVudCA9IGNsZWFyRXZlbnQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVzc2FnZUxpc3RlbmVyRXZlbnRSZWYuY3VycmVudD8uKCk7XG4gICAgfTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1ha2VUZW1wUmVzb3VyY2VBbmRTYXZlKCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGluaXRNZXNzYWdlTGlzdGVuZXIsXG4gIH07XG59O1xuIiwiZXhwb3J0IGNvbnN0IGNoZWNrUGFnZVVuc3VwcG9ydGVkID0gKHBhZ2VVcmw6IHN0cmluZykgPT4ge1xuICBpZiAocGFnZVVybCkge1xuICAgIGNvbnN0IGNoZWNrQnJvd3NlclNldHRpbmdQYWdlID1cbiAgICAgIHBhZ2VVcmwuc3RhcnRzV2l0aCgnY2hyb21lOi8vJykgfHxcbiAgICAgIHBhZ2VVcmwuc3RhcnRzV2l0aCgnZWRnZTovLycpIHx8XG4gICAgICBwYWdlVXJsLnN0YXJ0c1dpdGgoJ2FyYzovLycpIHx8XG4gICAgICBwYWdlVXJsLnN0YXJ0c1dpdGgoJ2Fib3V0OicpO1xuICAgIGNvbnN0IGNoZWNrQnJvd3NlckV4dGVuc2lvblN0b3JlUGFnZSA9IFtcbiAgICAgICdodHRwczovL2Jyb3dzZXIuZ29vZ2xlLmNvbS93ZWJzdG9yZScsXG4gICAgICAnaHR0cHM6Ly9taWNyb3NvZnRlZGdlLm1pY3Jvc29mdC5jb20vYWRkb25zJyxcbiAgICAgICdodHRwczovL2FkZG9ucy5tb3ppbGxhLm9yZy9lbi1VUy9maXJlZm94JyxcbiAgICAgICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20nLFxuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9sb2dpbicsXG4gICAgXS5zb21lKCh1cmwpID0+IHBhZ2VVcmwuc3RhcnRzV2l0aCh1cmwpKTtcblxuICAgIHJldHVybiBjaGVja0Jyb3dzZXJTZXR0aW5nUGFnZSB8fCBjaGVja0Jyb3dzZXJFeHRlbnNpb25TdG9yZVBhZ2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICcuL0FwcC5zY3NzJztcblxuLy8gaG9va3Ncbi8vIOiuvue9riBydW50aW1lIOeOr+Wig1xuaW1wb3J0IHsgc2V0UnVudGltZSB9IGZyb20gJ0ByZWZseS91dGlscy9lbnYnO1xuaW1wb3J0IHsgdXNlU3luY1dlYmxpbmtSZXNvdXJjZU1ldGEgfSBmcm9tICdAL2hvb2tzL2NvbnRlbnQtc2NyaXB0cy91c2UtZ2V0LXdlYmxpbmstcmVzb3VyY2UtbWV0YSc7XG5pbXBvcnQgeyBjaGVja1BhZ2VVbnN1cHBvcnRlZCB9IGZyb20gJ0ByZWZseS1wYWNrYWdlcy9haS13b3Jrc3BhY2UtY29tbW9uL3V0aWxzL2V4dGVuc2lvbi9jaGVjayc7XG5cbmNvbnN0IEFwcCA9ICgpID0+IHtcbiAgLy8g5Zyo5oyC6L295pe26K6w5b2V5b2T5YmN6LWE5rqQLE9ubHkgZm9yIENvbnRlbnQgU2NyaXB0XG4gIGNvbnN0IHsgaW5pdE1lc3NhZ2VMaXN0ZW5lciB9ID0gdXNlU3luY1dlYmxpbmtSZXNvdXJjZU1ldGEoKTtcbiAgY29uc3QgaXNEb21WaXNpYmlsaXR5UmVmID0gdXNlUmVmPCd2aXNpYmxlJyB8ICdoaWRkZW4nPihkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuXG4gIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgaXNEb21WaXNpYmlsaXR5UmVmLmN1cnJlbnQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJbml0aWFsIGNoZWNrIGlmIHRoZSBwYWdlIGlzIGFscmVhZHkgdmlzaWJsZVxuICAgIGlmIChpc0RvbVZpc2liaWxpdHlSZWYuY3VycmVudCA9PT0gJ3Zpc2libGUnICYmICFjaGVja1BhZ2VVbnN1cHBvcnRlZChsb2NhdGlvbi5ocmVmKSkge1xuICAgICAgLy8gY2hlY2tCcm93c2VyQXJjKCk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIH07XG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0UnVudGltZSgnZXh0ZW5zaW9uLWNzdWknKTtcbiAgICBpbml0TWVzc2FnZUxpc3RlbmVyKCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gPD48Lz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG4iLCIvKipcbiAqIERldmVsb3BtZW50IGxvZ2dlciB0aGF0IG9ubHkgb3V0cHV0cyBsb2dzIGluIGRldmVsb3BtZW50IG1vZGVcbiAqIFRoaXMgcHJldmVudHMgY29uc29sZSBzcGFtIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEF1dG8tZGV0ZWN0cyBkZXZlbG9wbWVudCBtb2RlIHZpYSBtdWx0aXBsZSBtZXRob2RzXG4gKiAtIDEwLWNsaWNrIGRlYnVnIG1vZGUgdG9nZ2xlIChjbGljayBzcGhlcmUgbG9nbyAxMCB0aW1lcylcbiAqIC0gU2FmZSBmYWxsYmFja3MgZm9yIGV4dGVuc2lvbiBlbnZpcm9ubWVudCBsaW1pdGF0aW9uc1xuICpcbiAqIFVzYWdlOlxuICogLSBsb2dnZXIuZGVidWcoJ21lc3NhZ2UnKSAtIE9ubHkgc2hvd3MgaW4gZGVidWcgbW9kZVxuICogLSBsb2dnZXIuaGFuZGxlRGVidWdDbGljaygpIC0gQ2FsbCBmcm9tIFVJIHRvIGVuYWJsZS9kaXNhYmxlIGRlYnVnIG1vZGVcbiAqL1xuXG5jbGFzcyBEZXZMb2dnZXIge1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQUklWQVRFIFBST1BFUlRJRVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgcHJpdmF0ZSBpc0RldmVsb3BtZW50OiBib29sZWFuO1xuXG4gIC8vIERlYnVnIGNsaWNrIGFjdGl2YXRpb24gc3RhdGVcbiAgcHJpdmF0ZSBkZWJ1Z0NsaWNrQ291bnQgPSAwO1xuICBwcml2YXRlIGxhc3RDbGlja1RpbWUgPSAwO1xuICBwcml2YXRlIGNsaWNrVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBDT05TVFJVQ1RPUiAmIElOSVRJQUxJWkFUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaXNEZXZlbG9wbWVudCA9IHRoaXMuY2hlY2tEZXZlbG9wbWVudE1vZGUoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMb2dnZXIoKTtcbiAgICB0aGlzLnNldHVwU3RvcmFnZUxpc3RlbmVyKCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVMb2dnZXIoKSB7XG4gICAgLy8gT25seSBzaG93IGluaXRpYWxpemF0aW9uIGxvZyB3aGVuIGRlYnVnIG1vZGUgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLmlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFtSZWZseSBMb2dnZXJdIERlYnVnIG1vZGU6IE9OIOKchScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBTdG9yYWdlTGlzdGVuZXIoKSB7XG4gICAgLy8gTGlzdGVuIGZvciBzdG9yYWdlIGNoYW5nZXMgdG8gdXBkYXRlIGRlYnVnIG1vZGUgZHluYW1pY2FsbHlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSAncmVmbHlkZWJ1ZycpIHtcbiAgICAgICAgICBjb25zdCB3YXNFbmFibGVkID0gdGhpcy5pc0RldmVsb3BtZW50O1xuICAgICAgICAgIHRoaXMuaXNEZXZlbG9wbWVudCA9IHRoaXMuY2hlY2tEZXZlbG9wbWVudE1vZGUoKTtcblxuICAgICAgICAgIC8vIE9ubHkgbG9nIHdoZW4gZGVidWcgbW9kZSBpcyBlbmFibGVkIChlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIGNoYW5nZSlcbiAgICAgICAgICBpZiAod2FzRW5hYmxlZCB8fCB0aGlzLmlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFtSZWZseSBMb2dnZXJdIERlYnVnIG1vZGU6ICR7dGhpcy5pc0RldmVsb3BtZW50ID8gJ09OIOKchScgOiAnT0ZGIOKdjCd9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQVUJMSUMgTE9HR0lORyBNRVRIT0RTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGxvZyguLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmICh0aGlzLmlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgaW5mbyguLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmICh0aGlzLmlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICB3YXJuKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGVycm9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQVUJMSUMgREVCVUcgU1RBVEUgTUFOQUdFTUVOVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZWZyZXNoRGVidWdTdGF0ZSgpIHtcbiAgICB0aGlzLmlzRGV2ZWxvcG1lbnQgPSB0aGlzLmNoZWNrRGV2ZWxvcG1lbnRNb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXZlbG9wbWVudDtcbiAgfVxuXG4gIHRlc3QoKSB7XG4gICAgLy8gQWx3YXlzIHNob3cgdGVzdCBvdXRwdXQgc2luY2UgaXQncyBleHBsaWNpdGx5IGNhbGxlZFxuICAgIGNvbnNvbGUubG9nKGDwn5SnIFtSZWZseSBMb2dnZXJdIERlYnVnIG1vZGU6ICR7dGhpcy5pc0RldmVsb3BtZW50ID8gJ09OIOKchScgOiAnT0ZGIOKdjCd9YCk7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXZlbG9wbWVudDtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERFQlVHIENMSUNLIEFDVElWQVRJT04gKDEwIENMSUNLUylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaGFuZGxlRGVidWdDbGljayhzaG93TWVzc2FnZT86IChjb250ZW50OiBzdHJpbmcsIHR5cGU/OiAnaW5mbycgfCAnc3VjY2VzcycpID0+IHZvaWQpIHtcbiAgICB0aGlzLnVwZGF0ZUNsaWNrQ291bnQoKTtcbiAgICB0aGlzLnJlc2V0Q2xpY2tDb3VudGVyQWZ0ZXJEZWxheSgpO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkU2hvd0hpbnRzKCkpIHtcbiAgICAgIHRoaXMuc2hvd0FjdGl2YXRpb25IaW50cyhzaG93TWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFRvZ2dsZURlYnVnTW9kZSgpKSB7XG4gICAgICB0aGlzLnRvZ2dsZURlYnVnTW9kZShzaG93TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVidWdDbGlja0NvdW50O1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDbGlja0NvdW50KCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlTGFzdENsaWNrID0gbm93IC0gdGhpcy5sYXN0Q2xpY2tUaW1lO1xuXG4gICAgLy8gUmVzZXQgY291bnRlciBpZiBtb3JlIHRoYW4gMyBzZWNvbmRzIGJldHdlZW4gY2xpY2tzXG4gICAgaWYgKHRpbWVTaW5jZUxhc3RDbGljayA+IDMwMDApIHtcbiAgICAgIHRoaXMuZGVidWdDbGlja0NvdW50ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1Z0NsaWNrQ291bnQgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDbGlja1RpbWUgPSBub3c7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0Q2xpY2tDb3VudGVyQWZ0ZXJEZWxheSgpIHtcbiAgICAvLyBDbGVhciBleGlzdGluZyB0aW1lb3V0XG4gICAgaWYgKHRoaXMuY2xpY2tUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGNvdW50ZXIgYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHlcbiAgICB0aGlzLmNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1Z0NsaWNrQ291bnQgPSAwO1xuICAgIH0sIDUwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRTaG93SGludHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGVidWdDbGlja0NvdW50ID09PSA4IHx8IHRoaXMuZGVidWdDbGlja0NvdW50ID09PSA5O1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRUb2dnbGVEZWJ1Z01vZGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGVidWdDbGlja0NvdW50ID49IDEwO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG93QWN0aXZhdGlvbkhpbnRzKHNob3dNZXNzYWdlPzogKGNvbnRlbnQ6IHN0cmluZywgdHlwZT86ICdpbmZvJyB8ICdzdWNjZXNzJykgPT4gdm9pZCkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0NsaWNrcyA9IDEwIC0gdGhpcy5kZWJ1Z0NsaWNrQ291bnQ7XG4gICAgc2hvd01lc3NhZ2U/LihcbiAgICAgIGDwn5SnIERlYnVnIG1vZGUgYWN0aXZhdGlvbjogJHtyZW1haW5pbmdDbGlja3N9IG1vcmUgY2xpY2ske3JlbWFpbmluZ0NsaWNrcyA+IDEgPyAncycgOiAnJ30gbmVlZGVkYCxcbiAgICAgICdpbmZvJyxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB0b2dnbGVEZWJ1Z01vZGUoc2hvd01lc3NhZ2U/OiAoY29udGVudDogc3RyaW5nLCB0eXBlPzogJ2luZm8nIHwgJ3N1Y2Nlc3MnKSA9PiB2b2lkKSB7XG4gICAgY29uc3QgaXNDdXJyZW50bHlFbmFibGVkID0gdGhpcy5yZWZyZXNoRGVidWdTdGF0ZSgpO1xuXG4gICAgaWYgKGlzQ3VycmVudGx5RW5hYmxlZCkge1xuICAgICAgdGhpcy5kZWFjdGl2YXRlRGVidWdNb2RlKHNob3dNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY3RpdmF0ZURlYnVnTW9kZShzaG93TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWJ1Z0NsaWNrQ291bnQgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBhY3RpdmF0ZURlYnVnTW9kZShzaG93TWVzc2FnZT86IChjb250ZW50OiBzdHJpbmcsIHR5cGU/OiAnaW5mbycgfCAnc3VjY2VzcycpID0+IHZvaWQpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZmx5ZGVidWcnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5yZWZyZXNoRGVidWdTdGF0ZSgpO1xuICAgICAgc2hvd01lc3NhZ2U/Lign8J+OiSBEZWJ1ZyBtb2RlIGFjdGl2YXRlZCEgQ2hlY2sgY29uc29sZSBmb3IgbG9ncy4nLCAnc3VjY2VzcycpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAvLyBGYWxsYmFjayBtZXRob2QgZm9yIHR1cm5pbmcgb25cbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmbHktZGVidWcnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5yZWZyZXNoRGVidWdTdGF0ZSgpO1xuICAgICAgc2hvd01lc3NhZ2U/LihcbiAgICAgICAgJ/CfjokgRGVidWcgbW9kZSBhY3RpdmF0ZWQgKGZhbGxiYWNrIG1ldGhvZCkhIENoZWNrIGNvbnNvbGUgZm9yIGxvZ3MuJyxcbiAgICAgICAgJ3N1Y2Nlc3MnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlYWN0aXZhdGVEZWJ1Z01vZGUoc2hvd01lc3NhZ2U/OiAoY29udGVudDogc3RyaW5nLCB0eXBlPzogJ2luZm8nIHwgJ3N1Y2Nlc3MnKSA9PiB2b2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZseWRlYnVnJyk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXJlZmx5LWRlYnVnJyk7XG4gICAgICB0aGlzLnJlZnJlc2hEZWJ1Z1N0YXRlKCk7XG4gICAgICBzaG93TWVzc2FnZT8uKCfwn5S0IERlYnVnIG1vZGUgZGVhY3RpdmF0ZWQhIENvbnNvbGUgbG9ncyBkaXNhYmxlZC4nLCAnc3VjY2VzcycpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAvLyBGYWxsYmFjayBtZXRob2QgZm9yIHR1cm5pbmcgb2ZmXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXJlZmx5LWRlYnVnJyk7XG4gICAgICB0aGlzLnJlZnJlc2hEZWJ1Z1N0YXRlKCk7XG4gICAgICBzaG93TWVzc2FnZT8uKFxuICAgICAgICAn8J+UtCBEZWJ1ZyBtb2RlIGRlYWN0aXZhdGVkIChmYWxsYmFjayBtZXRob2QpISBDb25zb2xlIGxvZ3MgZGlzYWJsZWQuJyxcbiAgICAgICAgJ3N1Y2Nlc3MnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQUklWQVRFIERFQlVHIE1PREUgREVURUNUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHByaXZhdGUgY2hlY2tEZXZlbG9wbWVudE1vZGUoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbFN0b3JhZ2VGbGFnKCkgfHxcbiAgICAgICAgdGhpcy5jaGVja0RvY3VtZW50QXR0cmlidXRlKCkgfHxcbiAgICAgICAgdGhpcy5jaGVja0J1aWxkRW52aXJvbm1lbnQoKSB8fFxuICAgICAgICB0aGlzLmNoZWNrUHJvY2Vzc0Vudmlyb25tZW50KCkgfHxcbiAgICAgICAgdGhpcy5jaGVja1VybFBhcmFtZXRlcigpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAvLyBJZiBhbnkgY2hlY2sgZmFpbHMsIGRlZmF1bHQgdG8gcHJvZHVjdGlvbiBtb2RlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0xvY2FsU3RvcmFnZUZsYWcoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZmx5ZGVidWcnKSA9PT0gJ3RydWUnO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9zdG9yYWdlRXJyb3IpIHtcbiAgICAgIC8vIFNpbGVudCBmYWxsYmFjayB0byBhbHRlcm5hdGl2ZXNcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0RvY3VtZW50QXR0cmlidXRlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmbHktZGVidWcnKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrQnVpbGRFbnZpcm9ubWVudCgpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlIC0gVml0ZSByZXBsYWNlcyB0aGlzIGF0IGJ1aWxkIHRpbWVcbiAgICByZXR1cm4gdHlwZW9mIGltcG9ydC5tZXRhICE9PSAndW5kZWZpbmVkJyAmJiBpbXBvcnQubWV0YS5lbnY/LkRFViA9PT0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tQcm9jZXNzRW52aXJvbm1lbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudj8uTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVXJsUGFyYW1ldGVyKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICByZXR1cm4gdXJsUGFyYW1zLmdldCgncmVmbHlfZGVidWcnKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEVYUE9SVCBTSU5HTEVUT04gSU5TVEFOQ0Vcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IERldkxvZ2dlcigpO1xuIiwiaW1wb3J0IHsgZGVmaW5lQ29udGVudFNjcmlwdCB9IGZyb20gJ3d4dC9zYW5kYm94JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20vY2xpZW50JztcblxuaW1wb3J0IHsgc2V0UnVudGltZSB9IGZyb20gJ0ByZWZseS91dGlscy9lbnYnO1xuaW1wb3J0IHsgY3JlYXRlU2hhZG93Um9vdFVpIH0gZnJvbSAnd3h0L2NsaWVudCc7XG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29udGVudFNjcmlwdCh7XG4gIG1hdGNoZXM6IFsnPGFsbF91cmxzPiddLFxuICAvLyAyLiBTZXQgY3NzSW5qZWN0aW9uTW9kZVxuICBjc3NJbmplY3Rpb25Nb2RlOiAndWknLFxuICBleGNsdWRlTWF0Y2hlczogW1xuICAgICdodHRwczovL3JlZmx5LmFpLyonLFxuICAgICdodHRwczovL2FwaS5yZWZseS5haS8qJyxcbiAgICAnaHR0cHM6Ly93d3cucmVmbHkuYWkvKicsXG4gICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6NTE3My8qJyxcbiAgXSxcblxuICBhc3luYyBtYWluKGN0eCkge1xuICAgIHNldFJ1bnRpbWUoJ2V4dGVuc2lvbi1jc3VpJyk7XG5cbiAgICBsb2dnZXIuZGVidWcoJ3V0aWxzLWNzdWkgY3R4JywgY3R4KTtcbiAgICAvLyAzLiBEZWZpbmUgeW91ciBVSWBcbiAgICBjb25zdCB1aSA9IGF3YWl0IGNyZWF0ZVNoYWRvd1Jvb3RVaShjdHgsIHtcbiAgICAgIG5hbWU6ICdyZWZseS11dGlscy1hcHAnLFxuICAgICAgcG9zaXRpb246ICdpbmxpbmUnLFxuICAgICAgYXBwZW5kOiAnYmVmb3JlJyxcbiAgICAgIG9uTW91bnQoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBSZWFjdERPTS5jcmVhdGVSb290KGNvbnRhaW5lcik7XG4gICAgICAgIHJvb3QucmVuZGVyKDxBcHAgLz4pO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH0sXG4gICAgICBvblJlbW92ZTogKHJvb3QpID0+IHtcbiAgICAgICAgcm9vdD8udW5tb3VudCgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIC8vIDQuIE1vdW50IHRoZSBVSVxuICAgIHVpLm1vdW50KCk7XG4gIH0sXG59KTtcbiJdLCJuYW1lcyI6WyJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsIlJlYWN0VmVyc2lvbiIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImN1cnJlbnQiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyIsInRyYW5zaXRpb24iLCJSZWFjdEN1cnJlbnRBY3RRdWV1ZSIsImlzQmF0Y2hpbmdMZWdhY3kiLCJkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImN1cnJlbnRFeHRyYVN0YWNrRnJhbWUiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJzdGFjayIsImdldEN1cnJlbnRTdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJpbXBsIiwiZW5hYmxlU2NvcGVBUEkiLCJlbmFibGVDYWNoZUVsZW1lbnQiLCJlbmFibGVUcmFuc2l0aW9uVHJhY2luZyIsImVuYWJsZUxlZ2FjeUhpZGRlbiIsImVuYWJsZURlYnVnVHJhY2luZyIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJfY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjYWxsYmFjayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiYXNzaWduIiwiT2JqZWN0IiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJDb21wb25lbnQiLCJwcm9wcyIsImNvbnRleHQiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidW5kZWZpbmVkIiwiZm5OYW1lIiwiaGFzT3duUHJvcGVydHkiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjcmVhdGVSZWYiLCJyZWZPYmplY3QiLCJzZWFsIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsInR5cGVOYW1lIiwidmFsdWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidHlwZSIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCIkJHR5cGVvZiIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsIlJFU0VSVkVEX1BST1BTIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzdGF0ZU5vZGUiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwic291cmNlIiwib3duZXIiLCJlbGVtZW50IiwiX293bmVyIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkcmVuIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJpIiwiZGVmYXVsdFByb3BzIiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJfc2VsZiIsIl9zb3VyY2UiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJyZXBsYWNlIiwibWF0Y2giLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwiZ2V0RWxlbWVudEtleSIsImluZGV4IiwidG9TdHJpbmciLCJtYXBJbnRvQXJyYXkiLCJhcnJheSIsImVzY2FwZWRQcmVmaXgiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsIl9jaGlsZCIsIm1hcHBlZENoaWxkIiwiY2hpbGRLZXkiLCJlc2NhcGVkQ2hpbGRLZXkiLCJjIiwicHVzaCIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJpdGVyYWJsZUNoaWxkcmVuIiwiZW50cmllcyIsInN0ZXAiLCJpaSIsIm5leHQiLCJkb25lIiwiY2hpbGRyZW5TdHJpbmciLCJrZXlzIiwiam9pbiIsIm1hcENoaWxkcmVuIiwiZnVuYyIsInJlc3VsdCIsImNvdW50IiwiY291bnRDaGlsZHJlbiIsIm4iLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsImZvckVhY2hDb250ZXh0IiwidG9BcnJheSIsIm9ubHlDaGlsZCIsImNyZWF0ZUNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRWYWx1ZTIiLCJfdGhyZWFkQ291bnQiLCJQcm92aWRlciIsIkNvbnN1bWVyIiwiX2RlZmF1bHRWYWx1ZSIsIl9nbG9iYWxOYW1lIiwiaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciIsImhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyIiwiZGVmaW5lUHJvcGVydGllcyIsInNldCIsIl9Qcm92aWRlciIsIl9jdXJyZW50UmVuZGVyZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsIlVuaW5pdGlhbGl6ZWQiLCJQZW5kaW5nIiwiUmVzb2x2ZWQiLCJSZWplY3RlZCIsImxhenlJbml0aWFsaXplciIsIl9zdGF0dXMiLCJjdG9yIiwiX3Jlc3VsdCIsInRoZW5hYmxlIiwidGhlbiIsIm1vZHVsZU9iamVjdCIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJwZW5kaW5nIiwiZGVmYXVsdCIsImxhenkiLCJsYXp5VHlwZSIsInByb3BUeXBlcyIsIm5ld0RlZmF1bHRQcm9wcyIsIm5ld1Byb3BUeXBlcyIsImZvcndhcmRSZWYiLCJlbGVtZW50VHlwZSIsIm93bk5hbWUiLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0TW9kdWxlSWQiLCJtZW1vIiwiY29tcGFyZSIsInJlc29sdmVEaXNwYXRjaGVyIiwiZGlzcGF0Y2hlciIsInVzZUNvbnRleHQiLCJDb250ZXh0IiwicmVhbENvbnRleHQiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZUVmZmVjdCIsImNyZWF0ZSIsImRlcHMiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlRGVidWdWYWx1ZSIsImZvcm1hdHRlckZuIiwidXNlVHJhbnNpdGlvbiIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VJZCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm93bmVyRm4iLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiRmFrZSIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsIl9mcmFtZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJoYXMiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInN0YXJ0VHJhbnNpdGlvbiIsInNjb3BlIiwib3B0aW9ucyIsInByZXZUcmFuc2l0aW9uIiwiY3VycmVudFRyYW5zaXRpb24iLCJfdXBkYXRlZEZpYmVycyIsIlNldCIsInVwZGF0ZWRGaWJlcnNDb3VudCIsInNpemUiLCJjbGVhciIsImRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsIiwiZW5xdWV1ZVRhc2tJbXBsIiwiZW5xdWV1ZVRhc2siLCJ0YXNrIiwicmVxdWlyZVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsIm5vZGVSZXF1aXJlIiwibW9kdWxlIiwic2V0SW1tZWRpYXRlIiwiX2VyciIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImFjdFNjb3BlRGVwdGgiLCJkaWRXYXJuTm9Bd2FpdEFjdCIsImFjdCIsInByZXZBY3RTY29wZURlcHRoIiwicHJldklzQmF0Y2hpbmdMZWdhY3kiLCJxdWV1ZSIsImZsdXNoQWN0UXVldWUiLCJwb3BBY3RTY29wZSIsInRoZW5hYmxlUmVzdWx0Iiwid2FzQXdhaXRlZCIsInJlc29sdmUiLCJyZWplY3QiLCJyZXR1cm5WYWx1ZSIsInJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsiLCJQcm9taXNlIiwiX3F1ZXVlIiwiX3RoZW5hYmxlIiwiX3RoZW5hYmxlMiIsImlzRmx1c2hpbmciLCJjcmVhdGVFbGVtZW50JDEiLCJjbG9uZUVsZW1lbnQkMSIsImNyZWF0ZUZhY3RvcnkiLCJDaGlsZHJlbiIsImZvckVhY2giLCJvbmx5IiwiZXhwb3J0cyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIiwicmVxdWlyZSIsIlJlYWN0IiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJqc3hERVYiLCJtYXliZUtleSIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJkaWRXYXJuQWJvdXRLZXlTcHJlYWQiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImFmdGVyRXhhbXBsZSIsImpzeERFViQxIiwiZGVmaW5lQ29udGVudFNjcmlwdCIsImRlZmluaXRpb24iLCJlbmFibGVQcm9maWxpbmciLCJmcmFtZVlpZWxkTXMiLCJoZWFwIiwic2lmdFVwIiwicGVlayIsInBvcCIsImZpcnN0IiwibGFzdCIsInNpZnREb3duIiwicGFyZW50SW5kZXgiLCJwYXJlbnQiLCJoYWxmTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdCIsInJpZ2h0SW5kZXgiLCJyaWdodCIsImIiLCJkaWZmIiwic29ydEluZGV4IiwiaWQiLCJJbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJMb3dQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsIm1hcmtUYXNrRXJyb3JlZCIsIm1zIiwiaGFzUGVyZm9ybWFuY2VOb3ciLCJwZXJmb3JtYW5jZSIsIm5vdyIsImxvY2FsUGVyZm9ybWFuY2UiLCJsb2NhbERhdGUiLCJEYXRlIiwiaW5pdGlhbFRpbWUiLCJtYXhTaWduZWQzMUJpdEludCIsIklNTUVESUFURV9QUklPUklUWV9USU1FT1VUIiwiVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUIiwiTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQiLCJMT1dfUFJJT1JJVFlfVElNRU9VVCIsIklETEVfUFJJT1JJVFlfVElNRU9VVCIsInRhc2tRdWV1ZSIsInRpbWVyUXVldWUiLCJ0YXNrSWRDb3VudGVyIiwiY3VycmVudFRhc2siLCJjdXJyZW50UHJpb3JpdHlMZXZlbCIsImlzUGVyZm9ybWluZ1dvcmsiLCJpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCIsImlzSG9zdFRpbWVvdXRTY2hlZHVsZWQiLCJsb2NhbFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibG9jYWxDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJsb2NhbFNldEltbWVkaWF0ZSIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJpc0lucHV0UGVuZGluZyIsImFkdmFuY2VUaW1lcnMiLCJjdXJyZW50VGltZSIsInRpbWVyIiwic3RhcnRUaW1lIiwiZXhwaXJhdGlvblRpbWUiLCJoYW5kbGVUaW1lb3V0IiwicmVxdWVzdEhvc3RDYWxsYmFjayIsImZsdXNoV29yayIsImZpcnN0VGltZXIiLCJyZXF1ZXN0SG9zdFRpbWVvdXQiLCJoYXNUaW1lUmVtYWluaW5nIiwiY2FuY2VsSG9zdFRpbWVvdXQiLCJwcmV2aW91c1ByaW9yaXR5TGV2ZWwiLCJ3b3JrTG9vcCIsInNob3VsZFlpZWxkVG9Ib3N0IiwicHJpb3JpdHlMZXZlbCIsImRpZFVzZXJDYWxsYmFja1RpbWVvdXQiLCJjb250aW51YXRpb25DYWxsYmFjayIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSIsImV2ZW50SGFuZGxlciIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsImRlbGF5IiwidGltZW91dCIsIm5ld1Rhc2siLCJ1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uIiwidW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUiLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNNZXNzYWdlTG9vcFJ1bm5pbmciLCJzY2hlZHVsZWRIb3N0Q2FsbGJhY2siLCJ0YXNrVGltZW91dElEIiwiZnJhbWVJbnRlcnZhbCIsInRpbWVFbGFwc2VkIiwicmVxdWVzdFBhaW50IiwiZm9yY2VGcmFtZVJhdGUiLCJmcHMiLCJmbG9vciIsInBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSIsImhhc01vcmVXb3JrIiwic2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUiLCJwb3J0IiwidW5zdGFibGVfcmVxdWVzdFBhaW50IiwidW5zdGFibGVfUHJvZmlsaW5nIiwiU2NoZWR1bGVyIiwic3VwcHJlc3NXYXJuaW5nIiwic2V0U3VwcHJlc3NXYXJuaW5nIiwibmV3U3VwcHJlc3NXYXJuaW5nIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiUHJvZmlsZXIiLCJTdXNwZW5zZUNvbXBvbmVudCIsIk1lbW9Db21wb25lbnQiLCJTaW1wbGVNZW1vQ29tcG9uZW50IiwiTGF6eUNvbXBvbmVudCIsIkluY29tcGxldGVDbGFzc0NvbXBvbmVudCIsIkRlaHlkcmF0ZWRGcmFnbWVudCIsIlN1c3BlbnNlTGlzdENvbXBvbmVudCIsIlNjb3BlQ29tcG9uZW50IiwiT2Zmc2NyZWVuQ29tcG9uZW50IiwiTGVnYWN5SGlkZGVuQ29tcG9uZW50IiwiQ2FjaGVDb21wb25lbnQiLCJUcmFjaW5nTWFya2VyQ29tcG9uZW50IiwiZW5hYmxlQ2xpZW50UmVuZGVyRmFsbGJhY2tPblRleHRNaXNtYXRjaCIsImVuYWJsZU5ld1JlY29uY2lsZXIiLCJlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uIiwiZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsImFsbE5hdGl2ZUV2ZW50cyIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0ZXJUd29QaGFzZUV2ZW50IiwicmVnaXN0cmF0aW9uTmFtZSIsImRlcGVuZGVuY2llcyIsInJlZ2lzdGVyRGlyZWN0RXZlbnQiLCJsb3dlckNhc2VkTmFtZSIsInRvTG93ZXJDYXNlIiwib25kYmxjbGljayIsImFkZCIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja1Byb3BTdHJpbmdDb2VyY2lvbiIsImNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbiIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uIiwiUkVTRVJWRUQiLCJTVFJJTkciLCJCT09MRUFOSVNIX1NUUklORyIsIkJPT0xFQU4iLCJPVkVSTE9BREVEX0JPT0xFQU4iLCJOVU1FUklDIiwiUE9TSVRJVkVfTlVNRVJJQyIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJzaG91bGRJZ25vcmVBdHRyaWJ1dGUiLCJwcm9wZXJ0eUluZm8iLCJpc0N1c3RvbUNvbXBvbmVudFRhZyIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nIiwiYWNjZXB0c0Jvb2xlYW5zIiwic2hvdWxkUmVtb3ZlQXR0cmlidXRlIiwiaXNOYU4iLCJnZXRQcm9wZXJ0eUluZm8iLCJwcm9wZXJ0aWVzIiwiUHJvcGVydHlJbmZvUmVjb3JkIiwibXVzdFVzZVByb3BlcnR5IiwiYXR0cmlidXRlTmFtZXNwYWNlIiwic2FuaXRpemVVUkwiLCJyZW1vdmVFbXB0eVN0cmluZyIsInByb3BlcnR5TmFtZSIsInJlc2VydmVkUHJvcHMiLCJfcmVmIiwiQ0FNRUxJWkUiLCJjYXBpdGFsaXplIiwidG9rZW4iLCJ0b1VwcGVyQ2FzZSIsInhsaW5rSHJlZiIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInVybCIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRWYWx1ZUZvclByb3BlcnR5IiwiZXhwZWN0ZWQiLCJzdHJpbmdWYWx1ZSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImdldFZhbHVlRm9yQXR0cmlidXRlIiwic2V0VmFsdWVGb3JQcm9wZXJ0eSIsIl9hdHRyaWJ1dGVOYW1lIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX3R5cGUiLCJhdHRyaWJ1dGVWYWx1ZSIsInNldEF0dHJpYnV0ZU5TIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIlJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJkZXNjcmliZUZpYmVyIiwiZmliZXIiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIndvcmtJblByb2dyZXNzIiwicmV0dXJuIiwiZ2V0V3JhcHBlZE5hbWUkMSIsImdldENvbnRleHROYW1lJDEiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiaXNSZW5kZXJpbmciLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCIsImdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYiLCJyZXNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRGaWJlciIsImdldEN1cnJlbnRGaWJlciIsInNldElzUmVuZGVyaW5nIiwicmVuZGVyaW5nIiwiZ2V0VG9TdHJpbmdWYWx1ZSIsImhhc1JlYWRPbmx5VmFsdWUiLCJidXR0b24iLCJjaGVja2JveCIsImltYWdlIiwiaGlkZGVuIiwicmFkaW8iLCJyZXNldCIsInN1Ym1pdCIsImNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMiLCJ0YWdOYW1lIiwib25DaGFuZ2UiLCJvbklucHV0IiwicmVhZE9ubHkiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJpc0NoZWNrYWJsZSIsImVsZW0iLCJub2RlTmFtZSIsImdldFRyYWNrZXIiLCJfdmFsdWVUcmFja2VyIiwiZGV0YWNoVHJhY2tlciIsImdldFZhbHVlRnJvbU5vZGUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJjdXJyZW50VmFsdWUiLCJ0cmFja2VyIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsInN0b3BUcmFja2luZyIsInRyYWNrIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJsYXN0VmFsdWUiLCJuZXh0VmFsdWUiLCJnZXRBY3RpdmVFbGVtZW50IiwiZG9jIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldEhvc3RQcm9wcyIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiX3dyYXBwZXJTdGF0ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdFdyYXBwZXJTdGF0ZSIsImNvbnRyb2xsZWQiLCJ1cGRhdGVDaGVja2VkIiwidXBkYXRlV3JhcHBlciIsInNldERlZmF1bHRWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIiLCJpc0h5ZHJhdGluZyIsImlzQnV0dG9uIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwicGFyZW50Tm9kZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJmb3JtIiwib3RoZXJQcm9wcyIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJvd25lckRvY3VtZW50IiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuSW52YWxpZENoaWxkIiwiZGlkV2FybkludmFsaWRJbm5lckhUTUwiLCJ2YWxpZGF0ZVByb3BzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJzZWxlY3RlZCIsInBvc3RNb3VudFdyYXBwZXIkMSIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIiwib3duZXJOYW1lIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInByb3BOYW1lSXNBcnJheSIsIm11bHRpcGxlIiwidXBkYXRlT3B0aW9ucyIsInByb3BWYWx1ZSIsInNldERlZmF1bHRTZWxlY3RlZCIsInNlbGVjdGVkVmFsdWVzIiwic2VsZWN0ZWRWYWx1ZSIsIl9pIiwiZGVmYXVsdFNlbGVjdGVkIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMSIsImluaXRXcmFwcGVyU3RhdGUkMSIsIndhc011bHRpcGxlIiwicG9zdE1vdW50V3JhcHBlciQyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImdldEhvc3RQcm9wcyQyIiwiaW5pdFdyYXBwZXJTdGF0ZSQyIiwidXBkYXRlV3JhcHBlciQxIiwibmV3VmFsdWUiLCJwb3N0TW91bnRXcmFwcGVyJDMiLCJ0ZXh0Q29udGVudCIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMiIsIkhUTUxfTkFNRVNQQUNFIiwiTUFUSF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJwYXJlbnROYW1lc3BhY2UiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsImh0bWwiLCJuYW1lc3BhY2VVUkkiLCJpbm5lckhUTUwiLCJ2YWx1ZU9mIiwic3ZnTm9kZSIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiRUxFTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwiQ09NTUVOVF9OT0RFIiwiRE9DVU1FTlRfTk9ERSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJzZXRUZXh0Q29udGVudCIsImxhc3RDaGlsZCIsIm5vZGVUeXBlIiwibm9kZVZhbHVlIiwic2hvcnRoYW5kVG9Mb25naGFuZCIsImFuaW1hdGlvbiIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJib3JkZXIiLCJib3JkZXJCbG9ja0VuZCIsImJvcmRlckJsb2NrU3RhcnQiLCJib3JkZXJCb3R0b20iLCJib3JkZXJDb2xvciIsImJvcmRlckltYWdlIiwiYm9yZGVySW5saW5lRW5kIiwiYm9yZGVySW5saW5lU3RhcnQiLCJib3JkZXJMZWZ0IiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJTdHlsZSIsImJvcmRlclRvcCIsImJvcmRlcldpZHRoIiwiY29sdW1uUnVsZSIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEZsb3ciLCJmb250IiwiZm9udFZhcmlhbnQiLCJnYXAiLCJncmlkIiwiZ3JpZEFyZWEiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkdhcCIsImdyaWRHYXAiLCJncmlkUm93IiwiZ3JpZFJvd0dhcCIsImdyaWRUZW1wbGF0ZSIsImxpc3RTdHlsZSIsIm1hcmdpbiIsIm1hcmtlciIsIm1hc2siLCJtYXNrUG9zaXRpb24iLCJvdXRsaW5lIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwicGxhY2VDb250ZW50IiwicGxhY2VJdGVtcyIsInBsYWNlU2VsZiIsInRleHREZWNvcmF0aW9uIiwidGV4dEVtcGhhc2lzIiwid29yZFdyYXAiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhc3BlY3RSYXRpbyIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsImNoYXJBdCIsInN1YnN0cmluZyIsInByZWZpeGVzIiwicHJvcCIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNFbXB0eSIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsIm1zUGF0dGVybiQxIiwiaHlwaGVuUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5lZEZvck5hTlZhbHVlIiwid2FybmVkRm9ySW5maW5pdHlWYWx1ZSIsImNhbWVsaXplIiwic3RyaW5nIiwiXyIsImNoYXJhY3RlciIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSIsImluZGV4T2YiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImlzVmFsdWVFbXB0eSIsImV4cGFuZFNob3J0aGFuZE1hcCIsImV4cGFuZGVkIiwibG9uZ2hhbmRzIiwidmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2Iiwic3R5bGVVcGRhdGVzIiwibmV4dFN0eWxlcyIsImV4cGFuZGVkVXBkYXRlcyIsImV4cGFuZGVkU3R5bGVzIiwid2FybmVkQWJvdXQiLCJvcmlnaW5hbEtleSIsImNvcnJlY3RPcmlnaW5hbEtleSIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImlucHV0Iiwia2V5Z2VuIiwibGluayIsIm1ldGEiLCJwYXJhbSIsIndiciIsInZvaWRFbGVtZW50VGFncyIsIm1lbnVpdGVtIiwiSFRNTCIsImFzc2VydFZhbGlkUHJvcHMiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJjb250ZW50RWRpdGFibGUiLCJpc0N1c3RvbUNvbXBvbmVudCIsImlzIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFjdGlvbiIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXN5bmMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNhcHR1cmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnQiLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGVmZXIiLCJkaXIiLCJkaXNhYmxlcGljdHVyZWlucGljdHVyZSIsImRpc2FibGVyZW1vdGVwbGF5YmFjayIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jdHlwZSIsImVudGVya2V5aGludCIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpbWFnZXNpemVzIiwiaW1hZ2VzcmNzZXQiLCJpbm5lcmh0bWwiLCJpbnB1dG1vZGUiLCJpbnRlZ3JpdHkiLCJpdGVtaWQiLCJpdGVtcHJvcCIsIml0ZW1yZWYiLCJpdGVtc2NvcGUiLCJpdGVtdHlwZSIsImtleXBhcmFtcyIsImtleXR5cGUiLCJraW5kIiwibGFiZWwiLCJsYW5nIiwibGlzdCIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbndpZHRoIiwibWFyZ2luaGVpZ2h0IiwibWF4IiwibWF4bGVuZ3RoIiwibWVkaWEiLCJtZWRpYWdyb3VwIiwibWV0aG9kIiwibWluIiwibWlubGVuZ3RoIiwibXV0ZWQiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93c3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNoYXBlIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVybGluZXBvc2l0aW9uIiwib3ZlcmxpbmV0aGlja25lc3MiLCJwYWludG9yZGVyIiwicGFub3NlMSIsInBhdGhsZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSIsInBhdHRlcm51bml0cyIsInBvaW50ZXJldmVudHMiLCJwb2ludHMiLCJwb2ludHNhdHgiLCJwb2ludHNhdHkiLCJwb2ludHNhdHoiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwicHJvcGVydHkiLCJyIiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidG8iLCJ0cmFuc2Zvcm0iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieSIsInljaGFubmVsc2VsZWN0b3IiLCJ6Iiwiem9vbWFuZHBhbiIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJ2YWxpZGF0ZVByb3BlcnR5JDEiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJFVkVOVF9OQU1FX1JFR0VYIiwiSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYIiwickFSSUEkMSIsInJBUklBQ2FtZWwkMSIsImV2ZW50UmVnaXN0cnkiLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSIsIklTX05PTl9ERUxFR0FURUQiLCJJU19DQVBUVVJFX1BIQVNFIiwiU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMiLCJjdXJyZW50UmVwbGF5aW5nRXZlbnQiLCJzZXRSZXBsYXlpbmdFdmVudCIsImV2ZW50IiwicmVzZXRSZXBsYXlpbmdFdmVudCIsImlzUmVwbGF5aW5nRXZlbnQiLCJnZXRFdmVudFRhcmdldCIsIm5hdGl2ZUV2ZW50Iiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwicmVzdG9yZUltcGwiLCJyZXN0b3JlVGFyZ2V0IiwicmVzdG9yZVF1ZXVlIiwicmVzdG9yZVN0YXRlT2ZUYXJnZXQiLCJpbnRlcm5hbEluc3RhbmNlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsIl9wcm9wcyIsInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbiIsImVucXVldWVTdGF0ZVJlc3RvcmUiLCJuZWVkc1N0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicXVldWVkVGFyZ2V0cyIsImJhdGNoZWRVcGRhdGVzSW1wbCIsImJvb2trZWVwaW5nIiwiZmx1c2hTeW5jSW1wbCIsImlzSW5zaWRlRXZlbnRIYW5kbGVyIiwiZmluaXNoRXZlbnRIYW5kbGVyIiwiY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMiLCJiYXRjaGVkVXBkYXRlcyIsInNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24iLCJfYmF0Y2hlZFVwZGF0ZXNJbXBsIiwiX2Rpc2NyZXRlVXBkYXRlc0ltcGwiLCJfZmx1c2hTeW5jSW1wbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImdldExpc3RlbmVyIiwiaW5zdCIsImxpc3RlbmVyIiwicGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QiLCJmIiwiZnVuY0FyZ3MiLCJvbkVycm9yIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCIsImRpc3BhdGNoRXZlbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZXZ0IiwiZGlkQ2FsbCIsImRpZEVycm9yIiwid2luZG93RXZlbnQiLCJ3aW5kb3dFdmVudERlc2NyaXB0b3IiLCJyZXN0b3JlQWZ0ZXJEaXNwYXRjaCIsImV2dFR5cGUiLCJjYWxsQ2FsbGJhY2siLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJkZWZhdWx0UHJldmVudGVkIiwiX3N1cHByZXNzTG9nZ2luZyIsImlubmVyIiwiaW5pdEV2ZW50IiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxIiwiaGFzRXJyb3IiLCJjYXVnaHRFcnJvciIsImhhc1JldGhyb3dFcnJvciIsInJldGhyb3dFcnJvciIsInJlcG9ydGVyIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsImhhc0NhdWdodEVycm9yIiwiX3JlYWN0SW50ZXJuYWxzIiwiTm9GbGFncyIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJVcGRhdGUiLCJDaGlsZERlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJEaWRDYXB0dXJlIiwiRm9yY2VDbGllbnRSZW5kZXIiLCJSZWYiLCJTbmFwc2hvdCIsIlBhc3NpdmUiLCJIeWRyYXRpbmciLCJWaXNpYmlsaXR5IiwiU3RvcmVDb25zaXN0ZW5jeSIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsImdldE5lYXJlc3RNb3VudGVkRmliZXIiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyIiwic3VzcGVuc2VTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJkZWh5ZHJhdGVkIiwiZ2V0Q29udGFpbmVyRnJvbUZpYmVyIiwiY29udGFpbmVySW5mbyIsImlzRmliZXJNb3VudGVkIiwiY29tcG9uZW50Iiwib3duZXJGaWJlciIsImluc3RhbmNlIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsIm5leHRQYXJlbnQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsInNjaGVkdWxlQ2FsbGJhY2siLCJjYW5jZWxDYWxsYmFjayIsInNob3VsZFlpZWxkIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwidW5zdGFibGVfeWllbGRWYWx1ZSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwicmVuZGVyZXJJRCIsImluamVjdGVkSG9vayIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJoYXNMb2dnZWRFcnJvciIsImlzRGV2VG9vbHNQcmVzZW50IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiZ2V0TGFuZUxhYmVsTWFwIiwiaW5qZWN0UHJvZmlsaW5nSG9va3MiLCJpbmplY3QiLCJjaGVja0RDRSIsIm9uU2NoZWR1bGVSb290Iiwicm9vdCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJzY2hlZHVsZXJQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJJZGxlRXZlbnRQcmlvcml0eSIsIm9uUG9zdENvbW1pdFJvb3QiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwic2V0U3RyaWN0TW9kZSIsInByb2ZpbGluZ0hvb2tzIiwibGFuZSIsIlRvdGFsTGFuZXMiLCJnZXRMYWJlbEZvckxhbmUiLCJtYXJrQ29tbWl0U3RhcnRlZCIsImxhbmVzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiTm9Nb2RlIiwiQ29uY3VycmVudE1vZGUiLCJQcm9maWxlTW9kZSIsIlN0cmljdExlZ2FjeU1vZGUiLCJTdHJpY3RFZmZlY3RzTW9kZSIsImNsejMyIiwiY2x6MzJGYWxsYmFjayIsIkxOMiIsImFzVWludCIsIk5vTGFuZXMiLCJOb0xhbmUiLCJTeW5jTGFuZSIsIklucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUiLCJJbnB1dENvbnRpbnVvdXNMYW5lIiwiRGVmYXVsdEh5ZHJhdGlvbkxhbmUiLCJEZWZhdWx0TGFuZSIsIlRyYW5zaXRpb25IeWRyYXRpb25MYW5lIiwiVHJhbnNpdGlvbkxhbmVzIiwiVHJhbnNpdGlvbkxhbmUxIiwiVHJhbnNpdGlvbkxhbmUyIiwiVHJhbnNpdGlvbkxhbmUzIiwiVHJhbnNpdGlvbkxhbmU0IiwiVHJhbnNpdGlvbkxhbmU1IiwiVHJhbnNpdGlvbkxhbmU2IiwiVHJhbnNpdGlvbkxhbmU3IiwiVHJhbnNpdGlvbkxhbmU4IiwiVHJhbnNpdGlvbkxhbmU5IiwiVHJhbnNpdGlvbkxhbmUxMCIsIlRyYW5zaXRpb25MYW5lMTEiLCJUcmFuc2l0aW9uTGFuZTEyIiwiVHJhbnNpdGlvbkxhbmUxMyIsIlRyYW5zaXRpb25MYW5lMTQiLCJUcmFuc2l0aW9uTGFuZTE1IiwiVHJhbnNpdGlvbkxhbmUxNiIsIlJldHJ5TGFuZXMiLCJSZXRyeUxhbmUxIiwiUmV0cnlMYW5lMiIsIlJldHJ5TGFuZTMiLCJSZXRyeUxhbmU0IiwiUmV0cnlMYW5lNSIsIlNvbWVSZXRyeUxhbmUiLCJTZWxlY3RpdmVIeWRyYXRpb25MYW5lIiwiTm9uSWRsZUxhbmVzIiwiSWRsZUh5ZHJhdGlvbkxhbmUiLCJJZGxlTGFuZSIsIk9mZnNjcmVlbkxhbmUiLCJOb1RpbWVzdGFtcCIsIm5leHRUcmFuc2l0aW9uTGFuZSIsIm5leHRSZXRyeUxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmUiLCJnZXROZXh0TGFuZXMiLCJ3aXBMYW5lcyIsInBlbmRpbmdMYW5lcyIsIm5leHRMYW5lcyIsInN1c3BlbmRlZExhbmVzIiwicGluZ2VkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwibm9uSWRsZVVuYmxvY2tlZExhbmVzIiwibm9uSWRsZVBpbmdlZExhbmVzIiwidW5ibG9ja2VkTGFuZXMiLCJuZXh0TGFuZSIsIndpcExhbmUiLCJlbnRhbmdsZWRMYW5lcyIsImVudGFuZ2xlbWVudHMiLCJwaWNrQXJiaXRyYXJ5TGFuZUluZGV4IiwiZ2V0TW9zdFJlY2VudEV2ZW50VGltZSIsImV2ZW50VGltZXMiLCJtb3N0UmVjZW50RXZlbnRUaW1lIiwiZXZlbnRUaW1lIiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwibWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZCIsImV4cGlyYXRpb25UaW1lcyIsImV4cGlyZWRMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzIiwiVXJnZW50TGFuZXMiLCJpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyIsImluY2x1ZGVzQmxvY2tpbmdMYW5lIiwiU3luY0RlZmF1bHRMYW5lcyIsImluY2x1ZGVzRXhwaXJlZExhbmUiLCJpc1RyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRSZXRyeUxhbmUiLCJwaWNrQXJiaXRyYXJ5TGFuZSIsImxhbmVUb0luZGV4IiwiaW5jbHVkZXNTb21lTGFuZSIsImlzU3Vic2V0T2ZMYW5lcyIsInN1YnNldCIsIm1lcmdlTGFuZXMiLCJyZW1vdmVMYW5lcyIsImludGVyc2VjdExhbmVzIiwibGFuZVRvTGFuZXMiLCJoaWdoZXJQcmlvcml0eUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFBpbmdlZCIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsIm5vTG9uZ2VyUGVuZGluZ0xhbmVzIiwibXV0YWJsZVJlYWRMYW5lcyIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmVzIiwicmVuZGVyTGFuZSIsImFkZEZpYmVyVG9MYW5lc01hcCIsInBlbmRpbmdVcGRhdGVyc0xhbmVNYXAiLCJ1cGRhdGVycyIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJnZXRUcmFuc2l0aW9uc0ZvckxhbmVzIiwiY3VycmVudFVwZGF0ZVByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwibmV3UHJpb3JpdHkiLCJydW5XaXRoUHJpb3JpdHkiLCJwcmlvcml0eSIsInByZXZpb3VzUHJpb3JpdHkiLCJoaWdoZXJFdmVudFByaW9yaXR5IiwibG93ZXJFdmVudFByaW9yaXR5IiwiaXNIaWdoZXJFdmVudFByaW9yaXR5IiwibGFuZXNUb0V2ZW50UHJpb3JpdHkiLCJpc1Jvb3REZWh5ZHJhdGVkIiwiY3VycmVudFN0YXRlIiwiaXNEZWh5ZHJhdGVkIiwiX2F0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsInNldEF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsImF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsImF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwic2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkkMSIsInNldEdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsImF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5Iiwic2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkiLCJoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0IiwicXVldWVkRGlzY3JldGVFdmVudHMiLCJxdWV1ZWRGb2N1cyIsInF1ZXVlZERyYWciLCJxdWV1ZWRNb3VzZSIsInF1ZXVlZFBvaW50ZXJzIiwicXVldWVkUG9pbnRlckNhcHR1cmVzIiwicXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzIiwiZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzIiwiaXNEaXNjcmV0ZUV2ZW50VGhhdFJlcXVpcmVzSHlkcmF0aW9uIiwiZXZlbnRUeXBlIiwiY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50IiwiYmxvY2tlZE9uIiwiZG9tRXZlbnROYW1lIiwiZXZlbnRTeXN0ZW1GbGFncyIsInRhcmdldENvbnRhaW5lciIsInRhcmdldENvbnRhaW5lcnMiLCJjbGVhcklmQ29udGludW91c0V2ZW50IiwicG9pbnRlcklkIiwiZGVsZXRlIiwiX3BvaW50ZXJJZCIsImFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQiLCJleGlzdGluZ1F1ZXVlZEV2ZW50IiwicXVldWVkRXZlbnQiLCJfZmliZXIyIiwicXVldWVJZkNvbnRpbnVvdXNFdmVudCIsImZvY3VzRXZlbnQiLCJkcmFnRXZlbnQiLCJtb3VzZUV2ZW50IiwicG9pbnRlckV2ZW50IiwiX3BvaW50ZXJFdmVudCIsIl9wb2ludGVySWQyIiwiYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0IiwicXVldWVkVGFyZ2V0IiwidGFyZ2V0SW5zdCIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwicXVldWVFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCIsInVwZGF0ZVByaW9yaXR5Iiwic3BsaWNlIiwiYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudCIsIm5leHRCbG9ja2VkT24iLCJmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50IiwibmF0aXZlRXZlbnRDbG9uZSIsIl9maWJlcjMiLCJzaGlmdCIsImF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCIsInJlcGxheVVuYmxvY2tlZEV2ZW50cyIsInNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZCIsInVuYmxvY2tlZCIsInJldHJ5SWZCbG9ja2VkT24iLCJ1bmJsb2NrIiwibmV4dEV4cGxpY2l0VGFyZ2V0IiwiX2VuYWJsZWQiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5IiwiZ2V0RXZlbnRQcmlvcml0eSIsImxpc3RlbmVyV3JhcHBlciIsImRpc3BhdGNoRGlzY3JldGVFdmVudCIsImRpc3BhdGNoQ29udGludW91c0V2ZW50IiwiY29udGFpbmVyIiwiZGlzcGF0Y2hFdmVudFdpdGhFbmFibGVDYXB0dXJlUGhhc2VTZWxlY3RpdmVIeWRyYXRpb25XaXRob3V0RGlzY3JldGVFdmVudFJlcGxheSIsImRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbSIsInJldHVybl90YXJnZXRJbnN0Iiwic3RvcFByb3BhZ2F0aW9uIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyIiwiYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIiLCJhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyIsInBhc3NpdmUiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnIiwic3RhcnRUZXh0IiwiZmFsbGJhY2tUZXh0IiwiaW5pdGlhbGl6ZSIsImdldFRleHQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUiLCJmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UiLCJjcmVhdGVTeW50aGV0aWNFdmVudCIsIkludGVyZmFjZSIsIlN5bnRoZXRpY0Jhc2VFdmVudCIsInJlYWN0TmFtZSIsInJlYWN0RXZlbnRUeXBlIiwiX3JlYWN0TmFtZSIsIl90YXJnZXRJbnN0IiwiY3VycmVudFRhcmdldCIsIl9wcm9wTmFtZSIsIm5vcm1hbGl6ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicHJldmVudERlZmF1bHQiLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiaXNQZXJzaXN0ZW50IiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJpc1RydXN0ZWQiLCJTeW50aGV0aWNFdmVudCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwiZGV0YWlsIiwiU3ludGhldGljVUlFdmVudCIsImxhc3RNb3ZlbWVudFgiLCJsYXN0TW92ZW1lbnRZIiwibGFzdE1vdXNlRXZlbnQiLCJ1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiTW91c2VFdmVudEludGVyZmFjZSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsImZyb21DaGFyQ29kZSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsInJlcGVhdCIsImxvY2FsZSIsIndoaWNoIiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlBvaW50ZXJFdmVudEludGVyZmFjZSIsInByZXNzdXJlIiwidGFuZ2VudGlhbFByZXNzdXJlIiwidGlsdFgiLCJ0aWx0WSIsInR3aXN0IiwicG9pbnRlclR5cGUiLCJpc1ByaW1hcnkiLCJTeW50aGV0aWNQb2ludGVyRXZlbnQiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJXaGVlbEV2ZW50SW50ZXJmYWNlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZWx0YVoiLCJkZWx0YU1vZGUiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJkb2N1bWVudE1vZGUiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJyZWdpc3RlckV2ZW50cyIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImdldENvbXBvc2l0aW9uRXZlbnRUeXBlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiaXNVc2luZ0tvcmVhbklNRSIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJkaXNwYXRjaFF1ZXVlIiwiZmFsbGJhY2tEYXRhIiwibGlzdGVuZXJzIiwiYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzIiwiY3VzdG9tRGF0YSIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImNoYXIiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsImV4dHJhY3RFdmVudHMiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiZGF0ZSIsImVtYWlsIiwibW9udGgiLCJudW1iZXIiLCJwYXNzd29yZCIsInJhbmdlIiwic2VhcmNoIiwidGVsIiwidGltZSIsIndlZWsiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJpc0V2ZW50U3VwcG9ydGVkIiwiZXZlbnROYW1lU3VmZml4IiwiZXZlbnROYW1lIiwiaXNTdXBwb3J0ZWQiLCJyZWdpc3RlckV2ZW50cyQxIiwiY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50IiwiYWN0aXZlRWxlbWVudEluc3QiLCJzaG91bGRVc2VDaGFuZ2VFdmVudCIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJwcm9jZXNzRGlzcGF0Y2hRdWV1ZSIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsInRhcmdldE5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiYXR0YWNoRXZlbnQiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiZGV0YWNoRXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCIsImhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIiLCJzdGF0ZSIsImV4dHJhY3RFdmVudHMkMSIsImdldFRhcmdldEluc3RGdW5jIiwiaGFuZGxlRXZlbnRGdW5jIiwicmVnaXN0ZXJFdmVudHMkMiIsImV4dHJhY3RFdmVudHMkMiIsImlzT3ZlckV2ZW50IiwiaXNPdXRFdmVudCIsInJlbGF0ZWQiLCJpc0NvbnRhaW5lck1hcmtlZEFzUm9vdCIsIndpbiIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiX3JlbGF0ZWQiLCJTeW50aGV0aWNFdmVudEN0b3IiLCJsZWF2ZUV2ZW50VHlwZSIsImVudGVyRXZlbnRUeXBlIiwiZXZlbnRUeXBlUHJlZml4IiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJsZWF2ZSIsImVudGVyIiwibmF0aXZlVGFyZ2V0SW5zdCIsImVudGVyRXZlbnQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZVR3b1BoYXNlTGlzdGVuZXJzIiwib2JqZWN0SXMiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJjdXJyZW50S2V5IiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsIm5leHRTaWJsaW5nIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJnZXRPZmZzZXRzIiwib3V0ZXJOb2RlIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwiaW5kZXhXaXRoaW5BbmNob3IiLCJpbmRleFdpdGhpbkZvY3VzIiwib3V0ZXIiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImlzVGV4dE5vZGUiLCJjb250YWluc05vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNJbkRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaXNTYW1lT3JpZ2luRnJhbWUiLCJpZnJhbWUiLCJjb250ZW50V2luZG93IiwiZ2V0QWN0aXZlRWxlbWVudERlZXAiLCJIVE1MSUZyYW1lRWxlbWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImFuY2VzdG9ycyIsImFuY2VzdG9yIiwic2Nyb2xsTGVmdCIsInRvcCIsInNjcm9sbFRvcCIsImZvY3VzIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJyZWdpc3RlckV2ZW50cyQzIiwiYWN0aXZlRWxlbWVudCQxIiwiYWN0aXZlRWxlbWVudEluc3QkMSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJnZXRTZWxlY3Rpb24kMSIsImdldEV2ZW50VGFyZ2V0RG9jdW1lbnQiLCJldmVudFRhcmdldCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsImV4dHJhY3RFdmVudHMkMyIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwiQU5JTUFUSU9OX0VORCIsIkFOSU1BVElPTl9JVEVSQVRJT04iLCJBTklNQVRJT05fU1RBUlQiLCJUUkFOU0lUSU9OX0VORCIsInRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzIiwic2ltcGxlRXZlbnRQbHVnaW5FdmVudHMiLCJyZWdpc3RlclNpbXBsZUV2ZW50IiwicmVnaXN0ZXJTaW1wbGVFdmVudHMiLCJjYXBpdGFsaXplZEV2ZW50IiwiZXh0cmFjdEV2ZW50cyQ0IiwiaW5DYXB0dXJlUGhhc2UiLCJhY2N1bXVsYXRlVGFyZ2V0T25seSIsIl9saXN0ZW5lcnMiLCJhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnMiLCJfZXZlbnQiLCJleHRyYWN0RXZlbnRzJDUiLCJzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zIiwibWVkaWFFdmVudFR5cGVzIiwibm9uRGVsZWdhdGVkRXZlbnRzIiwiZXhlY3V0ZURpc3BhdGNoIiwicHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIiLCJkaXNwYXRjaExpc3RlbmVycyIsInByZXZpb3VzSW5zdGFuY2UiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMkaSIsIl9kaXNwYXRjaExpc3RlbmVycyRfaSIsIl9pbnN0YW5jZSIsIl9jdXJyZW50VGFyZ2V0IiwiX2xpc3RlbmVyIiwiX2Rpc3BhdGNoUXVldWUkaSIsImRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyIsImxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQiLCJ0YXJnZXRFbGVtZW50IiwiaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciIsImxpc3RlbmVyU2V0IiwiZ2V0RXZlbnRMaXN0ZW5lclNldCIsImxpc3RlbmVyU2V0S2V5IiwiZ2V0TGlzdGVuZXJTZXRLZXkiLCJhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lciIsImxpc3RlblRvTmF0aXZlRXZlbnQiLCJsaXN0ZW5pbmdNYXJrZXIiLCJsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEZWZlcnJlZExpc3RlbmVyRm9yTGVnYWN5RkJTdXBwb3J0IiwiaXNQYXNzaXZlTGlzdGVuZXIiLCJpc01hdGNoaW5nUm9vdENvbnRhaW5lciIsImdyYW5kQ29udGFpbmVyIiwiYW5jZXN0b3JJbnN0IiwidGFyZ2V0Q29udGFpbmVyTm9kZSIsIm1haW5Mb29wIiwibm9kZVRhZyIsImdyYW5kTm9kZSIsImdyYW5kVGFnIiwicGFyZW50VGFnIiwiY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lciIsInRhcmdldEZpYmVyIiwibmF0aXZlRXZlbnRUeXBlIiwiY2FwdHVyZU5hbWUiLCJyZWFjdEV2ZW50TmFtZSIsImxhc3RIb3N0Q29tcG9uZW50IiwiX2luc3RhbmNlMiIsIl9pbnN0YW5jZTMiLCJjYXB0dXJlTGlzdGVuZXIiLCJidWJibGVMaXN0ZW5lciIsImdldFBhcmVudCIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaW5zdEEiLCJpbnN0QiIsIm5vZGVBIiwibm9kZUIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50IiwiY29tbW9uIiwiX2luc3RhbmNlNCIsImxlYXZlRXZlbnQiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkciLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFIiwiSFRNTCQxIiwid2FybmVkVW5rbm93blRhZ3MiLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50Iiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsIndhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciIsImNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmciLCJub3JtYWxpemVIVE1MIiwiZGlhbG9nIiwid2VidmlldyIsInNlcnZlclZhbHVlIiwiY2xpZW50VmFsdWUiLCJub3JtYWxpemVkQ2xpZW50VmFsdWUiLCJub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUiLCJub3JtYWxpemVkU2VydmVyVmFsdWUiLCJhdHRyaWJ1dGVOYW1lcyIsIm5hbWVzIiwidGVzdEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgiLCJOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgiLCJtYXJrdXAiLCJtYXJrdXBTdHJpbmciLCJjaGVja0ZvclVubWF0Y2hlZFRleHQiLCJzZXJ2ZXJUZXh0IiwiY2xpZW50VGV4dCIsImlzQ29uY3VycmVudE1vZGUiLCJzaG91bGRXYXJuRGV2Iiwibm9ybWFsaXplZENsaWVudFRleHQiLCJub3JtYWxpemVkU2VydmVyVGV4dCIsImdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lciIsIm5vb3AiLCJ0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCIsIm9uY2xpY2siLCJzZXRJbml0aWFsRE9NUHJvcGVydGllcyIsImRvbUVsZW1lbnQiLCJuZXh0UHJvcHMiLCJwcm9wS2V5IiwibmV4dFByb3AiLCJuZXh0SHRtbCIsImNhblNldFRleHRDb250ZW50IiwidXBkYXRlRE9NUHJvcGVydGllcyIsInVwZGF0ZVBheWxvYWQiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSIsInNldEluaXRpYWxQcm9wZXJ0aWVzIiwicmF3UHJvcHMiLCJvbkNsaWNrIiwiZGlmZlByb3BlcnRpZXMiLCJsYXN0UmF3UHJvcHMiLCJuZXh0UmF3UHJvcHMiLCJsYXN0UHJvcHMiLCJsYXN0U3R5bGUiLCJsYXN0UHJvcCIsImxhc3RIdG1sIiwidXBkYXRlUHJvcGVydGllcyIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiZGlmZkh5ZHJhdGVkUHJvcGVydGllcyIsImV4dHJhQXR0cmlidXRlTmFtZXMiLCJhdHRyaWJ1dGVzIiwic2VydmVySFRNTCIsImV4cGVjdGVkSFRNTCIsImV4cGVjdGVkU3R5bGUiLCJpc01pc21hdGNoRHVlVG9CYWRDYXNpbmciLCJvd25OYW1lc3BhY2UiLCJkb250V2FybkN1c3RvbUVsZW1lbnQiLCJkaWZmSHlkcmF0ZWRUZXh0IiwidGV4dE5vZGUiLCJpc0RpZmZlcmVudCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0IiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwidmFsaWRhdGVET01OZXN0aW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiQxIiwiY2hpbGRUYWciLCJjaGlsZFRleHQiLCJwYXJlbnRJbmZvIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsImludmFsaWRQYXJlbnRPckFuY2VzdG9yIiwiYW5jZXN0b3JUYWciLCJ3YXJuS2V5IiwidGFnRGlzcGxheU5hbWUiLCJ3aGl0ZXNwYWNlSW5mbyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJTVVNQRU5TRV9TVEFSVF9EQVRBIiwiU1VTUEVOU0VfRU5EX0RBVEEiLCJTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEiLCJTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIiwiU1RZTEUkMSIsImV2ZW50c0VuYWJsZWQiLCJzZWxlY3Rpb25JbmZvcm1hdGlvbiIsImdldFJvb3RIb3N0Q29udGV4dCIsInJvb3RDb250YWluZXJJbnN0YW5jZSIsIm5hbWVzcGFjZSIsInZhbGlkYXRlZFRhZyIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0RGV2IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJwcmVwYXJlRm9yQ29tbWl0IiwiYWN0aXZlSW5zdGFuY2UiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJob3N0Q29udGV4dCIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJob3N0Q29udGV4dERldiIsIm93bkFuY2VzdG9ySW5mbyIsInByZWNhY2hlRmliZXJOb2RlIiwidXBkYXRlRmliZXJQcm9wcyIsImFwcGVuZEluaXRpYWxDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJhdXRvRm9jdXMiLCJwcmVwYXJlVXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZFNldFRleHRDb250ZW50IiwiX19odG1sIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHkiLCJjdXJyZW50RXZlbnQiLCJzY2hlZHVsZVRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwibm9UaW1lb3V0IiwibG9jYWxQcm9taXNlIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJxdWV1ZU1pY3JvdGFzayIsImNhdGNoIiwiaGFuZGxlRXJyb3JJbk5leHRUaWNrIiwiY29tbWl0TW91bnQiLCJjb21taXRVcGRhdGUiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0VGV4dFVwZGF0ZSIsInRleHRJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsInJlYWN0Um9vdENvbnRhaW5lciIsIl9yZWFjdFJvb3RDb250YWluZXIiLCJiZWZvcmVDaGlsZCIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5Iiwic3VzcGVuc2VJbnN0YW5jZSIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsImlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmciLCJpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayIsImdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyIsImRhdGFzZXQiLCJkaWdlc3QiLCJkZ3N0IiwibXNnIiwic3RjayIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5IiwiX3JlYWN0UmV0cnkiLCJnZXROZXh0SHlkcmF0YWJsZSIsIm5vZGVEYXRhIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciIsInBhcmVudENvbnRhaW5lciIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlIiwidGFyZ2V0SW5zdGFuY2UiLCJwcmV2aW91c1NpYmxpbmciLCJjb21taXRIeWRyYXRlZENvbnRhaW5lciIsImNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsInNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzIiwiZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UiLCJwYXJlbnRQcm9wcyIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImVycm9ySHlkcmF0aW5nQ29udGFpbmVyIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicG9ydGFsSW5zdGFuY2UiLCJyYW5kb21LZXkiLCJpbnRlcm5hbEluc3RhbmNlS2V5IiwiaW50ZXJuYWxQcm9wc0tleSIsImludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleSIsImludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5IiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwiaG9zdEluc3QiLCJtYXJrQ29udGFpbmVyQXNSb290IiwiaG9zdFJvb3QiLCJ1bm1hcmtDb250YWluZXJBc1Jvb3QiLCJ0YXJnZXRTdXNwZW5zZUluc3QiLCJlbGVtZW50TGlzdGVuZXJTZXQiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImNyZWF0ZUN1cnNvciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImNhY2hlQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQiLCJnZXRNYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwiaGFzQ29udGV4dENoYW5nZWQiLCJjaGlsZENvbnRleHRUeXBlcyIsInBvcENvbnRleHQiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyIiwibWVyZ2VkQ29udGV4dCIsImZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290Iiwic3luY1F1ZXVlIiwiaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzIiwiaXNGbHVzaGluZ1N5bmNRdWV1ZSIsInNjaGVkdWxlU3luY0NhbGxiYWNrIiwic2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2siLCJmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlIiwiZmx1c2hTeW5jQ2FsbGJhY2tzIiwicHJldmlvdXNVcGRhdGVQcmlvcml0eSIsImlzU3luYyIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtQcm92aWRlciIsInRyZWVGb3JrQ291bnQiLCJpZFN0YWNrIiwiaWRTdGFja0luZGV4IiwidHJlZUNvbnRleHRQcm92aWRlciIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwiaXNGb3JrZWRDaGlsZCIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImdldEZvcmtzQXRMZXZlbCIsImdldFRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnZXRMZWFkaW5nQml0IiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsInB1c2hUcmVlSWQiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsInB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQiLCJyZXR1cm5GaWJlciIsIm51bWJlck9mRm9ya3MiLCJzbG90SW5kZXgiLCJwb3BUcmVlQ29udGV4dCIsImdldFN1c3BlbmRlZFRyZWVDb250ZXh0IiwicmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0Iiwic3VzcGVuZGVkQ29udGV4dCIsImdldElzSHlkcmF0aW5nIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkU3VzcGVuZE9yRXJyb3JERVYiLCJoeWRyYXRpb25FcnJvcnMiLCJ3YXJuSWZIeWRyYXRpbmciLCJtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFViIsImRpZFN1c3BlbmRPckVycm9yV2hpbGVIeWRyYXRpbmdERVYiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwidHJlZUNvbnRleHQiLCJ3YXJuVW5oeWRyYXRlZEluc3RhbmNlIiwibWVtb2l6ZWRQcm9wcyIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNoaWxkVG9EZWxldGUiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImRlbGV0aW9ucyIsIndhcm5Ob25oeWRyYXRlZEluc3RhbmNlIiwicGVuZGluZ1Byb3BzIiwiX3RleHQiLCJfaXNDb25jdXJyZW50TW9kZSIsIl9wYXJlbnRJbnN0YW5jZSIsIl90eXBlMiIsIl90ZXh0MiIsImluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJ0cnlIeWRyYXRlIiwibmV4dEluc3RhbmNlIiwicmV0cnlMYW5lIiwiZGVoeWRyYXRlZEZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50Iiwic2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaCIsInRocm93T25IeWRyYXRpb25NaXNtYXRjaCIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSIsInByZXZIeWRyYXRpb25QYXJlbnRGaWJlciIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJzaG91bGRXYXJuSWZNaXNtYXRjaERldiIsInVwZGF0ZVF1ZXVlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJzaG91bGRVcGRhdGUiLCJfaXNDb25jdXJyZW50TW9kZTIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UiLCJza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsInBvcEh5ZHJhdGlvblN0YXRlIiwid2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyIsImhhc1VuaHlkcmF0ZWRUYWlsTm9kZXMiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUiLCJxdWV1ZVJlY292ZXJhYmxlRXJyb3JzIiwicXVldWVIeWRyYXRpb25FcnJvciIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEiLCJOb1RyYW5zaXRpb24iLCJyZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24iLCJSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiZmluZFN0cmljdFJvb3QiLCJtYXliZVN0cmljdFJvb3QiLCJzZXRUb1NvcnRlZFN0cmluZyIsInNvcnQiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzMiIsIl9zb3J0ZWROYW1lczMiLCJfc29ydGVkTmFtZXM0IiwiX3NvcnRlZE5hbWVzNSIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290Iiwid2FybmluZ3NGb3JSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsImlzUmVhY3RDbGFzcyIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwicmVzb2x2ZWRJbnN0Iiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiY2hpbGRTdHJpbmciLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJyZXNvbHZlTGF6eSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX2NyZWF0ZWQiLCJfY3JlYXRlZDIiLCJfY3JlYXRlZDMiLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwibWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIyIiwiX21hdGNoZWRGaWJlcjMiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbnVtYmVyT2ZGb3JrcyIsIl9uZXdGaWJlcjIiLCJfbnVtYmVyT2ZGb3JrczIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsIl9uZXdDaGlsZHJlbiIsIl9zdGVwIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJwb3BQcm92aWRlciIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGlvblJvb3QiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJkZXBlbmRlbmN5IiwiZmlyc3RDb250ZXh0IiwidXBkYXRlIiwiY3JlYXRlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJzaGFyZWRRdWV1ZSIsInNoYXJlZCIsInBhcmVudFN1c3BlbnNlIiwiX2FsdGVybmF0ZSIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwibWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUiLCJyZWFkQ29udGV4dCIsImNvbnRleHRJdGVtIiwibWVtb2l6ZWRWYWx1ZSIsImNvbmN1cnJlbnRRdWV1ZXMiLCJwdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlIiwiZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcyIsImxhc3RJbnRlcmxlYXZlZFVwZGF0ZSIsImludGVybGVhdmVkIiwiZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZSIsImxhc3RQZW5kaW5nVXBkYXRlIiwiZmlyc3RQZW5kaW5nVXBkYXRlIiwiZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlIiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dCIsImVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJ1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJzb3VyY2VGaWJlciIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJVcGRhdGVTdGF0ZSIsIlJlcGxhY2VTdGF0ZSIsIkNhcHR1cmVVcGRhdGUiLCJoYXNGb3JjZVVwZGF0ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJiYXNlU3RhdGUiLCJmaXJzdEJhc2VVcGRhdGUiLCJsYXN0QmFzZVVwZGF0ZSIsImVmZmVjdHMiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiZW5xdWV1ZVVwZGF0ZSIsImlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwibmV3UXVldWVMYW5lcyIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsImNhcHR1cmVkVXBkYXRlIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwibmV4dFN0YXRlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwicGVuZGluZ1F1ZXVlIiwiY3VycmVudExhc3RCYXNlVXBkYXRlIiwibmV3U3RhdGUiLCJuZXdMYW5lcyIsIm5ld0Jhc2VTdGF0ZSIsIm5ld0ZpcnN0QmFzZVVwZGF0ZSIsIm5ld0xhc3RCYXNlVXBkYXRlIiwidXBkYXRlRXZlbnRUaW1lIiwiX2Nsb25lIiwiX2xhc3RQZW5kaW5nVXBkYXRlIiwiX2ZpcnN0UGVuZGluZ1VwZGF0ZSIsImxhc3RJbnRlcmxlYXZlZCIsIm1hcmtTa2lwcGVkVXBkYXRlTGFuZXMiLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJjb21taXRVcGRhdGVRdWV1ZSIsImZpbmlzaGVkV29yayIsImZpbmlzaGVkUXVldWUiLCJlZmZlY3QiLCJOT19DT05URVhUIiwiY29udGV4dFN0YWNrQ3Vyc29yJDEiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJyb290SW5zdGFuY2UiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwiZ2V0SG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRleHQiLCJuZXh0Q29udGV4dCIsInBvcEhvc3RDb250ZXh0IiwiRGVmYXVsdFN1c3BlbnNlQ29udGV4dCIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwiSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IiwiRm9yY2VTdXNwZW5zZUZhbGxiYWNrIiwic3VzcGVuc2VTdGFja0N1cnNvciIsImhhc1N1c3BlbnNlQ29udGV4dCIsImZsYWciLCJzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dCIsInNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQiLCJzaGFsbG93Q29udGV4dCIsImFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQiLCJzdWJ0cmVlQ29udGV4dCIsInB1c2hTdXNwZW5zZUNvbnRleHQiLCJuZXdDb250ZXh0IiwicG9wU3VzcGVuc2VDb250ZXh0Iiwic2hvdWxkQ2FwdHVyZVN1c3BlbnNlIiwiaGFzSW52aXNpYmxlUGFyZW50IiwiZmluZEZpcnN0U3VzcGVuZGVkIiwicm93IiwicmV2ZWFsT3JkZXIiLCJkaWRTdXNwZW5kIiwiTm9GbGFncyQxIiwiSGFzRWZmZWN0IiwiSW5zZXJ0aW9uIiwiTGF5b3V0IiwiUGFzc2l2ZSQxIiwid29ya0luUHJvZ3Jlc3NTb3VyY2VzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zIiwibXV0YWJsZVNvdXJjZSIsIl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5IiwicmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uIiwiZ2V0VmVyc2lvbiIsIl9nZXRWZXJzaW9uIiwibXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJsb2NhbElkQ291bnRlciIsImdsb2JhbENsaWVudElkQ291bnRlciIsIlJFX1JFTkRFUl9MSU1JVCIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJ3YXJuT25Ib29rTWlzbWF0Y2hJbkRldiIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiY3VycmVudEhvb2tOYW1lIiwidGFibGUiLCJzZWNvbmRDb2x1bW5TdGFydCIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJ0aHJvd0ludmFsaWRIb29rRXJyb3IiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwicmVuZGVyV2l0aEhvb2tzIiwic2Vjb25kQXJnIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJudW1iZXJPZlJlUmVuZGVycyIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIkNvbnRleHRPbmx5RGlzcGF0Y2hlciIsImRpZFJlbmRlclRvb0Zld0hvb2tzIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzQWZ0ZXJUaHJvdyIsImlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXdIb29rIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsImxhc3RFZmZlY3QiLCJzdG9yZXMiLCJiYXNpY1N0YXRlUmVkdWNlciIsIm1vdW50UmVkdWNlciIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsImhhc0VhZ2VyU3RhdGUiLCJlYWdlclN0YXRlIiwiaW50ZXJsZWF2ZWRMYW5lIiwicmVyZW5kZXJSZWR1Y2VyIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50TXV0YWJsZVNvdXJjZSIsInVwZGF0ZU11dGFibGVTb3VyY2UiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwibmV4dFNuYXBzaG90IiwiY2FjaGVkU25hcHNob3QiLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsInByZXZTbmFwc2hvdCIsInNuYXBzaG90Q2hhbmdlZCIsInVwZGF0ZUVmZmVjdCIsInJlbmRlcmVkU25hcHNob3QiLCJjaGVjayIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJzY2hlZHVsZVVwZGF0ZU9uRmliZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsImRlc3Ryb3kiLCJmaXJzdEVmZmVjdCIsIm1vdW50UmVmIiwiX3JlZjIiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckZsYWdzIiwiaG9va0ZsYWdzIiwidXBkYXRlRWZmZWN0SW1wbCIsInByZXZFZmZlY3QiLCJtb3VudEluc2VydGlvbkVmZmVjdCIsInVwZGF0ZUluc2VydGlvbkVmZmVjdCIsIm1vdW50TGF5b3V0RWZmZWN0IiwidXBkYXRlTGF5b3V0RWZmZWN0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNhbGxiYWNrIiwiX2luc3QiLCJfaW5zdDIiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJlZmZlY3REZXBzIiwidXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSIsIm1vdW50RGVidWdWYWx1ZSIsInVwZGF0ZURlYnVnVmFsdWUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsInVwZGF0ZURlZmVycmVkVmFsdWUiLCJyZXNvbHZlZEN1cnJlbnRIb29rIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJzaG91bGREZWZlclZhbHVlIiwiZGVmZXJyZWRMYW5lIiwic2V0UGVuZGluZyIsIm1vdW50VHJhbnNpdGlvbiIsIl9tb3VudFN0YXRlIiwiaXNQZW5kaW5nIiwidXBkYXRlVHJhbnNpdGlvbiIsIl91cGRhdGVTdGF0ZSIsInJlcmVuZGVyVHJhbnNpdGlvbiIsIl9yZXJlbmRlclN0YXRlIiwiZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsInJlcXVlc3RVcGRhdGVMYW5lIiwiaXNSZW5kZXJQaGFzZVVwZGF0ZSIsImVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZSIsInJlcXVlc3RFdmVudFRpbWUiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ1c2VNdXRhYmxlU291cmNlIiwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ckMSIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJhY3R1YWxEdXJhdGlvbiIsInNlbGZCYXNlRHVyYXRpb24iLCJyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbiIsInBhcmVudEZpYmVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXJlbnRTdGF0ZU5vZGUiLCJyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJzdGFydExheW91dEVmZmVjdFRpbWVyIiwic3RhcnRQYXNzaXZlRWZmZWN0VGltZXIiLCJ0cmFuc2ZlckFjdHVhbER1cmF0aW9uIiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDEiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkU3RhdGUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiY29udGV4dFR5cGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiaGFzTXV0YXRlZFByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJfc3RhdGUiLCJhZG9wdENsYXNzSW5zdGFuY2UiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsImlzTGVnYWN5Q29udGV4dENvbnN1bWVyIiwiYWRkZW5kdW0iLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImNvbXBvbmVudERpZE1vdW50IiwicmVzdW1lTW91bnRDbGFzc0luc3RhbmNlIiwib2xkQ29udGV4dCIsIm5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQiLCJoYXNOZXdMaWZlY3ljbGVzIiwiX2ZpYmVyRmxhZ3MiLCJfZmliZXJGbGFnczIiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwidW5yZXNvbHZlZE9sZFByb3BzIiwidW5yZXNvbHZlZE5ld1Byb3BzIiwibmV4dFVubWFza2VkQ29udGV4dCIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZSIsInNob3dFcnJvckRpYWxvZyIsImJvdW5kYXJ5IiwiZXJyb3JJbmZvIiwibG9nQ2FwdHVyZWRFcnJvciIsImxvZ0Vycm9yIiwiY29tcG9uZW50U3RhY2siLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJjb21iaW5lZE1lc3NhZ2UiLCJQb3NzaWJseVdlYWtNYXAkMSIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsIm9uVW5jYXVnaHRFcnJvciIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInBpbmdDYWNoZSIsInRocmVhZElEcyIsInBpbmciLCJwaW5nU3VzcGVuZGVkUm9vdCIsInJlc3RvcmVQZW5kaW5nVXBkYXRlcnMiLCJhdHRhY2hSZXRyeUxpc3RlbmVyIiwic3VzcGVuc2VCb3VuZGFyeSIsIndha2VhYmxlcyIsInJlc2V0U3VzcGVuZGVkQ29tcG9uZW50Iiwicm9vdFJlbmRlckxhbmVzIiwiY3VycmVudFNvdXJjZSIsImdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlIiwibWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlIiwiY3VycmVudFNvdXJjZUZpYmVyIiwidGhyb3dFeGNlcHRpb24iLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwidW5jYXVnaHRTdXNwZW5zZUVycm9yIiwiX3N1c3BlbnNlQm91bmRhcnkiLCJyZW5kZXJEaWRFcnJvciIsIl9lcnJvckluZm8iLCJpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5IiwiX2xhbmUiLCJfdXBkYXRlIiwiZ2V0U3VzcGVuZGVkQ2FjaGUiLCJkaWRSZWNlaXZlVXBkYXRlIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciIsImRpZFdhcm5BYm91dFRhaWxPcHRpb25zIiwiZGlkV2FybkFib3V0RGVmYXVsdFByb3BzT25GdW5jdGlvbkNvbXBvbmVudCIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwiZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZSIsInVwZGF0ZUZvcndhcmRSZWYiLCJpbm5lclByb3BUeXBlcyIsImhhc0lkIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50IiwicmVzb2x2ZWRUeXBlIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsIl9pbm5lclByb3BUeXBlcyIsImhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsImNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwicHJldlByb3BzIiwib3V0ZXJNZW1vVHlwZSIsIm91dGVyUHJvcFR5cGVzIiwidXBkYXRlRnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQiLCJiYXNlTGFuZXMiLCJjYWNoZVBvb2wiLCJ0cmFuc2l0aW9ucyIsInB1c2hSZW5kZXJMYW5lcyIsInNwYXduZWRDYWNoZVBvb2wiLCJuZXh0QmFzZUxhbmVzIiwicHJldkJhc2VMYW5lcyIsIl9uZXh0U3RhdGUiLCJfbmV4dFN0YXRlMiIsInN1YnRyZWVSZW5kZXJMYW5lcyIsIl9zdWJ0cmVlUmVuZGVyTGFuZXMiLCJ1cGRhdGVNb2RlIiwidXBkYXRlUHJvZmlsZXIiLCJtYXJrUmVmIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJzaG91bGRFcnJvciIsInRlbXBJbnN0YW5jZSIsImhhc0NvbnRleHQiLCJyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlIiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJwZW5kaW5nQ29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwicHJldkNoaWxkcmVuIiwib3ZlcnJpZGVTdGF0ZSIsImNhY2hlIiwicGVuZGluZ1N1c3BlbnNlQm91bmRhcmllcyIsInJlY292ZXJhYmxlRXJyb3IiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsIl9yZWNvdmVyYWJsZUVycm9yIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImlzRGlyZWN0VGV4dENoaWxkIiwidXBkYXRlSG9zdFRleHQiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJfY29tcG9uZW50TmFtZTIiLCJkZWJ1Z1NvdXJjZSIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJ1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwicHJldk9mZnNjcmVlblN0YXRlIiwic2hvdWxkUmVtYWluT25GYWxsYmFjayIsInN1c3BlbnNlQ29udGV4dCIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG91bGRTdXNwZW5kIiwic2hvd0ZhbGxiYWNrIiwibW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJuZXh0UHJpbWFyeUNoaWxkcmVuIiwibmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJmYWxsYmFjayIsImZhbGxiYWNrRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsInByaW1hcnlDaGlsZEZyYWdtZW50IiwibW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsIl9kZWh5ZHJhdGVkIiwidXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwiX25leHRGYWxsYmFja0NoaWxkcmVuIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4iLCJmYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJ1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQyIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MyIsInVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwicHJpbWFyeUNoaWxkcmVuIiwicHJpbWFyeUNoaWxkUHJvcHMiLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJmYWxsYmFja0NoaWxkcmVuIiwicHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCIsInRyZWVCYXNlRHVyYXRpb24iLCJvZmZzY3JlZW5Qcm9wcyIsImNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbiIsInVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50Iiwic3VidHJlZUZsYWdzIiwicmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmciLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyIsImZpYmVyTW9kZSIsIl9nZXRTdXNwZW5zZUluc3RhbmNlRiIsImNhcHR1cmVkVmFsdWUiLCJhdHRlbXB0SHlkcmF0aW9uQXRMYW5lIiwiX2NhcHR1cmVkVmFsdWUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJfY2FwdHVyZWRWYWx1ZTIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Iiwic2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyIiwicHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInZhbGlkYXRlVGFpbE9wdGlvbnMiLCJ0YWlsTW9kZSIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUiLCJpc0JhY2t3YXJkcyIsInRhaWwiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJwcm92aWRlclByb3BUeXBlcyIsIm9sZFZhbHVlIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyIiwidXBkYXRlQ29udGV4dENvbnN1bWVyIiwicmVtb3VudEZpYmVyIiwib2xkV29ya0luUHJvZ3Jlc3MiLCJuZXdXb3JrSW5Qcm9ncmVzcyIsInByZXZTaWJsaW5nIiwidXBkYXRlTGFuZXMiLCJhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZSIsImhhc0NoaWxkV29yayIsInByaW1hcnlDaGlsZExhbmVzIiwiX2hhc0NoaWxkV29yayIsImJlZ2luV29yayIsIl9kZWJ1Z05lZWRzUmVtb3VudCIsInVucmVzb2x2ZWRQcm9wcyIsIl9Db21wb25lbnQiLCJfdW5yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzMiIsIl9yZXNvbHZlZFByb3BzMiIsIl91bnJlc29sdmVkUHJvcHMzIiwiX3Jlc29sdmVkUHJvcHMzIiwiX0NvbXBvbmVudDIiLCJfdW5yZXNvbHZlZFByb3BzNCIsIl9yZXNvbHZlZFByb3BzNCIsIm1hcmtVcGRhdGUiLCJtYXJrUmVmJDEiLCJhcHBlbmRBbGxDaGlsZHJlbiIsInVwZGF0ZUhvc3RDb250YWluZXIiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJ1cGRhdGVIb3N0VGV4dCQxIiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwiaXNIaWRkZW4iLCJjdXJyZW50SG9zdENvbnRleHQiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJ0YWlsTm9kZSIsImxhc3RUYWlsTm9kZSIsIl90YWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwiY29tcGxldGVkV29yayIsImRpZEJhaWxvdXQiLCJuZXdDaGlsZExhbmVzIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwiX2NoaWxkMyIsImNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3YXNIeWRyYXRlZCIsImlzVGltZWRPdXRTdXNwZW5zZSIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJfd2FzSHlkcmF0ZWQiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dCIsIl93YXNIeWRyYXRlZDIiLCJmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoIiwibmV4dERpZFRpbWVvdXQiLCJwcmV2RGlkVGltZW91dCIsIl9vZmZzY3JlZW5GaWJlcjIiLCJoYXNJbnZpc2libGVDaGlsZENvbnRleHQiLCJ1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayIsInJlbmRlckRpZFN1c3BlbmQiLCJkaWRTdXNwZW5kQWxyZWFkeSIsInJlbmRlcmVkVGFpbCIsImNhbm5vdEJlU3VzcGVuZGVkIiwicmVuZGVySGFzTm90U3VzcGVuZGVkWWV0Iiwic3VzcGVuZGVkIiwibmV3VGhlbmFibGVzIiwiZ2V0UmVuZGVyVGFyZ2V0VGltZSIsIl9zdXNwZW5kZWQiLCJfbmV3VGhlbmFibGVzIiwicG9wUmVuZGVyTGFuZXMiLCJuZXh0SXNIaWRkZW4iLCJfcHJldlN0YXRlIiwicHJldklzSGlkZGVuIiwidW53aW5kV29yayIsIl9mbGFncyIsIl9mbGFnczIiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJQb3NzaWJseVdlYWtTZXQiLCJXZWFrU2V0IiwibmV4dEVmZmVjdCIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwicmVwb3J0VW5jYXVnaHRFcnJvckluREVWIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZXRWYWwiLCJzYWZlbHlDYWxsRGVzdHJveSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwic25hcHNob3QiLCJkaWRXYXJuU2V0IiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zIiwiZmluaXNoZWRSb290IiwiX2ZpbmlzaGVkV29yayRtZW1vaXplIiwib25Qb3N0Q29tbWl0IiwicGhhc2UiLCJjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyIiwiY29tbWl0dGVkTGFuZXMiLCJfdXBkYXRlUXVldWUiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUyIiwib25Db21taXQiLCJvblJlbmRlciIsImVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0IiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJyZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyIiwiaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4iLCJob3N0U3VidHJlZVJvb3QiLCJpbnN0YW5jZVRvVXNlIiwiZGV0YWNoRmliZXJNdXRhdGlvbiIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiaG9zdEluc3RhbmNlIiwiZ2V0SG9zdFBhcmVudEZpYmVyIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJzaWJsaW5ncyIsImNvbW1pdFBsYWNlbWVudCIsImJlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZSIsIl9wYXJlbnQiLCJfYmVmb3JlIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lciIsImlzSG9zdCIsImhvc3RQYXJlbnQiLCJob3N0UGFyZW50SXNDb250YWluZXIiLCJjb21taXREZWxldGlvbkVmZmVjdHMiLCJkZWxldGVkRmliZXIiLCJmaW5kUGFyZW50IiwiY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMiLCJwcmV2SG9zdFBhcmVudCIsInByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJfcHJldkhvc3RQYXJlbnQiLCJfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsIl9lZmZlY3QiLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsImNvbW1pdFN1c3BlbnNlQ2FsbGJhY2siLCJhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzIiwicmV0cnlDYWNoZSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMiLCJwcmV2RGVidWdGaWJlciIsImNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyIsInByZXZSb290U3RhdGUiLCJvZmZzY3JlZW5GaWJlciIsIm9mZnNjcmVlbkluc3RhbmNlIiwid2FzSGlkZGVuIiwibWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrIiwiX3dhc0hpZGRlbiIsIl9vZmZzY3JlZW5JbnN0YW5jZSIsIl9uZXdTdGF0ZSIsIl9pc0hpZGRlbiIsIm9mZnNjcmVlbkJvdW5kYXJ5Iiwib2Zmc2NyZWVuQ2hpbGQiLCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImNvbW1pdExheW91dEVmZmVjdHNfYmVnaW4iLCJzdWJ0cmVlUm9vdCIsImlzTW9kZXJuUm9vdCIsIm5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsImNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZSIsIm5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luIiwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZSIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXR0ZWRUcmFuc2l0aW9ucyIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4iLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlIiwiY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbiIsImZpYmVyVG9EZWxldGUiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwicHJldmlvdXNGaWJlciIsImRldGFjaGVkQ2hpbGQiLCJkZXRhY2hlZFNpYmxpbmciLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIiLCJkZWxldGVkU3VidHJlZVJvb3QiLCJjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlciIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUiLCJpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWIiwiaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYiLCJpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYiLCJpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWIiwic3ltYm9sRm9yIiwiY29tbWl0SG9va3MiLCJvbkNvbW1pdFJvb3QkMSIsImNvbW1pdEhvb2siLCJpc0xlZ2FjeUFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwiamVzdElzRGVmaW5lZCIsImplc3QiLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImNlaWwiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIiLCJSZWFjdEN1cnJlbnRPd25lciQyIiwiUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMyIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlJDEiLCJOb0NvbnRleHQiLCJCYXRjaGVkQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJDb21taXRDb250ZXh0IiwiUm9vdEluUHJvZ3Jlc3MiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdEVycm9yZWQiLCJSb290U3VzcGVuZGVkIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RDb21wbGV0ZWQiLCJSb290RGlkTm90Q29tcGxldGUiLCJleGVjdXRpb25Db250ZXh0Iiwid29ya0luUHJvZ3Jlc3NSb290Iiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIiwid29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciIsIndvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzIiwid29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwiSW5maW5pdHkiLCJSRU5ERVJfVElNRU9VVF9NUyIsIndvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMiLCJyZXNldFJlbmRlclRpbWVyIiwiaGFzVW5jYXVnaHRFcnJvciIsImZpcnN0VW5jYXVnaHRFcnJvciIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwicm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50Iiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJjdXJyZW50RXZlbnRUaW1lIiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJpc1RyYW5zaXRpb24iLCJldmVudExhbmUiLCJyZXF1ZXN0UmV0cnlMYW5lIiwiY2hlY2tGb3JOZXN0ZWRVcGRhdGVzIiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwic2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290IiwiZXhpc3RpbmdDYWxsYmFja05vZGUiLCJjYWxsYmFja05vZGUiLCJjYW5jZWxDYWxsYmFjayQxIiwiY2FsbGJhY2tQcmlvcml0eSIsIm5ld0NhbGxiYWNrUHJpb3JpdHkiLCJleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwibmV3Q2FsbGJhY2tOb2RlIiwicGVyZm9ybVN5bmNXb3JrT25Sb290Iiwic2NoZWR1bGVyUHJpb3JpdHlMZXZlbCIsInNjaGVkdWxlQ2FsbGJhY2skMSIsInBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCIsImRpZFRpbWVvdXQiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsImRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJmbHVzaFBhc3NpdmVFZmZlY3RzIiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJlcnJvclJldHJ5TGFuZXMiLCJyZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvciIsImZhdGFsRXJyb3IiLCJwcmVwYXJlRnJlc2hTdGFjayIsInJlbmRlcldhc0NvbmN1cnJlbnQiLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJfZXJyb3JSZXRyeUxhbmVzIiwiX2ZhdGFsRXJyb3IiLCJmaW5pc2hlZExhbmVzIiwiZmluaXNoQ29uY3VycmVudFJlbmRlciIsImVycm9yc0Zyb21GaXJzdEF0dGVtcHQiLCJyb290V29ya0luUHJvZ3Jlc3MiLCJlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCIsImVycm9ycyIsImNvbW1pdFJvb3QiLCJzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYiLCJtc1VudGlsVGltZW91dCIsInRpbWVvdXRIYW5kbGUiLCJldmVudFRpbWVNcyIsInRpbWVFbGFwc2VkTXMiLCJfbXNVbnRpbFRpbWVvdXQiLCJqbmQiLCJjaGVja3MiLCJyZW5kZXJlZFZhbHVlIiwiZmx1c2hSb290IiwiYmF0Y2hlZFVwZGF0ZXMkMSIsInByZXZFeGVjdXRpb25Db250ZXh0IiwiZGlzY3JldGVVcGRhdGVzIiwiZmx1c2hTeW5jIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwiaGFuZGxlRXJyb3IiLCJlcnJvcmVkV29yayIsImNvbXBsZXRlVW5pdE9mV29yayIsInlldEFub3RoZXJUaHJvd25WYWx1ZSIsInB1c2hEaXNwYXRjaGVyIiwicG9wRGlzcGF0Y2hlciIsIndvcmtMb29wU3luYyIsInBlcmZvcm1Vbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwidW5pdE9mV29yayIsImJlZ2luV29yayQxIiwiX25leHQiLCJzaWJsaW5nRmliZXIiLCJyZWNvdmVyYWJsZUVycm9ycyIsInByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5IiwiY29tbWl0Um9vdEltcGwiLCJyZW5kZXJQcmlvcml0eUxldmVsIiwiZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWIiwic3VidHJlZUhhc0VmZmVjdHMiLCJyb290SGFzRWZmZWN0Iiwicm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyIsImNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInJlbmRlclByaW9yaXR5IiwiZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwiLCJwcm9maWxlckVmZmVjdHMiLCJfZmliZXIiLCJwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsIndhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWIiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsImhhc1Bhc3NpdmVFZmZlY3RzIiwiaW52b2tlRWZmZWN0c0luRGV2IiwiaW52b2tlRWZmZWN0Rm4iLCJwcmltYXJ5U3VidHJlZUZsYWciLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50IiwiZHVtbXlGaWJlciIsIm9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5IiwiYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYiLCJvcmlnaW5hbEVycm9yIiwicmVwbGF5RXJyb3IiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsInJlbmRlcmluZ0NvbXBvbmVudE5hbWUiLCJkZWR1cGVLZXkiLCJzZXRTdGF0ZUNvbXBvbmVudE5hbWUiLCJzY2hlZHVsaW5nRmliZXIiLCJhY3RRdWV1ZSIsImlzUnVubmluZyIsInJlc29sdmVGYW1pbHkiLCJmYWlsZWRCb3VuZGFyaWVzIiwic2V0UmVmcmVzaEhhbmRsZXIiLCJoYW5kbGVyIiwiZmFtaWx5IiwiY3VycmVudFJlbmRlciIsInN5bnRoZXRpY1R5cGUiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwicHJldkZhbWlseSIsInNjaGVkdWxlUmVmcmVzaCIsInN0YWxlRmFtaWxpZXMiLCJ1cGRhdGVkRmFtaWxpZXMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5Iiwic2NoZWR1bGVSb290IiwidXBkYXRlQ29udGFpbmVyIiwiY2FuZGlkYXRlVHlwZSIsIm5lZWRzUmVuZGVyIiwibmVlZHNSZW1vdW50IiwiX3Jvb3QiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QkMSIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiaXNTdHJpY3RNb2RlIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJkZWh5ZHJhdGVkTm9kZSIsInBlbmRpbmdDaGlsZHJlbiIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidW5pbml0aWFsaXplZEZpYmVyIiwiX2luaXRpYWxTdGF0ZSIsImNyZWF0ZVBvcnRhbCIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSIsImdldENvbnRleHRGb3JTdWJ0cmVlIiwicGFyZW50Q29tcG9uZW50IiwiZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nIiwiaG9zdEZpYmVyIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3VycmVudCQxIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24kMSIsIm1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkIiwibWFya1JldHJ5TGFuZUltcGwiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsInVwZGF0ZWQiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJyZWNvbmNpbGVyVmVyc2lvbiIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJyZXBvcnRFcnJvciIsIlJlYWN0RE9NUm9vdCIsImludGVybmFsUm9vdCIsIl9pbnRlcm5hbFJvb3QiLCJSZWFjdERPTUh5ZHJhdGlvblJvb3QiLCJpc1ZhbGlkQ29udGFpbmVyIiwidW5tb3VudCIsImNyZWF0ZVJvb3QiLCJ3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWIiwidW5zdGFibGVfc3RyaWN0TW9kZSIsInNjaGVkdWxlSHlkcmF0aW9uIiwidW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb24iLCJoeWRyYXRlUm9vdCIsIm11dGFibGVTb3VyY2VzIiwiaHlkcmF0ZWRTb3VyY2VzIiwiZGlzYWJsZUNvbW1lbnRzQXNET01Db250YWluZXJzIiwiaXNWYWxpZENvbnRhaW5lckxlZ2FjeSIsIlJlYWN0Q3VycmVudE93bmVyJDMiLCJ0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImhhc05vblJvb3RSZWFjdENoaWxkIiwibm9vcE9uUmVjb3ZlcmFibGVFcnJvciIsImxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyIiwiaXNIeWRyYXRpb25Db250YWluZXIiLCJvcmlnaW5hbENhbGxiYWNrIiwicm9vdFNpYmxpbmciLCJfb3JpZ2luYWxDYWxsYmFjayIsIl9yb290Q29udGFpbmVyRWxlbWVudCIsIndhcm5PbkludmFsaWRDYWxsYmFjayQxIiwibGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJtYXliZVJvb3QiLCJkaWRXYXJuQWJvdXRGaW5kRE9NTm9kZSIsImZpbmRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImNvbnRhaW5lck5vZGUiLCJkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCIsIl9yb290RWwiLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsImNyZWF0ZVBvcnRhbCQxIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJJbnRlcm5hbHMiLCJ1c2luZ0NsaWVudEVudHJ5UG9pbnQiLCJFdmVudHMiLCJjcmVhdGVSb290JDEiLCJoeWRyYXRlUm9vdCQxIiwiZmx1c2hTeW5jJDEiLCJmb3VuZERldlRvb2xzIiwidXNlckFnZW50IiwicHJvdG9jb2wiLCJtIiwibyIsImgiLCJydW50aW1lIiwiZ2V0UnVudGltZSIsInNldFJ1bnRpbWUiLCJnbG9iYWwiLCJmYWN0b3J5IiwiZ2xvYmFsVGhpcyIsInRoaXMiLCJjaHJvbWUiLCJicm93c2VyIiwiZ2V0UHJvdG90eXBlT2YiLCJDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UiLCJ3cmFwQVBJcyIsImV4dGVuc2lvbkFQSXMiLCJhcGlNZXRhZGF0YSIsIkRlZmF1bHRXZWFrTWFwIiwiY3JlYXRlSXRlbSIsIml0ZW1zIiwiaXNUaGVuYWJsZSIsIm1ha2VDYWxsYmFjayIsInByb21pc2UiLCJtZXRhZGF0YSIsImNhbGxiYWNrQXJncyIsImxhc3RFcnJvciIsInNpbmdsZUNhbGxiYWNrQXJnIiwicGx1cmFsaXplQXJndW1lbnRzIiwibnVtQXJncyIsIndyYXBBc3luY0Z1bmN0aW9uIiwiYXN5bmNGdW5jdGlvbldyYXBwZXIiLCJtaW5BcmdzIiwibWF4QXJncyIsImZhbGxiYWNrVG9Ob0NhbGxiYWNrIiwiY2JFcnJvciIsIm5vQ2FsbGJhY2siLCJ3cmFwTWV0aG9kIiwid3JhcHBlciIsIlByb3h5IiwidGFyZ2V0TWV0aG9kIiwidGhpc09iaiIsIndyYXBPYmplY3QiLCJ3cmFwcGVycyIsImhhbmRsZXJzIiwicHJveHlUYXJnZXQiLCJyZWNlaXZlciIsImRlc2MiLCJkZWxldGVQcm9wZXJ0eSIsIndyYXBFdmVudCIsIndyYXBwZXJNYXAiLCJhZGRMaXN0ZW5lciIsImhhc0xpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJvblJlcXVlc3RGaW5pc2hlZFdyYXBwZXJzIiwib25SZXF1ZXN0RmluaXNoZWQiLCJyZXEiLCJ3cmFwcGVkUmVxIiwiZ2V0Q29udGVudCIsIm9uTWVzc2FnZVdyYXBwZXJzIiwib25NZXNzYWdlIiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwiZGlkQ2FsbFNlbmRSZXNwb25zZSIsIndyYXBwZWRTZW5kUmVzcG9uc2UiLCJzZW5kUmVzcG9uc2VQcm9taXNlIiwicmVzcG9uc2UiLCJpc1Jlc3VsdFRoZW5hYmxlIiwic2VuZFByb21pc2VkUmVzdWx0IiwiX19tb3pXZWJFeHRlbnNpb25Qb2x5ZmlsbFJlamVjdF9fIiwid3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2siLCJyZXBseSIsIndyYXBwZWRTZW5kTWVzc2FnZSIsImFwaU5hbWVzcGFjZU9iaiIsIndyYXBwZWRDYiIsInNlbmRNZXNzYWdlIiwic3RhdGljV3JhcHBlcnMiLCJkZXZ0b29scyIsIm5ldHdvcmsiLCJvbk1lc3NhZ2VFeHRlcm5hbCIsInRhYnMiLCJzZXR0aW5nTWV0YWRhdGEiLCJwcml2YWN5Iiwic2VydmljZXMiLCJ3ZWJzaXRlcyIsIm9yaWdpbmFsQnJvd3NlciIsInJlZ2V4IiwiaXNQb3RlbnRpYWxDdXN0b21FbGVtZW50TmFtZSIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsImZ1bGZpbGxlZCIsInRocm93IiwiY3JlYXRlSXNvbGF0ZWRFbGVtZW50IiwiY3NzIiwiaXNvbGF0ZUV2ZW50cyIsInBhcmVudEVsZW1lbnQiLCJzaGFkb3ciLCJhdHRhY2hTaGFkb3ciLCJpc29sYXRlZEVsZW1lbnQiLCJoZWFkIiwiZmV0Y2giLCJyZXMiLCJldmVudFR5cGVzIiwicHJpbnQiLCJsb2dnZXIiLCJkZWJ1ZyIsIld4dExvY2F0aW9uQ2hhbmdlRXZlbnQiLCJFdmVudCIsIm5ld1VybCIsIm9sZFVybCIsIl9XeHRMb2NhdGlvbkNoYW5nZUV2ZW50IiwiRVZFTlRfTkFNRSIsImdldFVuaXF1ZUV2ZW50TmFtZSIsImVudHJ5cG9pbnROYW1lIiwiaW1wb3J0IiwiY3JlYXRlTG9jYXRpb25XYXRjaGVyIiwiY3R4IiwiaW50ZXJ2YWwiLCJydW4iLCJVUkwiLCJzZXRJbnRlcnZhbCIsIkNvbnRlbnRTY3JpcHRDb250ZXh0IiwiY29udGVudFNjcmlwdE5hbWUiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJhYm9ydCIsInJlYXNvbiIsImlzSW52YWxpZCIsIm5vdGlmeUludmFsaWRhdGVkIiwiYWJvcnRlZCIsIm9uSW52YWxpZGF0ZWQiLCJjYiIsImJsb2NrIiwiY2xlYXJJbnRlcnZhbCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInN0YXJ0c1dpdGgiLCJfQ29udGVudFNjcmlwdENvbnRleHQiLCJTQ1JJUFRfU1RBUlRFRF9NRVNTQUdFX1RZUEUiLCJjcmVhdGVTaGFkb3dSb290VWkiLCJjc3NJbmplY3Rpb25Nb2RlIiwiZW50cnlDc3MiLCJsb2FkQ3NzIiwicmVwbGFjZUFsbCIsInVpQ29udGFpbmVyIiwic2hhZG93SG9zdCIsIm1vdW50ZWQiLCJtb3VudCIsIm1vdW50VWkiLCJhcHBseVBvc2l0aW9uIiwicXVlcnlTZWxlY3RvciIsIm9uTW91bnQiLCJyZW1vdmUiLCJvblJlbW92ZSIsInBvc2l0aW9uZWRFbGVtZW50IiwicG9zaXRpb24iLCJhbGlnbm1lbnQiLCJib3R0b20iLCJlbmRzV2l0aCIsImdldEFuY2hvciIsImFuY2hvciIsImFwcGVuZCIsInByZXBlbmQiLCJyZXBsYWNlV2l0aCIsIm5leHRFbGVtZW50U2libGluZyIsImdldFVSTCIsIkZVTkNfRVJST1JfVEVYVCIsIk5BTiIsInN5bWJvbFRhZyIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50IiwicGFyc2VJbnQiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJvYmplY3RQcm90byIsIm9iamVjdFRvU3RyaW5nIiwibmF0aXZlTWF4IiwibmF0aXZlTWluIiwiZGVib3VuY2UiLCJ3YWl0IiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJUeXBlRXJyb3IiLCJ0b051bWJlciIsImlzT2JqZWN0IiwiaW52b2tlRnVuYyIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJ0aHJvdHRsZSIsImlzT2JqZWN0TGlrZSIsImlzU3ltYm9sIiwib3RoZXIiLCJpc0JpbmFyeSIsIm5lZWRSZXNwb25zZSIsImZyb21SdW50aW1lIiwiX2Jyb3dzZXIiLCJ3YWl0Rm9yUmVzcG9uc2UiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJhY3RpdmVUYWJJZCIsIl9jYWxsYmFjayIsIndpbmRvd0NhbGxiYWNrIiwiUmVhZGFiaWxpdHkiLCJfZG9jIiwiX2RvY0pTRE9NUGFyc2VyIiwiX19KU0RPTVBhcnNlcl9fIiwiX2FydGljbGVUaXRsZSIsIl9hcnRpY2xlQnlsaW5lIiwiX2FydGljbGVEaXIiLCJfYXJ0aWNsZVNpdGVOYW1lIiwiX2F0dGVtcHRzIiwiX2RlYnVnIiwiX21heEVsZW1zVG9QYXJzZSIsIm1heEVsZW1zVG9QYXJzZSIsIkRFRkFVTFRfTUFYX0VMRU1TX1RPX1BBUlNFIiwiX25iVG9wQ2FuZGlkYXRlcyIsIm5iVG9wQ2FuZGlkYXRlcyIsIkRFRkFVTFRfTl9UT1BfQ0FORElEQVRFUyIsIl9jaGFyVGhyZXNob2xkIiwiY2hhclRocmVzaG9sZCIsIkRFRkFVTFRfQ0hBUl9USFJFU0hPTEQiLCJfY2xhc3Nlc1RvUHJlc2VydmUiLCJDTEFTU0VTX1RPX1BSRVNFUlZFIiwiY2xhc3Nlc1RvUHJlc2VydmUiLCJfa2VlcENsYXNzZXMiLCJrZWVwQ2xhc3NlcyIsIl9zZXJpYWxpemVyIiwic2VyaWFsaXplciIsImVsIiwiX2Rpc2FibGVKU09OTEQiLCJkaXNhYmxlSlNPTkxEIiwiX2FsbG93ZWRWaWRlb1JlZ2V4IiwiYWxsb3dlZFZpZGVvUmVnZXgiLCJSRUdFWFBTIiwidmlkZW9zIiwiRkxBR19TVFJJUF9VTkxJS0VMWVMiLCJGTEFHX1dFSUdIVF9DTEFTU0VTIiwiRkxBR19DTEVBTl9DT05ESVRJT05BTExZIiwibG9nTm9kZSIsImF0dHJQYWlycyIsImF0dHIiLCJsb2NhbE5hbWUiLCJhcmciLCJkdW1wIiwiREVGQVVMVF9UQUdTX1RPX1NDT1JFIiwidW5saWtlbHlDYW5kaWRhdGVzIiwib2tNYXliZUl0c0FDYW5kaWRhdGUiLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiZXh0cmFuZW91cyIsImJ5bGluZSIsInJlcGxhY2VGb250cyIsInNoYXJlRWxlbWVudHMiLCJuZXh0TGluayIsInByZXZMaW5rIiwidG9rZW5pemUiLCJ3aGl0ZXNwYWNlIiwiaGFzQ29udGVudCIsImhhc2hVcmwiLCJzcmNzZXRVcmwiLCJiNjREYXRhVXJsIiwiY29tbWFzIiwianNvbkxkQXJ0aWNsZVR5cGVzIiwiVU5MSUtFTFlfUk9MRVMiLCJESVZfVE9fUF9FTEVNUyIsIkFMVEVSX1RPX0RJVl9FWENFUFRJT05TIiwiUFJFU0VOVEFUSU9OQUxfQVRUUklCVVRFUyIsIkRFUFJFQ0FURURfU0laRV9BVFRSSUJVVEVfRUxFTVMiLCJQSFJBU0lOR19FTEVNUyIsIkhUTUxfRVNDQVBFX01BUCIsIl9wb3N0UHJvY2Vzc0NvbnRlbnQiLCJhcnRpY2xlQ29udGVudCIsIl9maXhSZWxhdGl2ZVVyaXMiLCJfc2ltcGxpZnlOZXN0ZWRFbGVtZW50cyIsIl9jbGVhbkNsYXNzZXMiLCJfcmVtb3ZlTm9kZXMiLCJub2RlTGlzdCIsImZpbHRlckZuIiwiX2lzTGl2ZU5vZGVMaXN0IiwiX3JlcGxhY2VOb2RlVGFncyIsIm5ld1RhZ05hbWUiLCJfc2V0Tm9kZVRhZyIsIl9mb3JFYWNoTm9kZSIsIl9maW5kTm9kZSIsImZpbmQiLCJfc29tZU5vZGUiLCJzb21lIiwiX2V2ZXJ5Tm9kZSIsImV2ZXJ5IiwiX2NvbmNhdE5vZGVMaXN0cyIsIm5vZGVMaXN0cyIsIl9nZXRBbGxOb2Rlc1dpdGhUYWciLCJ0YWdOYW1lcyIsImNvbGxlY3Rpb24iLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNsYXNzTmFtZSIsImNscyIsImZpcnN0RWxlbWVudENoaWxkIiwiYmFzZVVSSSIsImRvY3VtZW50VVJJIiwidG9BYnNvbHV0ZVVSSSIsInVyaSIsImxpbmtzIiwiY2hpbGROb2RlcyIsInJlcGxhY2VDaGlsZCIsIm1lZGlhcyIsIm5ld1NyY3NldCIsInAxIiwicDIiLCJwMyIsIl9pc0VsZW1lbnRXaXRob3V0Q29udGVudCIsIl9yZW1vdmVBbmRHZXROZXh0IiwiX2hhc1NpbmdsZVRhZ0luc2lkZUVsZW1lbnQiLCJfZ2V0TmV4dE5vZGUiLCJfZ2V0QXJ0aWNsZVRpdGxlIiwiY3VyVGl0bGUiLCJvcmlnVGl0bGUiLCJfZ2V0SW5uZXJUZXh0IiwidGl0bGVIYWRIaWVyYXJjaGljYWxTZXBhcmF0b3JzIiwid29yZENvdW50Iiwic3RyIiwiaGVhZGluZ3MiLCJ0cmltbWVkVGl0bGUiLCJoZWFkaW5nIiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJoT25lcyIsImN1clRpdGxlV29yZENvdW50IiwiX3ByZXBEb2N1bWVudCIsIl9yZXBsYWNlQnJzIiwiX25leHROb2RlIiwicmVwbGFjZWQiLCJiclNpYmxpbmciLCJwIiwibmV4dEVsZW0iLCJfaXNQaHJhc2luZ0NvbnRlbnQiLCJfaXNXaGl0ZXNwYWNlIiwicmVwbGFjZW1lbnQiLCJyZWFkYWJpbGl0eSIsIl9wcmVwQXJ0aWNsZSIsIl9jbGVhblN0eWxlcyIsIl9tYXJrRGF0YVRhYmxlcyIsIl9maXhMYXp5SW1hZ2VzIiwiX2NsZWFuQ29uZGl0aW9uYWxseSIsIl9jbGVhbiIsInNoYXJlRWxlbWVudFRocmVzaG9sZCIsInRvcENhbmRpZGF0ZSIsIl9jbGVhbk1hdGNoZWROb2RlcyIsIm1hdGNoU3RyaW5nIiwiX2NsZWFuSGVhZGVycyIsInBhcmFncmFwaCIsImltZ0NvdW50IiwiZW1iZWRDb3VudCIsIm9iamVjdENvdW50IiwiaWZyYW1lQ291bnQiLCJ0b3RhbENvdW50IiwidGJvZHkiLCJjZWxsIiwiX2luaXRpYWxpemVOb2RlIiwiY29udGVudFNjb3JlIiwiX2dldENsYXNzV2VpZ2h0IiwiaWdub3JlU2VsZkFuZEtpZHMiLCJfdGV4dFNpbWlsYXJpdHkiLCJ0ZXh0QSIsInRleHRCIiwidG9rZW5zQSIsIkJvb2xlYW4iLCJ0b2tlbnNCIiwidW5pcVRva2Vuc0IiLCJkaXN0YW5jZUIiLCJfY2hlY2tCeWxpbmUiLCJfaXNWYWxpZEJ5bGluZSIsIl9nZXROb2RlQW5jZXN0b3JzIiwibWF4RGVwdGgiLCJfZ3JhYkFydGljbGUiLCJwYWdlIiwiaXNQYWdpbmciLCJwYWdlQ2FjaGVIdG1sIiwic3RyaXBVbmxpa2VseUNhbmRpZGF0ZXMiLCJfZmxhZ0lzQWN0aXZlIiwiZWxlbWVudHNUb1Njb3JlIiwic2hvdWxkUmVtb3ZlVGl0bGVIZWFkZXIiLCJfYXJ0aWNsZUxhbmciLCJfaXNQcm9iYWJseVZpc2libGUiLCJfaGVhZGVyRHVwbGljYXRlc1RpdGxlIiwiX2hhc0FuY2VzdG9yVGFnIiwiY2hpbGROb2RlIiwiX2dldExpbmtEZW5zaXR5IiwibmV3Tm9kZSIsIl9oYXNDaGlsZEJsb2NrRWxlbWVudCIsImNhbmRpZGF0ZXMiLCJlbGVtZW50VG9TY29yZSIsImlubmVyVGV4dCIsInNjb3JlRGl2aWRlciIsInRvcENhbmRpZGF0ZXMiLCJjbCIsImNhbmRpZGF0ZSIsImNhbmRpZGF0ZVNjb3JlIiwidCIsImFUb3BDYW5kaWRhdGUiLCJuZWVkZWRUb0NyZWF0ZVRvcENhbmRpZGF0ZSIsInBhcmVudE9mVG9wQ2FuZGlkYXRlIiwiYWx0ZXJuYXRpdmVDYW5kaWRhdGVBbmNlc3RvcnMiLCJNSU5JTVVNX1RPUENBTkRJREFURVMiLCJsaXN0c0NvbnRhaW5pbmdUaGlzQW5jZXN0b3IiLCJhbmNlc3RvckluZGV4IiwibGFzdFNjb3JlIiwic2NvcmVUaHJlc2hvbGQiLCJwYXJlbnRTY29yZSIsInNpYmxpbmdTY29yZVRocmVzaG9sZCIsInNsIiwiY29udGVudEJvbnVzIiwibGlua0RlbnNpdHkiLCJub2RlQ29udGVudCIsIm5vZGVMZW5ndGgiLCJwYXJzZVN1Y2Nlc3NmdWwiLCJ0ZXh0TGVuZ3RoIiwiX3JlbW92ZUZsYWciLCJhcnRpY2xlRGlyIiwiX3VuZXNjYXBlSHRtbEVudGl0aWVzIiwiaHRtbEVzY2FwZU1hcCIsImhleCIsIm51bVN0ciIsIm51bSIsIl9nZXRKU09OTEQiLCJzY3JpcHRzIiwianNvbkxkRWxlbWVudCIsInBhcnNlZCIsInBhcnNlIiwiaXQiLCJoZWFkbGluZSIsIm5hbWVNYXRjaGVzIiwiaGVhZGxpbmVNYXRjaGVzIiwiYXV0aG9yIiwiZGVzY3JpcHRpb24iLCJleGNlcnB0IiwicHVibGlzaGVyIiwic2l0ZU5hbWUiLCJkYXRlUHVibGlzaGVkIiwiX2dldEFydGljbGVNZXRhZGF0YSIsImpzb25sZCIsIm1ldGFFbGVtZW50cyIsInByb3BlcnR5UGF0dGVybiIsIm5hbWVQYXR0ZXJuIiwiZWxlbWVudE5hbWUiLCJlbGVtZW50UHJvcGVydHkiLCJtYXRjaGVzIiwicHVibGlzaGVkVGltZSIsIl9pc1NpbmdsZUltYWdlIiwiX3Vud3JhcE5vc2NyaXB0SW1hZ2VzIiwiaW1ncyIsIm5vc2NyaXB0cyIsIm5vc2NyaXB0IiwidG1wIiwicHJldkVsZW1lbnQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldkltZyIsIm5ld0ltZyIsImF0dHJOYW1lIiwiX3JlbW92ZVNjcmlwdHMiLCJub3JtYWxpemVTcGFjZXMiLCJfZ2V0Q2hhckNvdW50IiwiY3VyIiwibGlua0xlbmd0aCIsImxpbmtOb2RlIiwiY29lZmZpY2llbnQiLCJ3ZWlnaHQiLCJpc0VtYmVkIiwiX2dldFJvd0FuZENvbHVtbkNvdW50IiwidHJzIiwiY29sdW1uc0luVGhpc1JvdyIsImNlbGxzIiwiaiIsInRhYmxlcyIsIl9yZWFkYWJpbGl0eURhdGFUYWJsZSIsImRhdGF0YWJsZSIsImNhcHRpb24iLCJkYXRhVGFibGVEZXNjZW5kYW50cyIsImRlc2NlbmRhbnRFeGlzdHMiLCJzaXplSW5mbyIsInBhcnRzIiwiZXhlYyIsInNyY0NvdWxkQmVSZW1vdmVkIiwiYjY0c3RhcnRzIiwiYjY0bGVuZ3RoIiwiY29weVRvIiwiX2dldFRleHREZW5zaXR5IiwidGFncyIsImlzRGF0YVRhYmxlIiwiaXNMaXN0IiwibGlzdExlbmd0aCIsImxpc3ROb2RlcyIsImxpIiwiaGVhZGluZ0RlbnNpdHkiLCJlbWJlZHMiLCJjb250ZW50TGVuZ3RoIiwiaGF2ZVRvUmVtb3ZlIiwibGlfY291bnQiLCJlbmRPZlNlYXJjaE1hcmtlck5vZGUiLCJoZWFkaW5nTm9kZXMiLCJzaG91bGRSZW1vdmUiLCJudW1UYWdzIiwianNvbkxkIiwicGFyYWdyYXBocyIsImlzTm9kZVZpc2libGUiLCJpc1Byb2JhYmx5UmVhZGVyYWJsZSIsInZpc2liaWxpdHlDaGVja2VyIiwiZGVmYXVsdE9wdGlvbnMiLCJtaW5TY29yZSIsIm1pbkNvbnRlbnRMZW5ndGgiLCJub2RlcyIsImJyTm9kZXMiLCJzY29yZSIsInRleHRDb250ZW50TGVuZ3RoIiwic3FydCIsInJ1bGVzIiwidGFibGVDZWxsIiwidGFibGVSb3ciLCJib3JkZXJDZWxscyIsImFsaWduTWFwIiwiY2VudGVyIiwiaXNIZWFkaW5nUm93IiwiYWxpZ24iLCJ0YWJsZVNlY3Rpb24iLCJ0ciIsImlzRmlyc3RUYm9keSIsInR1cm5kb3duU2VydmljZSIsImtlZXAiLCJhZGRSdWxlIiwiZGVzdGluYXRpb24iLCJ0cmltTGVhZGluZ05ld2xpbmVzIiwidHJpbVRyYWlsaW5nTmV3bGluZXMiLCJpbmRleEVuZCIsImJsb2NrRWxlbWVudHMiLCJpc0Jsb2NrIiwidm9pZEVsZW1lbnRzIiwiaXNWb2lkIiwiaGFzVm9pZCIsIm1lYW5pbmdmdWxXaGVuQmxhbmtFbGVtZW50cyIsImlzTWVhbmluZ2Z1bFdoZW5CbGFuayIsImhhc01lYW5pbmdmdWxXaGVuQmxhbmsiLCJsaW5lQnJlYWsiLCJoTGV2ZWwiLCJoZWFkaW5nU3R5bGUiLCJ1bmRlcmxpbmUiLCJibG9ja3F1b3RlIiwibGFzdEVsZW1lbnRDaGlsZCIsImxpc3RJdGVtIiwiYnVsbGV0TGlzdE1hcmtlciIsImluZGVudGVkQ29kZUJsb2NrIiwiY29kZUJsb2NrU3R5bGUiLCJmZW5jZWRDb2RlQmxvY2siLCJsYW5ndWFnZSIsImZlbmNlQ2hhciIsImZlbmNlIiwiZmVuY2VTaXplIiwiZmVuY2VJbkNvZGVSZWdleCIsImhvcml6b250YWxSdWxlIiwiaW5saW5lTGluayIsImxpbmtTdHlsZSIsImNsZWFuQXR0cmlidXRlIiwicmVmZXJlbmNlTGluayIsInJlZmVyZW5jZSIsImxpbmtSZWZlcmVuY2VTdHlsZSIsInJlZmVyZW5jZXMiLCJlbXBoYXNpcyIsImVtRGVsaW1pdGVyIiwic3Ryb25nIiwic3Ryb25nRGVsaW1pdGVyIiwiaGFzU2libGluZ3MiLCJpc0NvZGVCbG9jayIsImV4dHJhU3BhY2UiLCJ0aXRsZVBhcnQiLCJhdHRyaWJ1dGUiLCJSdWxlcyIsIl9rZWVwIiwiX3JlbW92ZSIsImJsYW5rUnVsZSIsImJsYW5rUmVwbGFjZW1lbnQiLCJrZWVwUmVwbGFjZW1lbnQiLCJkZWZhdWx0UnVsZSIsImRlZmF1bHRSZXBsYWNlbWVudCIsInJ1bGUiLCJmb3JOb2RlIiwiaXNCbGFuayIsImZpbmRSdWxlIiwiZmlsdGVyVmFsdWUiLCJjb2xsYXBzZVdoaXRlc3BhY2UiLCJpc1ByZSIsInByZXZUZXh0Iiwia2VlcExlYWRpbmdXcyIsInByZXYiLCJjYW5QYXJzZUhUTUxOYXRpdmVseSIsIlBhcnNlciIsIkRPTVBhcnNlciIsImNhblBhcnNlIiwicGFyc2VGcm9tU3RyaW5nIiwiY3JlYXRlSFRNTFBhcnNlciIsInNob3VsZFVzZUFjdGl2ZVgiLCJBY3RpdmVYT2JqZWN0IiwiZGVzaWduTW9kZSIsIndyaXRlIiwiY2xvc2UiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJ1c2VBY3RpdmVYIiwiSFRNTFBhcnNlciIsIlJvb3ROb2RlIiwiaHRtbFBhcnNlciIsImdldEVsZW1lbnRCeUlkIiwiY2xvbmVOb2RlIiwicHJlZm9ybWF0dGVkQ29kZSIsImlzUHJlT3JDb2RlIiwiX2h0bWxQYXJzZXIiLCJOb2RlIiwiaXNDb2RlIiwiZmxhbmtpbmdXaGl0ZXNwYWNlIiwiZWRnZXMiLCJlZGdlV2hpdGVzcGFjZSIsImxlYWRpbmdBc2NpaSIsImlzRmxhbmtlZEJ5V2hpdGVzcGFjZSIsImxlYWRpbmdOb25Bc2NpaSIsInRyYWlsaW5nQXNjaWkiLCJ0cmFpbGluZ05vbkFzY2lpIiwic2lkZSIsInJlZ0V4cCIsImlzRmxhbmtlZCIsInJlZHVjZSIsImVzY2FwZXMiLCJUdXJuZG93blNlcnZpY2UiLCJkZWZhdWx0cyIsIm91dGVySFRNTCIsInR1cm5kb3duIiwiY2FuQ29udmVydCIsIm91dHB1dCIsInByb2Nlc3MiLCJwb3N0UHJvY2VzcyIsInVzZSIsInBsdWdpbiIsImFjY3VtdWxhdG9yIiwicmVwbGFjZW1lbnRGb3JOb2RlIiwiczEiLCJzMiIsIm5scyIsInNlcGFyYXRvciIsInRpZHlNYXJrZG93biIsIm1hcmtkb3duIiwibm9ybWFsaXplZE1hcmtkb3duIiwiX21hdGNoIiwiY2xlYW5UZXh0IiwiY2xlYW5VcmwiLCJpbWdVcmwiLCJsaW5rVXJsIiwiY2xlYW5BbHQiLCJjbGVhbkltZ1VybCIsImNsZWFuTGlua1VybCIsImdldFR1cm5kb3duIiwidHVybkRvd25TZXJ2aWNlIiwiX2NvbnRlbnQiLCJjb252ZXJ0SFRNTFRvTWFya2Rvd24iLCJ0dXJuRG93blBsdWdpbnMiLCJ0b0JlVHVybmVkVG9NZCIsImNvbnRlbnRUZXh0IiwidmFuaWxsYVR1cm5Eb3duU2VydmljZSIsImVycjIiLCJjbGVhbk1hcmtkb3duIiwibWFya2Rvd25Db250ZW50IiwiY2xlYW5lZE1hcmtkb3duIiwicHJlcHJvY2Vzc0h0bWxDb250ZW50IiwiaHRtbENvbnRlbnQiLCJEb2N1bWVudCIsIkhUTUxFbGVtZW50IiwiRG9jdW1lbnRGcmFnbWVudCIsImdldE1hcmtkb3duIiwibWQiLCJzYXZlTW9ja2VkUmVzb3VyY2UiLCJwYWdlQ29udGVudCIsInJlc291cmNlSWQiLCJyZXNvdXJjZVR5cGUiLCJpc1B1YmxpYyIsImNvbGxhYkVuYWJsZWQiLCJjdXJyZW50TW9ja1Jlc291cmNlIiwidXNlU3luY1dlYmxpbmtSZXNvdXJjZU1ldGEiLCJtZXNzYWdlTGlzdGVuZXJFdmVudFJlZiIsIm1ha2VUZW1wUmVzb3VyY2VBbmRTYXZlIiwib25NZXNzYWdlSGFuZGxlciIsImluaXRNZXNzYWdlTGlzdGVuZXIiLCJjbGVhckV2ZW50IiwiY2hlY2tQYWdlVW5zdXBwb3J0ZWQiLCJwYWdlVXJsIiwiY2hlY2tCcm93c2VyU2V0dGluZ1BhZ2UiLCJjaGVja0Jyb3dzZXJFeHRlbnNpb25TdG9yZVBhZ2UiLCJBcHAiLCJpc0RvbVZpc2liaWxpdHlSZWYiLCJ2aXNpYmlsaXR5U3RhdGUiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiY29sdW1uTnVtYmVyIiwiRGV2TG9nZ2VyIiwiaXNEZXZlbG9wbWVudCIsImRlYnVnQ2xpY2tDb3VudCIsImxhc3RDbGlja1RpbWUiLCJjbGlja1RpbWVvdXQiLCJjaGVja0RldmVsb3BtZW50TW9kZSIsImluaXRpYWxpemVMb2dnZXIiLCJzZXR1cFN0b3JhZ2VMaXN0ZW5lciIsIndhc0VuYWJsZWQiLCJyZWZyZXNoRGVidWdTdGF0ZSIsImhhbmRsZURlYnVnQ2xpY2siLCJzaG93TWVzc2FnZSIsInVwZGF0ZUNsaWNrQ291bnQiLCJyZXNldENsaWNrQ291bnRlckFmdGVyRGVsYXkiLCJzaG91bGRTaG93SGludHMiLCJzaG93QWN0aXZhdGlvbkhpbnRzIiwic2hvdWxkVG9nZ2xlRGVidWdNb2RlIiwidG9nZ2xlRGVidWdNb2RlIiwidGltZVNpbmNlTGFzdENsaWNrIiwicmVtYWluaW5nQ2xpY2tzIiwiaXNDdXJyZW50bHlFbmFibGVkIiwiZGVhY3RpdmF0ZURlYnVnTW9kZSIsImFjdGl2YXRlRGVidWdNb2RlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIl9lIiwicmVtb3ZlSXRlbSIsImNoZWNrTG9jYWxTdG9yYWdlRmxhZyIsImNoZWNrRG9jdW1lbnRBdHRyaWJ1dGUiLCJjaGVja0J1aWxkRW52aXJvbm1lbnQiLCJjaGVja1Byb2Nlc3NFbnZpcm9ubWVudCIsImNoZWNrVXJsUGFyYW1ldGVyIiwiZ2V0SXRlbSIsIl9zdG9yYWdlRXJyb3IiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJleGNsdWRlTWF0Y2hlcyIsIm1haW4iLCJ1aSIsIlJlYWN0RE9NIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtB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QUFBQSxNQUMxQztBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUtPLFFBQU02MEgsV0FBUyxJQUFJdW1CLFVBQUFBOztBQ2pRMUIsUUFBQSxhQUFlNWpJLG9CQUFvQjtBQUFBLElBQ2pDazBILFNBQVMsQ0FBQyxZQUFZO0FBQUE7QUFBQSxJQUV0QnZVLGtCQUFrQjtBQUFBLElBQ2xCcW1CLGdCQUFnQixDQUNkLHNCQUNBLDBCQUNBLDBCQUNBLHlCQUFBO0FBQUEsSUFHRixNQUFNQyxLQUFLaG9CLEtBQUs7QUFDZGhILGlCQUFXLGdCQUFnQjtBQUUzQm9HLGVBQU9DLE1BQU0sa0JBQWtCVyxHQUFHO0FBRWxDLFlBQU1pb0IsS0FBSyxNQUFNeG1CLG1CQUFtQnpCLEtBQUs7QUFBQSxRQUN2Q3IzSCxNQUFNO0FBQUEsUUFDTjg1SCxVQUFVO0FBQUEsUUFDVk0sUUFBUTtBQUFBLFFBQ1JWLFFBQVF2ckUsV0FBVztBQUNqQixnQkFBTS9QLFFBQU9taEcsT0FBU3h5QixXQUFXNStELFNBQVM7QUFDMUMvUCxVQUFBQSxNQUFLdDZDLG1EQUFRNjRJLEtBQUEsQ0FBQSxHQUFELFFBQUEsT0FBQTtBQUFBLFlBQUF6cEksVUFBQTtBQUFBLFlBQUFDLFlBQUE7QUFBQSxZQUFBNHBJLGNBQUE7QUFBQSxhQUFBLElBQUssQ0FBRTtBQUNuQixpQkFBTzMrRjtBQUFBQSxRQUNUO0FBQUEsUUFDQXc3RSxVQUFXeDdFLENBQUFBLFVBQVM7QUFDbEJBLFVBQUFBLFNBQUFBLGdCQUFBQSxNQUFNMHVFO0FBQUFBLFFBQ1I7QUFBQSxNQUNGLENBQUM7QUFHRHd5QixTQUFHaG1CLE1BQUE7QUFBQSxJQUNMO0FBQUEsRUFDRixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDMsNSw2LDcsOCw5LDExLDEzLDE0LDE2LDE4LDE5LDIwLDIxXX0=
